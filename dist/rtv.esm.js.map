{"version":3,"file":"rtv.esm.js","sources":["../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isArray.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isString.js","../src/lib/types.js","../src/lib/qualiiers.js","../src/lib/Enumeration.js","../src/lib/impl.js","../src/rtv.js"],"sourcesContent":["/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n","//// Type Definitions \\\\\\\\\n\n/**\n * <h2>Types</h2>\n *\n * <h3>Primitives</h3>\n *\n * In RTV.js, a primitive is considered to be one of the following types:\n *\n * - `string` (note that `new String('s')` does not produce a _primitive_, it\n *   produces an _object_, and should generally be avoided).\n * - `boolean` (note that `new Boolean(true)` does not produce a _primitive_,\n *   it produces an _object_, and should generally be avoided).\n * - `number` (note that `new Number(1)` does not produce a _primitive_,\n *   it produces an _object_, and should generally be avoided).\n * - `Symbol`\n * - `null`\n * - `undefined`\n *\n * <h3>Rules Per Qualifiers</h3>\n *\n * {@link rtvref.qualifiers Qualifiers} state basic rules. Unless otherwise stated,\n *  every type herein abides by those basic rules. Each type will also impose\n *  additional rules specific to the type of value it represents.\n *\n * For example, while the {@link rtvref.types.FINITE FINITE} type states that the\n *  value must not be `NaN`, `+Infinity`, nor `-Infinity`; it could be `null` if\n *  the qualifier used is `EXPECTED`; and it could be `undefined` if the qualifier\n *  used is `OPTIONAL`.\n *\n * @namespace rtvref.types\n */\n\n/**\n * <h3>Type Arguments</a></h3>\n *\n * Some types will accept, or may even expect, one or more arguments. Each type\n *  will specify whether it has arguments, and if they're optional or required.\n *  Arguments are specified as a single object immediately following a type in an\n *  __Array__ {@link rtvref.types.typeset typeset} (i.e. an Array must be used as\n *  the typeset in order to provide arguments for a type).\n *\n * If a type does not accept any arguments, but an arguments object is provided,\n *  it will simply be ignored (i.e. it will __not__ be treated as a nested\n *  {@link rtvref.shape_descriptor shape descriptor}).\n *\n * An arguments object immediately follows its type in a typeset, such as\n *  `[PLAIN_OBJECT, {hello: STRING}]`. This would specify the value must be a\n *  {@link rtvref.types.PLAIN_OBJECT plain object} with a shape that includes a\n *  property named 'hello', that property being a\n *  {@link rtvref.qualifiers.REQUIRED required} {@link rtvref.types.STRING string}.\n *\n * @typedef {Object} rtvref.types.type_arguments\n */\n\n/**\n * <h3>Collection Descriptor</h3>\n *\n * Describes the keys and values in a collection-based object, which is one of\n *  the following types:\n *\n * - {@link rtvref.types.MAP_OBJECT MAP_OBJECT}\n * - {@link rtvref.types.MAP MAP}\n * - {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * - {@link rtvref.types.SET SET} (with some exceptions)\n * - {@link rtvref.types.WEAK_SET WEAK_SET} (with some exceptions)\n *\n * Note that an {@link rtvref.types.ARRAY ARRAY} is __not__ included in this list\n *  because the array type has special syntax for describing the type of its items.\n *\n * For example, the following descriptors both verify a collection of 3-letter\n *  string keys (upper- or lowercase) to finite numbers:\n *\n * - `{keyExp: '[a-z]{3}', keyExpFlags: 'i', values: rtv.t.FINITE}`\n * - `{keyExp: '[a-zA-Z]{3}', values: rtv.t.FINITE}`\n *\n * @typedef {Object} rtvref.types.collection_descriptor\n * @property {rtvref.types.typeset} [keys] Optional. A typeset describing each key\n *  in the collection.\n *\n * The type of collection being described may restrict the types that this typeset\n *  can include. For example, the {@link rtvref.types.MAP_OBJECT MAP_OBJECT} collection\n *  only supports the {@link rtvref.types.STRING STRING} type due to the nature of\n *  its JavaScript `Object`-based implementation.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {String} [keyExp] Optional. A string-based regular expression\n *  describing the names of keys (own-enumerable properties) found in the\n *  collection.\n *\n * By default, there are no restrictions on key names. This expression is only\n *  used if the `keys` typeset includes the {@link rtvref.types.STRING STRING} type.\n *\n * For example, to require numerical keys, the following expression could be\n *  used: `'^\\\\d+$'`.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {String} [keyExpFlags] Optional. A string specifying any flags to use\n *  with the regular expression specified in `keyExp`. If this property is _falsy_,\n *  default `RegExp` flags will be used. Ignored if `keyExp` is not specified, or\n *  does not apply per the `keys` typeset.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {rtvref.types.typeset} [values] Optional. A typeset describing each value\n *  in the collection. Defaults to the {@link rtvref.types.ANY ANY} type which allows\n *  _anything_. All values must match this typeset (but the collection is not\n *  required to have any entries/properties to be considered valid, unless\n *  `count` is specified).\n *\n * For example, to require arrays of non-empty string values, the following\n *  typeset could be used: `[[types.STRING]]`.\n *\n * @property {Number} [count=-1] Optional. The number of entries expected in\n *  the collection. A negative value allows for any number of entries. Zero\n *  requires an empty collection.\n *\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n * @see {@link rtvref.types.SET}\n * @see {@link rtvref.types.WEAK_SET}\n */\n\n/**\n * <h3>Typeset</h3>\n *\n * Describes the possible types for a given value. It can be any one of the following\n *  JavaScript types:\n *\n * - `Object`: For the root or a nested {@link rtvref.shape_descriptor shape descriptor}\n *   of _implied_ {@link rtvref.types.OBJECT OBJECT} type (unless qualified with a specific\n *   object type like {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, for example, when\n *   using the `Array` notation, e.g. `[PLAIN_OBJECT, {...}]`).\n * - `String`: For a single type, such as {@link rtvref.types.FINITE 'FINITE'}\n *   for a finite number.\n * - `Function`: For a {@link rtvref.types.property_validator property validator}\n *   that will verify the value of the property using custom code. Only one validator\n *   can be specified for a given typeset, and it will only be called if the value\n *   was verified against at least one of the other types listed (regardless of the\n *   validator function's position when specified in a typeset array). If no other types\n *   were listed (i.e. using the `Array` form, as described above), then the validator\n *   is called immediately.\n * - `Array`: For multiple type possibilities, optionally {@link rtvref.qualifiers qualified},\n *   using an __OR__ conjunction, which means the value of the property being described must\n *   be at _least one_ of the types listed, but not all. Matching is done in a short-circuit\n *   fashion, from the first to the last element in the typeset. If a simpler type is\n *   likely, it's more performant to specify those first in the typeset to avoid a match\n *   attempt on a nested shape or array.\n *   - An Array is necessary to {@link rtvref.qualifiers qualify} the typeset as not\n *     required (see _Typeset Qualifiers_ below).\n *   - An Array is also necessary if a type needs or requires\n *     {@link rtvref.types.type_arguments arguments}.\n *   - If the first element is an `Object`, it's treated as a nested\n *     {@link rtvref.shape_descriptor shape descriptor} describing an object of the\n *     default `OBJECT` type. To include a shape descriptor at any other position\n *     within the array, it __must__ be preceded by a type, even if the default\n *     `OBJECT` type is being used (i.e. `OBJECT` must be specified as the type).\n *   - If the first element is an `Array`, it's treated as a nested list with an\n *     implied `ARRAY` type, e.g. `[BOOLEAN, [STRING, FINITE]]` would describe a\n *     property that should be a boolean, or an array of non-empty strings or finite\n *     numbers.\n *   - If the first element is a `Function`, it's treated as a property validator.\n *\n * <h4>Typeset Qualifiers</h4>\n *\n * All typesets use an _implied_ {@link rtvref.qualifiers.REQUIRED required}\n *  qualifier unless otherwise specified. To qualify a typeset, a\n *  {@link rtvref.qualifiers qualifier} may be specified as the __first__ element\n *  in the `Array` form (if specified, it must be the first element). For example,\n *  `{note: [EXPECTED, STRING]}` would describe an object with a 'note' property\n *  that is an expected, but not required, string, which could therefore be either\n *  empty or even `null`. The `Array` form must be used in order to qualify a\n *  typeset as other than required, and the qualifier applies to all immediate\n *  types in the typeset (which means each nested typeset can have its own qualifier).\n *\n * <h4>Example: Object</h4>\n *\n * <pre><code>const contactShape = {\n *   name: rtv.t.STRING, // required, non-empty, string\n *   tags: [rtv.t.ARRAY, [rtv.t.STRING]], // required array of non-empty strings\n *   // tags: [[rtv.t.STRING]], // same as above, but using shortcut array format\n *   details: { // required nested object of type `rtv.t.OBJECT` (default)\n *     birthday: [rtv.q.EXPECTED, rtv.t.DATE] // Date (could be null)\n *   },\n *   notes: [rtv.q.OPTIONAL, rtv.t.STRING, function(value) { // optional string...\n *     return !value || value.length < 500; // ...less than 500 characters long, if specified\n *   }]\n * };\n *\n * const contact = {\n *   name: 'John Doe',\n *   tags: ['colleagues', 'sports'],\n *   details: {\n *     birthday: null // not specified\n *   }\n * };\n *\n * rtv.verify(contact, contactShape); // OK\n *\n * const walletShape = {\n *   contacts: [[contactShape]], // list of contacts using nested shape\n *   address: {\n *     street: rtv.t.STRING\n *     // ...\n *   },\n *   money: rtv.t.FINITE\n * };\n *\n * rtv.verify({\n *   contacts: [contact],\n *   address: {street: '123 Main St'},\n *   money: 100\n * }, walletShape); // OK\n * </code></pre>\n *\n * <h4>Example: String</h4>\n *\n * <pre><code>rtv.verify('foo', rtv.t.STRING); // OK\n * rtv.verify('foo', rtv.t.FINITE); // ERROR\n * </code></pre>\n *\n * <h4>Example: Array</h4>\n *\n * <pre><code>const typeset = [rtv.t.STRING, rtv.t.FINITE]; // non-empty string, or finite number\n * rtv.verify('foo', typeset); // OK\n * rtv.verify(1, typeset); // OK\n * </code></pre>\n *\n * <h4>Example: Function</h4>\n *\n * <pre><code>rtv.verify(123, (v) => v > 100); // OK\n * rtv.verify('123', [rtv.t.STRING, (v) => parseInt(v) > 100); // OK\n * </code></pre>\n *\n * <h4>Example: Alternate Qualifier</h4>\n *\n * <pre><code>const person = {\n *   name: rtv.t.STRING, // required, non-empty\n *   age: [rtv.q.OPTIONAL, rtv.t.FINITE, (v) => v >= 18] // 18 or older, if specified\n * };\n * rtv.verify({name: 'Bob'}, person); // OK\n * rtv.verify({name: ''}, person); // ERROR\n * rtv.verify({name: 'Steve', age: 17}, person); // ERROR\n * rtv.verify({name: 'Steve', age: null}, person); // OK\n * </code></pre>\n *\n * @typedef {(Object|String|Array|Function)} rtvref.types.typeset\n */\n\n/**\n * <h3>Fully-Qualified Typeset</h3>\n *\n * A {@link rtvref.types.typeset typeset} expressed without any shortcut notations\n *  to make it easier to parse, especially as the `match` parameter given to a\n *  {@link rtvref.types.property_validator property validator}.\n *\n * For example:\n *\n * - `STRING` -> `[REQUIRED, STRING]`\n * - `{note: STRING}` -> `[REQUIRED, OBJECT, {note: [REQUIRED, STRING]}]`\n * - `[[FINITE]]` -> `[REQUIRED, ARRAY, [REQUIRED, FINITE]]`\n *\n * @typedef {Array} rtvref.types.fully_qualified_typeset\n */\n\n/**\n * <h3>Property Validator</h3>\n *\n * A function used as a {@link rtvref.types.typeset typeset}, or as a subset to\n *  a typeset, to provide custom verification of the value being verified.\n *\n * A typeset may only have one validator, and the validator is only called if\n *  the value being verified was verified by at least one type in the typeset.\n *  The position of the validator within the typeset (if the typeset is an array),\n *  does not change when the validator is invoked (i.e. before one type or after\n *  another; it's always called last, if called at all).\n *\n * There is one disadvantage to using a property validator: It cannot be de/serialized\n *  via JSON, which means it cannot be transmitted or persisted. One option would be\n *  to customize the de/serialization to JSON by serializing the validator to a\n *  special object with properties that would inform the deserialization process\n *  on how to reconstruct the validator dynamically.\n *\n * @typedef {Function} rtvref.types.property_validator\n * @param {*} value The value being verified.\n * @param {Array} match A __first-level__, {@link rtvref.types.fully_qualified_typeset fully-qualified}\n *  typeset describing the type that matched. This means the first level of this\n *  subset of `typeset` (the 3rd parameter) is fully-qualified, but any nested\n *  {@link rtvref.shape_descriptor shape descriptors} or arrays will not be (they\n *  will remain references to the same shapes/arrays in `typeset`). For example,\n *  if the given typeset was `[PLAIN_OBJECT, {note: STRING}]`, this parameter\n *  would be a new typeset array `[REQUIRED, PLAIN_OBJECT, {note: STRING}]`,\n *  and the `typeset` parameter would be the original `[PLAIN_OBJECT, {note: STRING}]`.\n * @param {rtvref.types.typeset} typeset Reference to the typeset used for\n *  verification. Note that the typeset may contain nested typeset(s), and may\n *  be part of a larger parent typeset (though there would be no reference to\n *  the parent typeset, if any). This typeset is as it was specified in the\n *  parent shape, and therefore it may not be fully-qualified.\n * @returns {boolean} `true` to verify the value, `false` to reject it.\n */\n\n/**\n * The any type is special in that it allows _anything_, which includes `null`\n *  and `undefined` values. Because of this, it's the most liberal in terms of\n *  types as well as qualifiers. A more specific type should be used whenever\n *  possible to ensure a higher degree of confidence in the value being validated.\n *\n * Any rules per qualifiers:\n *\n * - REQUIRED: Property must be defined _somewhere_ in the prototype chain, but\n *   its value can be anything, including `null` and `undefined`.\n * - EXPECTED: Same rules as REQUIRED.\n * - OPTIONAL: Since this qualifier removes the property's need for existence\n *   in the prototype chain, it renders the verification moot (i.e. the property\n *   might as well not be included in the {@link rtvref.shape_descriptor shape descriptor}\n *   unless a {@link rtvref.types.property_validator property validator} is being\n *   used to do customized verification.\n *\n * @name rtvref.types.ANY\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const ANY = 'any';\n\n// TODO: Add 'exp: string' and 'expFlags: string' args (strings because of JSON requirement...)\n//  for a regular expression test. Similar prop names to collection_descriptor.\n/**\n * {@link rtvref.types.STRING STRING} arguments.\n * @typedef {Object} rtvref.types.STRING_args\n * @property {String} [exact] An exact value to match.\n * @property {Number} [min] Minimum length. Defaults to 1 for a `REQUIRED` string,\n *  and 0 for an `EXPECTED` or `OPTIONAL` string. Ignored if `exact` is specified.\n * @property {Number} [max=-1] Maximum length. -1 means no maximum. Ignored if `exact`\n *  is specified.\n * @property {String} [partial] A partial value to match (must be somewhere within the string).\n *  Ignored if `exact` is specified.\n * @see {@link rtvref.qualifiers}\n */\n\n/**\n * String rules per qualifiers:\n *\n * - REQUIRED: Must be a non-empty string.\n * - EXPECTED | OPTIONAL: Can be an empty string.\n *\n * Arguments (optional): {@link rtvref.types.STRING_args}\n *\n * @name rtvref.types.STRING\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const STRING = 'string';\n\n/**\n * Boolean rules per qualifiers: Must be a boolean.\n * @name rtvref.types.BOOLEAN\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const BOOLEAN = 'boolean';\n\n/**\n * Symbol rules per qualifiers: Must be a symbol.\n * @name rtvref.types.SYMBOL\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const SYMBOL = 'symbol';\n\n/**\n * Numeric value arguments. Applies to all numeric types.\n * @typedef {Object} rtvref.types.numeric_args\n * @property {String} [exact] An exact value to match.\n * @property {Number} [min] Minimum inclusive value. Default varies per type.\n *  Ignored if `exact` is specified.\n * @property {Number} [max] Maximum inclusive value. Default varies per type.\n *  Ignored if `exact` is specified.\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.NUMBER}\n * @see {@link rtvref.types.FINITE}\n * @see {@link rtvref.types.INT}\n * @see {@link rtvref.types.FLOAT}\n */\n\n/**\n * Number rules per qualifiers:\n *\n * - REQUIRED: Cannot be `NaN`, but could be `+Infinity`, `-Infinity`.\n * - EXPECTED | OPTIONAL: Could be `NaN`, `+Infinity`, `-Infinity`.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.NUMBER\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.FINITE}\n */\nexport const NUMBER = 'number';\n\n/**\n * Finite rules per qualifiers: Cannot be `NaN`, `+Infinity`, `-Infinity`. The\n *  value can be either a safe integer or a {@link rtvref.types.FLOAT floating point number}.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.FINITE\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.NUMBER}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n */\nexport const FINITE = 'finite';\n\n/**\n * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} integer,\n *  but is not necessarily _safe_.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.INT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.FINITE}\n * @see {@link rtvref.types.FLOAT}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n */\nexport const INT = 'int';\n\n/**\n * Float rules per qualifiers: Must be a finite floating point number.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.FLOAT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.INT}\n */\nexport const FLOAT = 'float';\n\n/**\n * An _any_ object is anything that is not a {@link rtvref.types primitive}, which\n *  means it includes the `Array` type, as well as functions and arguments. To\n *  test for an array, use the {@link rtvref.types.ARRAY ARRAY} type. To\n *  test for a function, use the {@link rtvref.types.FUNCTION FUNCTION} type.\n *\n * The following values are considered any objects:\n *\n * - `{}`\n * - `new Object()`\n * - `[]`\n * - `new Array()`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `/re/`\n * - `new RegExp('re')`\n * - `new function() {}` (class instance)\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n *\n * The following values __are not__ considered any objects (because they are\n *  considered to be {@link rtvref.types primitives}):\n *\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null` (NOTE: `typeof null === 'object'` in JavaScript; the `ANY_OBJECT`\n *   type allows testing for this undesirable fact)\n * - `undefined`\n *\n * Any object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.shape_descriptor}\n *\n * @name rtvref.types.ANY_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const ANY_OBJECT = 'anyObject';\n\n/**\n * An object is one that extends from `JavaScript.Object` and is not\n *  a {@link rtvref.types.FUNCTION function}, {@link rtvref.types.ARRAY array},\n *  {@link rtvref.types.REGEXP regular expression}, function arguments object,\n *  {@link rtvref.types.MAP map}, {@link rtvref.types.WEAK_MAP weak map},\n *  {@link rtvref.types.SET set}, {@link rtvref.types.WEAK_SET weak set}, nor a\n *  {@link rtvref.types primitive}.\n *\n * This is the __default__ (imputed) type for\n *  {@link rtvref.shape_descriptor shape descriptors}, which means the object itself\n *  (the value being tested), prior to being checked against its shape, will be\n *  tested according to this type.\n *\n * The following values are considered objects:\n *\n * - `{}`\n * - `new Object()`\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `new function() {}` (class instance)\n *\n * The following values __are not__ considered objects:\n *\n * - `[]`\n * - `new Array()`\n * - `/re/`\n * - `new RegExp('re')`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null`\n * - `undefined`\n *\n * Object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.shape_descriptor}\n *\n * @name rtvref.types.OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const OBJECT = 'object';\n\n/**\n * A _plain_ object is one that is created directly from the `Object` constructor,\n *  whether using `new Object()` or the literal `{}`.\n *\n * The following values are considered plain objects:\n *\n * - `{}`\n * - `new Object()`\n *\n * The following values __are not__ considered plain objects:\n *\n * - `[]`\n * - `new Array()`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `/re/`\n * - `new RegExp('re')`\n * - `new function() {}` (class instance)\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null`\n * - `undefined`\n *\n * Plain object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.shape_descriptor}\n *\n * @name rtvref.types.PLAIN_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const PLAIN_OBJECT = 'plainObject';\n\n/**\n * {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} arguments.\n * @typedef {Object} rtvref.types.CLASS_OBJECT_args\n * @property {Function} [ctr] A reference to a constructor function. If specified,\n *  the class object (instance) must have this class function in its inheritance\n *  chain such that `<class_object> instanceof <function> === true`. Note that\n *  this property is not serializable to JSON.\n * @property {rtvref.shape_descriptor} [shape] A description of the class object's\n *  shape.\n */\n\n/**\n * A _class_ object is one that is created by invoking the `new` operator on a\n *  function (other than a primitive type function), generating a new object,\n *  commonly referred to as a _class instance_. This object's prototype\n *  (`__proto__`) is a reference to that function's `prototype` and has a\n *  `constructor` property that is `===` to the function.\n *\n * The following values are considered class objects:\n *\n * - `new function() {}`\n *\n * The following values __are not__ considered class objects:\n *\n * - `{}`\n * - `new Object()`\n * - `[]`\n * - `new Array()`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `/re/`\n * - `new RegExp('re')`\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null`\n * - `undefined`\n *\n * Class object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.types.CLASS_OBJECT_args}\n *\n * @name rtvref.types.CLASS_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const CLASS_OBJECT = 'classObject';\n\n/**\n * A _map_ object is an {@link rtvref.types.OBJECT OBJECT} that is treated as a\n *  hash map with an expected set of keys and values. Keys can be described\n *  using a regular expression, and values can be described using a\n *  {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Map object rules per qualifiers: Same as {@link rtvref.types.OBJECT OBJECT} rules.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.MAP_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const MAP_OBJECT = 'mapObject';\n\n// TODO: Is there a way that ARRAY could take a parameter, that being the\n//  required length of the array, defaulting to -1 for any length? Perhaps\n//  only when using the full form as `[ARRAY, 2, [STRING]]` instead of the\n//  short form as `[[STRING]]`? Maybe `[2, [STRING]]` would even work for short\n//  hand. If so, then this would be up to par with the MAP_OBJECT where a count\n//  can be specified...\n/**\n * Array rules per qualifiers: Must be an `Array`. Empty arrays are permitted.\n * @name rtvref.types.ARRAY\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const ARRAY = 'array';\n\n/**\n * JSON rules per qualifiers: Must be a JSON value:\n *\n * - {@link rtvref.types.STRING string}, however __empty strings__ are permitted,\n *   even if the qualifier is `REQUIRED`;\n * - {@link rtvref.types.BOOLEAN boolean};\n * - {@link rtvref.types.FINITE finite number};\n * - {@link rtvref.types.PLAIN_OBJECT plain object};\n * - {@link rtvref.types.ARRAY array};\n * - `null`\n *\n * Since this type checks for _any_ valid JSON value, empty string and `null`\n *  values are permitted, even when the typeset is qualified as `REQUIRED`.\n *  Therefore, the `REQUIRED` qualifier has the same effect as the `EXPECTED`\n *  qualifier.\n *\n * @name rtvref.types.JSON\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const JSON = 'json';\n\n/**\n * Function rules per qualifiers: Must be a `function`.\n * @name rtvref.types.FUNCTION\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const FUNCTION = 'function';\n\n/**\n * RegExp rules per qualifiers: Must be a `RegExp` instance.\n * @name rtvref.types.REGEXP\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n */\nexport const REGEXP = 'regexp';\n\n/**\n * Date rules per qualifiers: Must be a `Date` instance.\n * @name rtvref.types.DATE\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n */\nexport const DATE = 'date';\n\n/**\n * Error rules per qualifiers: Must be an `Error` instance.\n * @name rtvref.types.ERROR\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n */\nexport const ERROR = 'error';\n\n/**\n * Promise rules per qualifiers: Must be a `Promise` instance.\n * @name rtvref.types.PROMISE\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\nexport const PROMISE = 'promise';\n\n/**\n * An ES6 map supports any object as its keys, unlike a\n *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n *  be described using a regular expression (if they are strings), and values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Map rules per qualifiers: Must be a `Map` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.MAP\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const MAP = 'map';\n\n/**\n * An ES6 weak map supports any object as its keys, unlike a\n *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n *  be described using a regular expression (if they are strings), and values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Weak map rules per qualifiers: Must be a `WeakMap` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.WEAK_MAP\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n */\nexport const WEAK_MAP = 'weakMap';\n\n/**\n * An ES6 set is a collection of _unique_ values without associated keys. Values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted.\n *\n * Set rules per qualifiers: Must be a `Set` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.SET\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.WEAK_SET}\n */\nexport const SET = 'set';\n\n/**\n * An ES6 weak set is a collection of _unique_ values without associated keys. Values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted.\n *\n * Weak set rules per qualifiers: Must be a `WeakSet` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.WEAK_SET\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.SET}\n */\nexport const WEAK_SET = 'weakSet';\n","//// Qualifier Definitions \\\\\\\\\n\n/**\n * <h2>Qualifiers</h2>\n * @namespace rtvref.qualifiers\n */\n\n/**\n * Required qualifier: Property _must_ exist and be of the expected type.\n *  Depending on the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, and does not\n *  allow its value to be `null` or `undefined`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.REQUIRED\n * @const {String}\n * @see {@link rtvref.types}\n */\nexport const REQUIRED = '!';\n\n/**\n * Expected qualifier: Property _should_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, does not allow\n *  its value to be `undefined`, but does _allow_ its value to be `null`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.EXPECTED\n * @const {String}\n * @see {@link rtvref.types}\n */\nexport const EXPECTED = '+';\n\n/**\n * Optional qualifier: Property _may_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced (i.e. less so\n *  than with the `EXPECTED` qualifier).\n *\n * Unless otherwise stated in type-specific rules, this qualifier _allows_ a\n *  property value to be `null` as well as `undefined`, and does _not_ require\n *  the property to be defined anywhere in the prototype chain. If the property\n *  is defined, then it is treated as an `EXPECTED` value.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.OPTIONAL\n * @const {String}\n * @see {@link rtvref.types}\n */\nexport const OPTIONAL = '?';\n","//// Enumeration \\\\\\\\\n\n/**\n * Simple enumeration type.\n * @class rtvref.Enumeration\n * @param {Object.<String,*>} map Object mapping keys to values. Values cannot\n *  be `undefined`.\n * @throws {Error} If `map` is falsy or empty.\n * @throws {Error} If `map` has a key that maps to `undefined`.\n */\nclass Enumeration {\n  constructor(map) {\n    map = map || {};\n\n    const keys = Object.keys(map);\n    const values = [];\n\n    if (keys.length === 0) {\n      throw new Error('map must contain at least one key');\n    }\n\n    // shallow-clone each key in the map into this\n    keys.forEach((key) => {\n      if (map[key] === undefined) {\n        throw new Error('map[' + key + '] cannot be undefined');\n      }\n\n      const value = map[key];\n      values.push(value);\n      this[key] = value;\n    });\n\n    /**\n     * [internal] List of enumeration values.\n     * @name rtvref.Enumeration#_values\n     * @type Array.<String>\n     */\n    Object.defineProperty(this, '_values', {\n      enumerable: false, // internal\n      configurable: true,\n      value: values\n    });\n  }\n\n  /**\n   * Validates a value as being in this enumeration. Throws an exception if the value\n   *  is not in this enumeration, unless `silent` is true.\n   * @method rtvref.Enumeration#verify\n   * @param {*} value Value to check. Cannot be undefined.\n   * @param {Boolean} [silent=false] If truthy, returns `undefined` instead of throwing\n   *  an exception if the specified value is not in this enumeration.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined` if\n   *  `silent` is true and the value is not in this enumeration.\n   */\n  verify(value, silent) {\n    if (this._values.indexOf(value) >= 0) {\n      return value;\n    } else if (silent) {\n      return undefined;\n    }\n\n    throw new Error('invalid value for enum[' + this._values.join(', ') + ']: ' + value);\n  }\n\n  /**\n   * A string representation of this Enumeration.\n   * @returns {string} String representation.\n   */\n  toString() {\n    const pairs = Object.keys(this).map((k) => [k, this[k]]);\n    return `{Enumeration pairs=[${pairs.map((p) => `[${p}]`).join(', ')}]}`;\n  }\n}\n\nexport default Enumeration;\n","//// Main Implementation Module \\\\\\\\\n\nimport isString from 'lodash/isString';\n\nimport * as allTypes from './types';\nimport * as allQualifiers from './qualiiers';\nimport Enumeration from './Enumeration';\n\n/**\n * RTV Implementation\n * @private\n * @namespace rtv.impl\n */\n\n/**\n * Enumeration of {@link rtvref.types types}.\n * @name rtv.impl.types\n * @type {rtvref.Enumeration}\n */\nexport const types = new Enumeration(allTypes);\n\n/**\n * Enumeration of {@link rtvref.qualifiers qualifiers}.\n * @name rtv.impl.qualifiers\n * @type {rtvref.Enumeration}\n */\nexport const qualifiers = new Enumeration(allQualifiers);\n\n/**\n * Checks a value against a shape for compliance.\n * @function rtv.impl.check\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} shape Expected shape of the value.\n * @returns {Boolean} `true` if the `value` is compliant to the `shape`; `false`\n *  otherwise. An exception is __not__ thrown if the `value` is non-compliant.\n * @see rtv.impl.verify\n */\nexport const check = function(value, shape) {\n  // TODO: testing 'check'\n  return isString(value) && !!value;\n};\n","//// Main entry point \\\\\\\\\n\nimport {version as VERSION} from '../package.json';\nimport * as impl from './lib/impl';\n\n/**\n * <h1>RTV.js Reference</h1>\n *\n * Members herein are _indirectly_ exposed through the {@link rtv} object.\n * @namespace rtvref\n */\n\n/**\n * <h2>Shape Descriptor</h2>\n *\n * Describes the shape (i.e. interface) of an object as a map of properties to\n *  {@link rtvref.types.typeset typesets}. Each typeset indicates whether the\n *  property is required, expected, or optional, using {@link rtvref.qualifiers qualifiers},\n *  along with possible types.\n *\n * When a value is {@link rtv.check checked} or {@link rtv.verify verified} against\n *  a given shape, properties that are not part of the shape are ignored. If\n *  successfully checked/verified, the value is guaranteed to provide the properties\n *  described in the shape, and each property is guaranteed to be assigned to a\n *  value of at least one type described in each property's typeset.\n *\n * @typedef {Object} rtvref.shape_descriptor\n */\n\n/**\n * <h1>RTV.js</h1>\n *\n * Runtime Verification Library for browsers and Node.js.\n * @namespace rtv\n */\nconst rtv = {\n  /**\n   * Enumeration of {@link rtvref.types types}.\n   * @name rtv.t\n   * @type {rtvref.Enumeration}\n   */\n  t: impl.types,\n\n  /**\n   * Enumeration of {@link rtvref.qualifiers qualifiers}.\n   * @name rtv.q\n   * @type {rtvref.Enumeration}\n   */\n  q: impl.qualifiers,\n\n  /**\n   * Checks a value against a shape for compliance.\n   * @function rtv.check\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value.\n   * @returns {Boolean} `true` if the `value` is compliant to the `shape`; `false`\n   *  otherwise. An exception is __not__ thrown if the `value` is non-compliant.\n   * @see rtv.verify\n   */\n  check(value, shape) {\n    // TODO: testing 'check'\n    return impl.check(value, shape);\n  },\n\n  /**\n   * __Requires__ a value to be compliant to a shape.\n   * @function rtv.verify\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value.\n   * @throws {Error} If the `value` is not compliant to the `shape`.\n   * @see rtv.verify\n   */\n  verify(value, shape) {\n    if (this.config.enabled) {\n      if (!this.check(value, shape)) {\n        // TODO: consider throwing a special RtvError object that contains extra\n        //  properties to indicate what didn't match, what was expected, the shape\n        //  that was checked, the value that was checked, etc.\n        throw new Error('value does not match specified shape');\n      }\n    }\n  },\n\n  /**\n   * RTV Library Configuration\n   * @name rtv.config\n   * @type {rtv.config_properties}\n   */\n  config: Object.defineProperties({}, {\n\n    /**\n     * Configuration Properties\n     * @typedef {Object} rtv.config_properties\n     * @property {Boolean} enabled // TODO[docs]\n     */\n\n    enabled: (function() {\n      let value = true;\n      return {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return value;\n        },\n        set(newValue) {\n          rtv.verify(newValue, rtv.t.BOOLEAN);\n          value = newValue;\n        }\n      };\n    })()\n  }),\n\n  /**\n   * Contextual RTV Generator // TODO[docs]\n   * @function rtv.Context\n   * @param {String} context\n   */\n  Context(context) {\n    // TODO: a version with same API (less 'config') that will include 'context' in errors thrown\n  }\n};\n\n/**\n * [internal] Library version.\n * @name rtv._version\n * @type {String}\n */\nObject.defineProperty(rtv, '_version', {\n  enumerable: false, // internal\n  configurable: true,\n  value: VERSION\n});\n\nexport default rtv;\n"],"names":["global","freeGlobal","Symbol","root","objectProto","nativeObjectToString","symToStringTag","getRawTag","objectToString","isArray","isObjectLike","baseGetTag","ANY","STRING","BOOLEAN","SYMBOL","NUMBER","FINITE","INT","FLOAT","ANY_OBJECT","OBJECT","PLAIN_OBJECT","CLASS_OBJECT","MAP_OBJECT","ARRAY","JSON","FUNCTION","REGEXP","DATE","ERROR","PROMISE","MAP","WEAK_MAP","SET","WEAK_SET","REQUIRED","EXPECTED","OPTIONAL","Enumeration","map","keys","Object","values","length","Error","forEach","key","undefined","value","push","defineProperty","silent","_values","indexOf","join","pairs","k","p","types","allTypes","qualifiers","allQualifiers","check","shape","isString","rtv","impl","config","enabled","defineProperties","newValue","verify","t","context","VERSION"],"mappings":";;;;;;;;;AAAA;AACA,IAAI,UAAU,GAAG,OAAOA,cAAM,IAAI,QAAQ,IAAIA,cAAM,IAAIA,cAAM,CAAC,MAAM,KAAK,MAAM,IAAIA,cAAM,CAAC;;AAE3F,eAAc,GAAG,UAAU,CAAC;;ACD5B;AACA,IAAI,QAAQ,GAAG,OAAO,IAAI,IAAI,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,MAAM,IAAI,IAAI,CAAC;;;AAGjF,IAAI,IAAI,GAAGC,WAAU,IAAI,QAAQ,IAAI,QAAQ,CAAC,aAAa,CAAC,EAAE,CAAC;;AAE/D,SAAc,GAAG,IAAI,CAAC;;ACNtB;AACA,IAAIC,QAAM,GAAGC,KAAI,CAAC,MAAM,CAAC;;AAEzB,WAAc,GAAGD,QAAM,CAAC;;ACHxB;AACA,IAAI,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC;;;AAGnC,IAAI,cAAc,GAAG,WAAW,CAAC,cAAc,CAAC;;;;;;;AAOhD,IAAI,oBAAoB,GAAG,WAAW,CAAC,QAAQ,CAAC;;;AAGhD,IAAI,cAAc,GAAGA,OAAM,GAAGA,OAAM,CAAC,WAAW,GAAG,SAAS,CAAC;;;;;;;;;AAS7D,SAAS,SAAS,CAAC,KAAK,EAAE;EACxB,IAAI,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,cAAc,CAAC;MAClD,GAAG,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;;EAEhC,IAAI;IACF,KAAK,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC;IAClC,IAAI,QAAQ,GAAG,IAAI,CAAC;GACrB,CAAC,OAAO,CAAC,EAAE,EAAE;;EAEd,IAAI,MAAM,GAAG,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;EAC9C,IAAI,QAAQ,EAAE;IACZ,IAAI,KAAK,EAAE;MACT,KAAK,CAAC,cAAc,CAAC,GAAG,GAAG,CAAC;KAC7B,MAAM;MACL,OAAO,KAAK,CAAC,cAAc,CAAC,CAAC;KAC9B;GACF;EACD,OAAO,MAAM,CAAC;CACf;;AAED,cAAc,GAAG,SAAS,CAAC;;AC7C3B;AACA,IAAIE,aAAW,GAAG,MAAM,CAAC,SAAS,CAAC;;;;;;;AAOnC,IAAIC,sBAAoB,GAAGD,aAAW,CAAC,QAAQ,CAAC;;;;;;;;;AAShD,SAAS,cAAc,CAAC,KAAK,EAAE;EAC7B,OAAOC,sBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;CACzC;;AAED,mBAAc,GAAG,cAAc,CAAC;;ACjBhC;AACA,IAAI,OAAO,GAAG,eAAe;IACzB,YAAY,GAAG,oBAAoB,CAAC;;;AAGxC,IAAIC,gBAAc,GAAGJ,OAAM,GAAGA,OAAM,CAAC,WAAW,GAAG,SAAS,CAAC;;;;;;;;;AAS7D,SAAS,UAAU,CAAC,KAAK,EAAE;EACzB,IAAI,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,KAAK,KAAK,SAAS,GAAG,YAAY,GAAG,OAAO,CAAC;GACrD;EACD,OAAO,CAACI,gBAAc,IAAIA,gBAAc,IAAI,MAAM,CAAC,KAAK,CAAC;MACrDC,UAAS,CAAC,KAAK,CAAC;MAChBC,eAAc,CAAC,KAAK,CAAC,CAAC;CAC3B;;AAED,eAAc,GAAG,UAAU,CAAC;;AC3B5B;;;;;;;;;;;;;;;;;;;;;;;AAuBA,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;;AAE5B,aAAc,GAAG,OAAO,CAAC;;ACzBzB;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAAS,YAAY,CAAC,KAAK,EAAE;EAC3B,OAAO,KAAK,IAAI,IAAI,IAAI,OAAO,KAAK,IAAI,QAAQ,CAAC;CAClD;;AAED,kBAAc,GAAG,YAAY,CAAC;;ACxB9B;AACA,IAAI,SAAS,GAAG,iBAAiB,CAAC;;;;;;;;;;;;;;;;;;;AAmBlC,SAAS,QAAQ,CAAC,KAAK,EAAE;EACvB,OAAO,OAAO,KAAK,IAAI,QAAQ;KAC5B,CAACC,SAAO,CAAC,KAAK,CAAC,IAAIC,cAAY,CAAC,KAAK,CAAC,IAAIC,WAAU,CAAC,KAAK,CAAC,IAAI,SAAS,CAAC,CAAC;CAC9E;;AAED,cAAc,GAAG,QAAQ,CAAC;;AC7B1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwUA,AAAO,IAAMC,MAAM,KAAZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BP,AAAO,IAAMC,SAAS,QAAf;;;;;;;;AAQP,AAAO,IAAMC,UAAU,SAAhB;;;;;;;;AAQP,AAAO,IAAMC,SAAS,QAAf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BP,AAAO,IAAMC,SAAS,QAAf;;;;;;;;;;;;;;AAcP,AAAO,IAAMC,SAAS,QAAf;;;;;;;;;;;;;;;AAeP,AAAO,IAAMC,MAAM,KAAZ;;;;;;;;;;;;AAYP,AAAO,IAAMC,QAAQ,OAAd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDP,AAAO,IAAMC,aAAa,WAAnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DP,AAAO,IAAMC,SAAS,QAAf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDP,AAAO,IAAMC,eAAe,aAArB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEP,AAAO,IAAMC,eAAe,aAArB;;;;;;;;;;;;;;;;;;;;;;AAsBP,AAAO,IAAMC,aAAa,WAAnB;;;;;;;;;;;;;;AAcP,AAAO,IAAMC,QAAQ,OAAd;;;;;;;;;;;;;;;;;;;;;;AAsBP,AAAO,IAAMC,OAAO,MAAb;;;;;;;;AAQP,AAAO,IAAMC,WAAW,UAAjB;;;;;;;;;AASP,AAAO,IAAMC,SAAS,QAAf;;;;;;;;;AASP,AAAO,IAAMC,OAAO,MAAb;;;;;;;;;AASP,AAAO,IAAMC,QAAQ,OAAd;;;;;;;;;AASP,AAAO,IAAMC,UAAU,SAAhB;;;;;;;;;;;;;;;;;;AAkBP,AAAO,IAAMC,MAAM,KAAZ;;;;;;;;;;;;;;;;;;AAkBP,AAAO,IAAMC,WAAW,SAAjB;;;;;;;;;;;;;;;AAeP,AAAO,IAAMC,MAAM,KAAZ;;;;;;;;;;;;;;;AAeP,AAAO,IAAMC,WAAW,SAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACv0BP;;;;;;;;;;;;;;;;;;;;;AAqBA,AAAO,IAAMC,WAAW,GAAjB;;;;;;;;;;;;;;;;AAgBP,AAAO,IAAMC,WAAW,GAAjB;;;;;;;;;;;;;;;;;;AAkBP,AAAO,IAAMC,WAAW,GAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDP;;;;;;;;;;IAUMC;uBACQC,GAAZ,EAAiB;;;;;UACTA,OAAO,EAAb;;QAEMC,OAAOC,OAAOD,IAAP,CAAYD,GAAZ,CAAb;QACMG,SAAS,EAAf;;QAEIF,KAAKG,MAAL,KAAgB,CAApB,EAAuB;YACf,IAAIC,KAAJ,CAAU,mCAAV,CAAN;;;;SAIGC,OAAL,CAAa,UAACC,GAAD,EAAS;UAChBP,IAAIO,GAAJ,MAAaC,SAAjB,EAA4B;cACpB,IAAIH,KAAJ,CAAU,SAASE,GAAT,GAAe,uBAAzB,CAAN;;;UAGIE,QAAQT,IAAIO,GAAJ,CAAd;aACOG,IAAP,CAAYD,KAAZ;YACKF,GAAL,IAAYE,KAAZ;KAPF;;;;;;;WAeOE,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;kBACzB,KADyB;oBAEvB,IAFuB;aAG9BR;KAHT;;;;;;;;;;;;;;;;;2BAiBKM,OAAOG,QAAQ;UAChB,KAAKC,OAAL,CAAaC,OAAb,CAAqBL,KAArB,KAA+B,CAAnC,EAAsC;eAC7BA,KAAP;OADF,MAEO,IAAIG,MAAJ,EAAY;eACVJ,SAAP;;;YAGI,IAAIH,KAAJ,CAAU,4BAA4B,KAAKQ,OAAL,CAAaE,IAAb,CAAkB,IAAlB,CAA5B,GAAsD,KAAtD,GAA8DN,KAAxE,CAAN;;;;;;;;;;+BAOS;;;UACHO,QAAQd,OAAOD,IAAP,CAAY,IAAZ,EAAkBD,GAAlB,CAAsB,UAACiB,CAAD;eAAO,CAACA,CAAD,EAAI,OAAKA,CAAL,CAAJ,CAAP;OAAtB,CAAd;sCAC8BD,MAAMhB,GAAN,CAAU,UAACkB,CAAD;qBAAWA,CAAX;OAAV,EAA2BH,IAA3B,CAAgC,IAAhC,CAA9B;;;;;;ACtEJ;;;;;;;;;;;;;AAmBA,AAAO,IAAMI,QAAQ,IAAIpB,WAAJ,CAAgBqB,QAAhB,CAAd;;;;;;;AAOP,AAAO,IAAMC,aAAa,IAAItB,WAAJ,CAAgBuB,aAAhB,CAAnB;;;;;;;;;;;AAWP,AAAO,IAAMC,QAAQ,SAARA,KAAQ,CAASd,KAAT,EAAgBe,KAAhB,EAAuB;;SAEnCC,WAAShB,KAAT,KAAmB,CAAC,CAACA,KAA5B;CAFK;;ACrCP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,IAAMiB,MAAM;;;;;;KAMPC,KANO;;;;;;;KAaPA,UAbO;;;;;;;;;;;OAAA,oBAwBJlB,KAxBI,EAwBGe,KAxBH,EAwBU;;WAEXG,KAAA,CAAWlB,KAAX,EAAkBe,KAAlB,CAAP;GA1BQ;;;;;;;;;;;QAAA,kBAqCHf,KArCG,EAqCIe,KArCJ,EAqCW;QACf,KAAKI,MAAL,CAAYC,OAAhB,EAAyB;UACnB,CAAC,KAAKN,KAAL,CAAWd,KAAX,EAAkBe,KAAlB,CAAL,EAA+B;;;;cAIvB,IAAInB,KAAJ,CAAU,sCAAV,CAAN;;;GA3CI;;;;;;;;UAqDFH,OAAO4B,gBAAP,CAAwB,EAAxB,EAA4B;;;;;;;;aAQxB,YAAW;UACfrB,QAAQ,IAAZ;aACO;oBACO,IADP;sBAES,IAFT;WAAA,iBAGC;iBACGA,KAAP;SAJG;WAAA,eAMDsB,QANC,EAMS;cACRC,MAAJ,CAAWD,QAAX,EAAqBL,IAAIO,CAAJ,CAAM3D,OAA3B;kBACQyD,QAAR;;OARJ;KAFO;GARH,CArDE;;;;;;;SAAA,mBAkFFG,OAlFE,EAkFO;;;CAlFnB;;;;;;;AA4FAhC,OAAOS,cAAP,CAAsBe,GAAtB,EAA2B,UAA3B,EAAuC;cACzB,KADyB;gBAEvB,IAFuB;SAG9BS;CAHT;;;;"}