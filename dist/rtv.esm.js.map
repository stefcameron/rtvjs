{"version":3,"file":"rtv.esm.js","sources":["../node_modules/lodash/_arrayEach.js","../node_modules/lodash/_createBaseFor.js","../node_modules/lodash/_baseFor.js","../node_modules/lodash/_baseTimes.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/_baseIsArguments.js","../node_modules/lodash/isArguments.js","../node_modules/lodash/isArray.js","../node_modules/lodash/stubFalse.js","../node_modules/lodash/isBuffer.js","../node_modules/lodash/_isIndex.js","../node_modules/lodash/isLength.js","../node_modules/lodash/_baseIsTypedArray.js","../node_modules/lodash/_baseUnary.js","../node_modules/lodash/_nodeUtil.js","../node_modules/lodash/isTypedArray.js","../node_modules/lodash/_arrayLikeKeys.js","../node_modules/lodash/_isPrototype.js","../node_modules/lodash/_overArg.js","../node_modules/lodash/_nativeKeys.js","../node_modules/lodash/_baseKeys.js","../node_modules/lodash/isObject.js","../node_modules/lodash/isFunction.js","../node_modules/lodash/isArrayLike.js","../node_modules/lodash/keys.js","../node_modules/lodash/_baseForOwn.js","../node_modules/lodash/_createBaseEach.js","../node_modules/lodash/_baseEach.js","../node_modules/lodash/identity.js","../node_modules/lodash/_castFunction.js","../node_modules/lodash/forEach.js","../node_modules/lodash/isFinite.js","../src/lib/util.js","../src/lib/Enumeration.js","../src/lib/types.js","../src/lib/qualifiers.js","../src/lib/validator/isFinite.js","../src/lib/validator/isArray.js","../node_modules/lodash/_coreJsData.js","../node_modules/lodash/_isMasked.js","../node_modules/lodash/_toSource.js","../node_modules/lodash/_baseIsNative.js","../node_modules/lodash/_getValue.js","../node_modules/lodash/_getNative.js","../node_modules/lodash/_DataView.js","../node_modules/lodash/_Map.js","../node_modules/lodash/_Promise.js","../node_modules/lodash/_Set.js","../node_modules/lodash/_WeakMap.js","../node_modules/lodash/_getTag.js","../node_modules/lodash/_baseIsMap.js","../node_modules/lodash/isMap.js","../node_modules/lodash/_baseIsSet.js","../node_modules/lodash/isSet.js","../node_modules/lodash/isWeakMap.js","../src/lib/validator/isWeakMap.js","../node_modules/lodash/isWeakSet.js","../src/lib/validator/isWeakSet.js","../node_modules/lodash/_baseIsRegExp.js","../node_modules/lodash/isRegExp.js","../src/lib/validator/isRegExp.js","../src/lib/validator/isObject.js","../src/lib/validator/isString.js","../src/lib/validator/isFunction.js","../src/lib/validator/isBoolean.js","../src/lib/validation/isTypeset.js","../src/lib/validation/isShape.js","../src/lib/validation/isTypeArgs.js","../src/lib/validation/isValidator.js","../src/lib/RtvSuccess.js","../src/lib/RtvError.js","../src/lib/impl.js","../src/lib/validator/isAny.js","../node_modules/lodash/isSymbol.js","../src/lib/validator/isSymbol.js","../node_modules/lodash/isNumber.js","../node_modules/lodash/isNaN.js","../src/lib/validator/isNumber.js","../src/lib/validator/isAnyObject.js","../src/lib/validator/isMap.js","../src/lib/validator/isSet.js","../src/rtv.js"],"sourcesContent":["/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","var root = require('./_root');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsFinite = root.isFinite;\n\n/**\n * Checks if `value` is a finite primitive number.\n *\n * **Note:** This method is based on\n * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n * @example\n *\n * _.isFinite(3);\n * // => true\n *\n * _.isFinite(Number.MIN_VALUE);\n * // => true\n *\n * _.isFinite(Infinity);\n * // => false\n *\n * _.isFinite('3');\n * // => false\n */\nfunction isFinite(value) {\n  return typeof value == 'number' && nativeIsFinite(value);\n}\n\nmodule.exports = isFinite;\n","////// Utilities\n\n// NOTE: Ideally, this module has no dependencies. If it must, they should be\n//  third-party/external dependencies to avoid circular dependencies within\n//  this library.\n\n/**\n * RTV Utilities Module\n * @private\n * @namespace rtv.util\n */\n\n/**\n * Pretty-print a value.\n * @function rtv.util.print\n * @param {*} value Value to print.\n * @returns {string} Pretty-printed value. It's not perfect and may not catch\n *  all types, but attempts to be good enough.\n */\nexport const print = function(value) {\n  const replacer = function replacer(key, val) {\n    if (typeof val === 'function') {\n      return '<function>';\n    } else if (typeof val === 'symbol') {\n      return `<<${val.toString()}>>`;\n    } else if (val === null || val === undefined) {\n      return val + '';\n    }\n\n    return val;\n  };\n\n  // do an initial pass to see if we have a string\n  const result = replacer(undefined, value);\n\n  // if it's just a string, return it\n  if (typeof result === 'string') {\n    return result;\n  }\n\n  // otherwise, stringify it\n  return JSON.stringify(value, replacer);\n};\n","////// Enumeration\n\nimport {print} from './util';\n\n/**\n * Simple enumeration type. Own-properties on an instance are the keys in the\n *  specified `map`, with their associated values. Key names cannot start with\n *  \"$\".\n *\n * <pre><code>const state = new Enumeration({\n *   READY: 1,\n *   RUNNING: 2,\n *   STOPPED: 3,\n *   COMPLETE: 4\n * });\n *\n * state.RUNNING; // 2\n * state.verify(3); // 3 (returns the value since found in enumeration)\n * state.verify(5); // ERROR thrown\n * state.check(3); // 3 (same as verify(3) since found in enumeration)\n * state.check(5); // undefined (silent failure)\n * state.$values; // [1, 2, 3, 4] (special non-enumerable own-property)\n * </code></pre>\n *\n * @class rtvref.Enumeration\n * @param {Object.<String,*>} map Object mapping keys to values. Values cannot\n *  be `undefined`.\n * @param {string} [name] Friendly name used to identify this enumeration,\n *  especially in validation error messages.\n * @throws {Error} If `map` is falsy or empty.\n * @throws {Error} If `map` has a key that maps to `undefined`.\n * @throws {Error} If `map` contains a duplicate value.\n * @throws {Error} If `map` has a key that is a restricted property (starts with\n *  \"$\").\n */\nexport default class Enumeration {\n  // JSDoc is provided at the @class level\n  constructor(map, name) {\n    map = map || {};\n\n    const keys = Object.keys(map);\n    const values = [];\n\n    if (keys.length === 0) {\n      throw new Error('map must contain at least one key');\n    }\n\n    // shallow-clone each key in the map into this\n    keys.forEach((key) => {\n      if (key.indexOf('$') === 0) {\n        throw new Error(`map key \"${key}\" cannot start with \"$\"`);\n      }\n\n      if (map[key] === undefined) {\n        throw new Error(`map[${key}] cannot be undefined`);\n      }\n\n      const value = map[key];\n      if (values.indexOf(value) >= 0) {\n        throw new Error(`map[${key}] is a duplicate value: ${print(value)}`);\n      }\n\n      values.push(value);\n      this[key] = value;\n    });\n\n    /**\n     * Friendly name (not necessarily unique among all enumeration instances)\n     *  used to identify this enumeration, especially in validation error\n     *  messages. Empty string if not specified during construction.\n     * @readonly\n     * @name rtvref.Enumeration#$name\n     * @type {string}\n     */\n    Object.defineProperty(this, '$name', {\n      enumerable: false,\n      configurable: true,\n      value: (name && print(name)) || ''\n    });\n\n    /**\n     * List of enumeration values. Values are _references_ to values in this\n     *  enumeration.\n     *\n     * Note that this own-property is non-enumerable on purpose. Enumerable\n     *  properties on this instance are the keys in this enumeration.\n     *\n     * @readonly\n     * @name rtvref.Enumeration#$values\n     * @type {Array.<String>}\n     */\n    Object.defineProperty(this, '$values', {\n      enumerable: false,\n      configurable: true,\n      get() {\n        return values.concat(); // shallow clone\n      }\n    });\n  }\n\n  /**\n   * Checks if a value is in this enumeration.\n   * @method rtvref.Enumeration#check\n   * @param {*} value Value to check. Cannot be undefined.\n   * @returns {(*|undefined)} The specified value if it is in this enumeration, or `undefined`\n   *  if not. An exception is __not__ thrown if the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#verify}\n   */\n  check(value) {\n    if (this.$values.indexOf(value) >= 0) {\n      return value;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Validates a value as being in this enumeration. Throws an exception if the value\n   *  is not in this enumeration, unless `silent` is true.\n   * @method rtvref.Enumeration#verify\n   * @param {*} value Value to check. Cannot be undefined.\n   * @param {boolean} [silent=false] If truthy, returns `undefined` instead of throwing\n   *  an exception if the specified value is not in this enumeration.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined` if\n   *  `silent` is true and the value is not in this enumeration.\n   * @throws {Error} If not `silent` and the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#check}\n   */\n  verify(value, silent) {\n    const result = this.check(value);\n\n    if (result === undefined && !silent) {\n      throw new Error(`Invalid value for ${this.$name ? `${this.$name} ` : ''}enum[${this.$values.map(print).join(', ')}]: ${print(value)}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * A string representation of this Enumeration.\n   * @method rtvref.Enumeration#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    const pairs = Object.keys(this).map((k) => [k, this[k]]);\n    return `{rtvref.Enumeration $name=\"${this.$name}\" pairs=[${pairs.map((p) => `[${print(p)}]`).join(', ')}]}`;\n  }\n}\n","////// Type Definitions\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Types</h2>\n * @namespace rtvref.types\n */\n\n/**\n * <h3>Primitives</h3>\n *\n * In RTV.js (as in {@link https://developer.mozilla.org/en-US/docs/Glossary/Primitive ECMAScript 2015}),\n *  a _primitive_ is considered one of the following types:\n *\n * - `undefined`\n * - `null`\n * - `string` (note that `new String('s')` does not produce a _primitive_, it\n *   produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `boolean` (note that `new Boolean(true)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `number` (note that `new Number(1)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `Symbol`\n *\n * @typedef {*} rtvref.types.primitives\n * @see {@link rtvref.validation.isPrimitive}\n */\n\n/**\n * <h3>Rules Per Qualifiers</h3>\n *\n * {@link rtvref.qualifiers Qualifiers} state basic rules. Unless otherwise stated,\n *  every type herein abides by those basic rules. Each type will also impose\n *  additional rules specific to the type of value it represents.\n *\n * For example, while the {@link rtvref.types.FINITE FINITE} type states that the\n *  value must not be `NaN`, `+Infinity`, nor `-Infinity`; it could be `null` if\n *  the qualifier used is `EXPECTED`; and it could be `undefined` if the qualifier\n *  used is `OPTIONAL`.\n *\n * @typedef {*} rtvref.types.rules\n */\n\n/**\n * <h3>Type Arguments</a></h3>\n *\n * Some types will accept, or may even expect, one or more arguments. Each type\n *  will specify whether it has arguments, and if they're optional or required.\n *  Arguments are specified as a single {@link rtvref.types.OBJECT object}\n *  immediately following a type in an __Array__ {@link rtvref.types.typeset typeset}\n *  (i.e. an Array must be used as the typeset in order to provide arguments for\n *  a type).\n *\n * An arguments object immediately follows its type in a typeset, such as\n *  `[PLAIN_OBJECT, {hello: STRING}]`. This would specify the value must be a\n *  {@link rtvref.types.PLAIN_OBJECT plain object} with a shape that includes a\n *  property named 'hello', that property being a\n *  {@link rtvref.qualifiers.REQUIRED required} {@link rtvref.types.STRING string}.\n *  Another example would be `[STRING, {min: 5}]`, which would require a string\n *  of at least 5 characters in length.\n *\n * Since {@link rtvref.qualifiers qualifiers} may affect how a value is validated\n *  against a type, {@link rtvref.types.rules qualifier rules} always take\n *  __precedence__ over any argument specified. For example, `[STRING, {min: 0}]`\n *  would fail to validate an empty string because the _implied_ qualifier\n *  is `REQUIRED`, and per {@link rtvref.types.STRING STRING} qualifier rules,\n *  required strings cannot be empty.\n *\n * @typedef {Object} rtvref.types.type_arguments\n * @see {@link rtvref.validation.isTypeArgs}\n */\n\n/**\n * <h3>Collection Arguments</h3>\n *\n * Describes the keys and values in a collection-based object, which is one of\n *  the following types:\n *\n * - {@link rtvref.types.MAP_OBJECT MAP_OBJECT} (NOTE: only __own-enumerable\n *   properties__ are considered part of this type of collection)\n * - {@link rtvref.types.MAP MAP}\n * - {@link rtvref.types.SET SET} (with some exceptions)\n *\n * For example, the following arguments both verify a collection of 3-letter\n *  string keys (upper- or lowercase) to finite numbers:\n *\n * - `{keyExp: '[a-z]{3}', keyFlagSpec: 'i', values: FINITE}`\n * - `{keyExp: '[a-zA-Z]{3}', values: FINITE}`\n *\n * Note that {@link rtvref.types.ARRAY ARRAY} is __not__ included in this list\n *  because the array type has special syntax for describing the type of its items.\n *  See {@link rtvref.types.ARRAY_args ARRAY_args} instead.\n *\n * The {@link rtvref.types.WEAK_MAP WEAK_MAP} and {@link rtvref.types.WEAK_SET WEAK_SET}\n *  types do not apply because, due to their nature, their elements cannot be\n *  iterated.\n *\n * @typedef {Object} rtvref.types.collection_args\n * @property {number} [length] The exact number of elements required in\n *  the collection. A negative value allows for any number of entries. Zero\n *  requires an empty collection. Ignored if not a\n *  {@link rtvref.types.FINITE FINITE} number.\n *\n *  Applies to: All collection types.\n *\n * @property {rtvref.types.typeset} [keys] A typeset describing each key\n *  in the collection.\n *\n *  If the type is {@link rtvref.types.MAP_OBJECT MAP_OBJECT}, this argument is\n *   hard set to the {@link rtvref.types.STRING STRING} type due to the nature of\n *   its JavaScript `Object`-based implementation and does not need to be specified.\n *\n *  Applies to: {@link rtvref.types.MAP_OBJECT MAP_OBJECT} (with restrictions),\n *   {@link rtvref.types.MAP MAP}, {@link rtvref.types.MAP WEAK_MAP}.\n *\n * @property {string} [keyExp] A string-based regular expression describing the\n *  names of keys found in the collection. By default, there are no restrictions\n *  on key names. Ignored if the key type is not {@link rtvref.types.STRING STRING},\n *  as specified in `keys`.\n *\n *  For example, to require numerical keys, the following expression could be\n *   used: `\"^\\\\d+$\"`.\n *\n *  Applies to: {@link rtvref.types.MAP_OBJECT MAP_OBJECT},\n *   {@link rtvref.types.MAP MAP}, {@link rtvref.types.MAP WEAK_MAP}.\n *\n * @property {string} [keyFlagSpec] A string specifying any flags to use with\n *  the regular expression specified in `keyExp`. Ignored if _falsy_ or if\n *  `keyExp` is not specified. See the\n *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp RegExp#flags}\n *  parameter for more information.\n *\n *  Applies to: {@link rtvref.types.MAP_OBJECT MAP_OBJECT},\n *   {@link rtvref.types.MAP MAP}, {@link rtvref.types.MAP WEAK_MAP}.\n *\n * @property {rtvref.types.typeset} [values] A typeset describing each value in\n *  the collection. Defaults to the {@link rtvref.types.ANY ANY} type which allows\n *  _anything_. All values must match this typeset (but the collection is not\n *  required to have any elements to be considered valid, unless `length` is\n *  specified).\n *\n *  For example, to require arrays of non-empty string values as values in the\n *   collection, the following typeset could be used: `[[types.STRING]]`.\n *\n *  Applies to: All collection types.\n *\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n * @see {@link rtvref.types.SET}\n * @see {@link rtvref.types.WEAK_SET}\n */\n\n/**\n * <h3>Typeset</h3>\n *\n * Describes the possible types for a given value. It can be any one of the following\n *  JavaScript types:\n *\n * - {@link rtvref.types.OBJECT Object}: For the root or a nested\n *   {@link rtvref.shape_descriptor shape descriptor} of _implied_\n *   {@link rtvref.types.OBJECT OBJECT} type (unless paired with a specific object type\n *   like {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, for example, when using the\n *   Array notation, e.g. `[PLAIN_OBJECT, {...}]`). If the object is empty (has no properties),\n *   nothing will be verified (anything will pass).\n * - {@link rtvref.types.STRING String}: For a single type, such as\n *   {@link rtvref.types.FINITE FINITE} for a finite number. Must be one of the types\n *   defined in {@link rtvref.types}.\n * - {@link rtvref.types.FUNCTION Function}: For a\n *   {@link rtvref.types.custom_validator custom validator} that will verify the value of the\n *   property using custom code. Since the Array form is not being used (only the validator is\n *   being provided), it's always invoked immediately. Since a type is not provided, the\n *   {@link rtvref.types.ANY ANY} type is implied.\n * - {@link rtvref.types.ARRAY Array}: For multiple type possibilities, optionally\n *   {@link rtvref.qualifiers qualified}, using a short-circuit __OR__ conjunction, which means\n *   the value of the property being described must match _at least one_ of the types listed, but\n *   not all. Matching is done in a short-circuit fashion, from the first to the last element in\n *   the typeset. If a simpler type is a more likely match, it's more performant to specify it\n *   first/earlier in the typeset to avoid a match attempt on a nested shape or Array.\n *   - Cannot be an empty Array.\n *   - A given type may not be included more than once in the typeset, but may appear\n *     again in a nested typeset (when a parent typeset describes an\n *     {@link rtfref.types.ARRAY Array} or type of {@link rtfref.types.OBJECT Object}).\n *   - An Array is necessary to {@link rtvref.qualifiers qualify} the typeset as not\n *     required (see _Typeset Qualifiers_ below).\n *   - An Array is necessary if a type needs or requires\n *     {@link rtvref.types.type_arguments arguments}.\n *   - If the __first__ element (or second, if a {@link rtvref.types.qualifiers qualifier}\n *     is provided, and this, in a typeset that is _not_\n *     {@link rtvref.types.fully_qualified_typeset fully-qualified}), is an `Object`,\n *     it's treated as a nested {@link rtvref.shape_descriptor shape descriptor}\n *     describing an object of the default {@link rtvref.types.OBJECT OBJECT} type.\n *     To include a shape descriptor at any other position within the array, it\n *     __must__ be preceded by a type, even if the default `OBJECT` type is being\n *     used (i.e. `OBJECT` must be specified as the type). For example, all\n *     these typesets are equivalent (and equivalent to just `{name: STRING}`\n *     as the typeset): `[{name: STRING}]`, `[REQUIRED, {name: STRING}]`, and\n *     `[REQUIRED, OBJECT, {name: STRING}]`, describing an object that has a name\n *     property which is a non-empty string. Changing it to `[STRING, {name: STRING}]`,\n *     however, does __not__ mean, \"a non-empty string, or an object with a name\n *     property which is a non-empty string\". In this case, `{name: STRING}` would\n *     be treated as {@link rtvref.types.STRING_args STRING arguments}, which is\n *     likely not the desired intent. The object would have to be preceded by an\n *     object type (e.g. {@link rtvref.types.OBJECT OBJECT},\n *     {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, etc.) to have it interpreted\n *     as in the OR case.\n *   - If an element is an `Array` (any position), it's treated as a __nested list__\n *     with an implied {@link rtvref.types.ARRAY ARRAY} type, e.g.\n *     `[BOOLEAN, [STRING, FINITE]]` would describe a property that should be a boolean,\n *     or an array of non-empty strings or finite numbers. See the `ARRAY` type\n *     reference for more information on _shorthand_ and _full_ notations.\n *   - If an element is a `Function`, it must be the __last__ element in the Array\n *     and will be treated as a {@link rtvref.types.custom_validator custom validator}.\n *     Only one validator can be specified for a given typeset (additional validators\n *     may appear in nested typesets).\n *\n * <h4>Typeset Qualifiers</h4>\n *\n * All typesets use an _implied_ {@link rtvref.qualifiers.REQUIRED REQUIRED}\n *  qualifier unless otherwise specified. To qualify a typeset, a\n *  {@link rtvref.qualifiers qualifier} may be specified as the __first__ element\n *  in the `Array` form (if specified, it must be the first element). For example,\n *  `{note: [EXPECTED, STRING]}` would describe an object with a 'note' property\n *  that is an expected, but not required, string, which could therefore be either\n *  empty or even `null`. The `Array` form must be used in order to qualify a\n *  typeset as other than required, and the qualifier applies to all immediate\n *  types in the typeset (which means each nested typeset can have its own qualifier).\n *\n * <h4>Example: Object</h4>\n *\n * <pre><code>const contactShape = {\n *   name: rtv.t.STRING, // required, non-empty, string\n *   tags: [rtv.t.ARRAY, [rtv.t.STRING]], // required array of non-empty strings\n *   // tags: [[rtv.t.STRING]], // same as above, but using shortcut array format\n *   details: { // required nested object of type `OBJECT` (default)\n *     birthday: [rtv.q.EXPECTED, rtv.t.DATE] // Date (could be null)\n *   },\n *   notes: [rtv.q.OPTIONAL, rtv.t.STRING, function(value) { // optional string...\n *     return !value || value.length < 500; // ...less than 500 characters long, if specified\n *   }]\n * };\n *\n * const contact = {\n *   name: 'John Doe',\n *   tags: ['colleagues', 'sports'],\n *   details: {\n *     birthday: null // not specified\n *   }\n * };\n *\n * rtv.verify(contact, contactShape); // OK\n *\n * const walletShape = {\n *   contacts: [[contactShape]], // list of contacts using nested shape\n *   address: {\n *     street: rtv.t.STRING\n *     // ...\n *   },\n *   money: rtv.t.FINITE\n * };\n *\n * rtv.verify({\n *   contacts: [contact],\n *   address: {street: '123 Main St'},\n *   money: 100\n * }, walletShape); // OK\n * </code></pre>\n *\n * <h4>Example: String</h4>\n *\n * <pre><code>rtv.verify('foo', rtv.t.STRING); // OK\n * rtv.verify('foo', rtv.t.FINITE); // ERROR\n * </code></pre>\n *\n * <h4>Example: Array</h4>\n *\n * <pre><code>const typeset = [rtv.t.STRING, rtv.t.FINITE]; // non-empty string, or finite number\n * rtv.verify('foo', typeset); // OK\n * rtv.verify(1, typeset); // OK\n * </code></pre>\n *\n * <h4>Example: Function</h4>\n *\n * <pre><code>rtv.verify(123, (v) => v > 100); // OK\n * rtv.verify('123', [rtv.t.STRING, (v) => parseInt(v) > 100); // OK\n * </code></pre>\n *\n * <h4>Example: Alternate Qualifier</h4>\n *\n * <pre><code>const person = {\n *   name: rtv.t.STRING, // required, non-empty\n *   age: [rtv.q.OPTIONAL, rtv.t.FINITE, (v) => v >= 18] // 18 or older, if specified\n * };\n * rtv.verify({name: 'Bob'}, person); // OK\n * rtv.verify({name: ''}, person); // ERROR\n * rtv.verify({name: 'Steve', age: 17}, person); // ERROR\n * rtv.verify({name: 'Steve', age: null}, person); // OK\n * </code></pre>\n *\n * @typedef {(Object|string|Array|Function)} rtvref.types.typeset\n */\n\n/**\n * <h3>Fully-Qualified Typeset</h3>\n *\n * A {@link rtvref.types.typeset typeset} expressed without any shortcut notations\n *  or implied/default types to make it easier to parse, especially as the `match`\n *  parameter given to a {@link rtvref.types.custom_validator custom validator}.\n *  A fully-qualified typeset always uses the array notation, and has a single\n *  {@link rtvref.qualifiers qualifier} as its first element, followed by\n *  at least one type, and at most one validator.\n *\n * For example:\n *\n * - `STRING` -> `[REQUIRED, STRING]`\n * - `{note: STRING}` -> `[REQUIRED, OBJECT, {note: [REQUIRED, STRING]}]`\n * - `[[FINITE]]` -> `[REQUIRED, ARRAY, [REQUIRED, FINITE]]`\n * - `(v) => !!v` -> `[REQUIRED, ANY, (v) => !!v]`\n *\n * @typedef {Array} rtvref.types.fully_qualified_typeset\n */\n\n/**\n * <h3>Custom Validator</h3>\n *\n * A function used as a {@link rtvref.types.typeset typeset}, or as a subset to\n *  a typeset, to provide custom verification of the value being verified.\n *\n * A typeset may only have one validator, and the validator is _only called if\n *  the value being verified was verified by at least one type in the typeset_.\n *  The validator must be the __last__ element within the typeset (if the typeset\n *  is an array, and a validator is needed). The validator must also be\n *  specified _after_ the {@link rtvref.qualifiers qualifier} in a typeset Array.\n *\n * The validator is invoked immediately after the first type match, but _only if\n *  a type match is made_. If the typeset is not\n *  {@link rtvref.types.fully_qualified_typeset fully-qualified} and does not\n *  explicitly specify a type, the {@link rtvref.types.ANY ANY} type is implied,\n *  which will match _any_ value, which means the validator will always be called.\n *\n * There is one disadvantage to using a custom validator: It cannot be de/serialized\n *  via JSON, which means it cannot be transmitted or persisted. One option would be\n *  to customize the de/serialization to JSON by serializing the validator to a\n *  special object with properties that would inform the deserialization process\n *  on how to reconstruct the validator dynamically.\n *\n * @typedef {function} rtvref.types.custom_validator\n * @param {*} value The value being verified.\n * @param {Array} match A __first-level__, {@link rtvref.types.fully_qualified_typeset fully-qualified}\n *  typeset describing the type that matched. This means the first level of this\n *  subset of `typeset` (the 3rd parameter) is fully-qualified, but any nested\n *  {@link rtvref.shape_descriptor shape descriptors} or arrays will not be (they\n *  will remain references to the same shapes/arrays in `typeset`).\n *\n * For example, if the given typeset was `[PLAIN_OBJECT, {note: STRING}]`, this\n *  parameter would be a new typeset array `[REQUIRED, PLAIN_OBJECT, {note: STRING}]`,\n *  and the `typeset` parameter would be the original `[PLAIN_OBJECT, {note: STRING}]`.\n *\n * If the given typeset was `[STRING, FINITE]` and FINITE matched, this parameter\n *  would be `[REQUIRED, FINITE]` and the `typeset` parameter would be the\n *  original `[STRING, FINITE]`.\n * @param {rtvref.types.typeset} typeset Reference to the typeset used for\n *  verification. Note that the typeset may contain nested typeset(s), and may\n *  be part of a larger parent typeset (though there would be no reference to\n *  the parent typeset, if any). This typeset is as it was specified in the\n *  parent shape, and therefore it may not be fully-qualified.\n * @returns {boolean} A _truthy_ value to verify, a _falsy_ value to reject.\n * @see {@link rtvref.validation.isValidator}\n */\n\n// Creates a definition object.\n// @param {string} value Type value. Must not be empty.\n// @param {boolean} [hasArgs=false] If the type takes arguments.\n// @param {boolean} [isObject=false] If the type is an object type.\n// @returns {{value: boolean, hasArgs: boolean, isObject: boolean}} Type definition.\nconst def = function(value, hasArgs, isObject) {\n  return {\n    value,\n    hasArgs: !!hasArgs,\n    isObject: !!isObject\n  };\n};\n\n// map of type key (string) to type definition (see def() for shape)\nconst defs = {\n  /**\n   * The any type is special in that it allows _anything_, which includes `null`\n   *  and `undefined` values. Because of this, it's the most liberal in terms of\n   *  types as well as qualifiers. A more specific type should be used whenever\n   *  possible to ensure a higher degree of confidence in the value being validated.\n   *\n   * Any rules per qualifiers:\n   *\n   * - REQUIRED: Property must be defined _somewhere_ in the prototype chain, but\n   *   its value can be anything, including `null` and `undefined`.\n   * - EXPECTED: Same rules as REQUIRED.\n   * - OPTIONAL: Since this qualifier removes the property's need for existence\n   *   in the prototype chain, it renders the verification moot (i.e. the property\n   *   might as well not be included in the {@link rtvref.shape_descriptor shape descriptor}\n   *   unless a {@link rtvref.types.custom_validator custom validator} is being\n   *   used to do customized verification.\n   *\n   * @name rtvref.types.ANY\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  ANY: def('any'),\n\n  // TODO[future]: Add 'exp: string' and 'expFlags: string' args (strings because of JSON requirement...)\n  //  for a regular expression test. Similar prop names to collection_args.\n  /**\n   * <h3>String Arguments</h3>\n   * @typedef {Object} rtvref.types.STRING_args\n   * @property {string} [exact] An exact string to match.\n   * @property {string} [partial] A partial value to match (must be somewhere\n   *  within the string). Ignored if empty string, or `exact` is specified. `min`\n   *  and `max` take __precedence__ over this argument (the length will be\n   *  validated first, then a partial match will be attempted).\n   * @property {number} [min] Minimum inclusive length. Defaults to 1 for a\n   *  `REQUIRED` string, and 0 for an `EXPECTED` or `OPTIONAL` string. Ignored if\n   *  `exact` is specified, or `min` is not a {@link rtvref.types.FINITE FINITE}\n   *  number >= 0.\n   * @property {number} [max] Maximum inclusive length. Negative means no maximum.\n   *  Ignored if `exact` is specified, `max` is not a\n   *  {@link rtvref.types.FINITE FINITE} number, or `max` is less than `min`.\n   * @see {@link rtvref.types.STRING}\n   */\n\n  /**\n   * String rules per qualifiers:\n   *\n   * - REQUIRED: Must be a non-empty string.\n   * - EXPECTED | OPTIONAL: May be an empty string.\n   *\n   * In all cases, the value must be a string {@link rtvref.types.primitives primitive}.\n   *  Note that `new String('hello') !== 'hello'` because the former is an _object_, not a string.\n   *\n   * Arguments (optional): {@link rtvref.types.STRING_args}\n   *\n   * @name rtvref.types.STRING\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  STRING: def('string', true),\n\n  /**\n   * Boolean rules per qualifiers: Must be a boolean {@link rtvref.types.primitives primitive}.\n   *  Note that `new Boolean(true) !== true` because the former is an _object_, not a boolean.\n   * @name rtvref.types.BOOLEAN\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  BOOLEAN: def('boolean'),\n\n  /**\n   * Symbol rules per qualifiers: Must be a symbol {@link rtvref.types.primitives primitive}.\n   * @name rtvref.types.SYMBOL\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  SYMBOL: def('symbol'),\n\n  /**\n   * <h3>Numeric Value Arguments</h3>\n   *\n   * Applicable to all numeric types.\n   *\n   * @typedef {Object} rtvref.types.numeric_args\n   * @property {string} [exact] An exact number to match. Ignored if not\n   *  within normal range of the type (e.g. for `NUMBER`, could be `+Infinity`,\n   *  or even `NaN` if the qualifier is not `REQUIRED`; but these values would be\n   *  ignored by `FINITE` since they aren't part of the `FINITE` range).\n   * @property {number} [min] Minimum inclusive value. Ignored if `exact` is\n   *  specified, `min` is `NaN`, or `min` is not within normal range of the type.\n   * @property {number} [max] Maximum inclusive value. Ignored if `exact` is\n   *  specified, `max` is `NaN`, `max` is not within normal range of the type,\n   *  or `max` is less than `min`.\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.FLOAT}\n   * @see {@link rtvref.qualifiers}\n   */\n\n  /**\n   * Number rules per qualifiers:\n   *\n   * - REQUIRED: Cannot be `NaN`, but could be `+Infinity`, `-Infinity`.\n   * - EXPECTED | OPTIONAL: Could be `NaN`, `+Infinity`, `-Infinity`.\n   *\n   * In all cases, the value must be a number {@link rtvref.types.primitives primitive}.\n   *  Note that `new Number(1) !== 1` because the former is an _object_, not a number.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.NUMBER\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.FINITE}\n   */\n  NUMBER: def('number', true),\n\n  /**\n   * Finite rules per qualifiers: Cannot be `NaN`, `+Infinity`, `-Infinity`. The\n   *  value can be either a safe integer or a {@link rtvref.types.FLOAT floating point number}.\n   *  It must also be a number {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.FINITE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n   */\n  FINITE: def('finite', true),\n\n  /**\n   * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} integer,\n   *  but is not necessarily _safe_. It must also be a number\n   *  {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.INT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.FLOAT}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n   */\n  INT: def('int', true),\n\n  /**\n   * Float rules per qualifiers: Must be a {@link rtvref.types.FINITE finite}\n   *  floating point number. It must also be a number\n   *  {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.FLOAT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.INT}\n   */\n  FLOAT: def('float', true),\n\n  /**\n   * Function rules per qualifiers: Must be a `function`.\n   * @name rtvref.types.FUNCTION\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  FUNCTION: def('function'),\n\n  /**\n   * RegExp rules per qualifiers: Must be a `RegExp` instance.\n   * @name rtvref.types.REGEXP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n   */\n  REGEXP: def('regexp'),\n\n  /**\n   * Date rules per qualifiers: Must be a `Date` instance.\n   * @name rtvref.types.DATE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n   */\n  DATE: def('date'),\n\n  /**\n   * Error rules per qualifiers: Must be an `Error` instance.\n   * @name rtvref.types.ERROR\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n   */\n  ERROR: def('error'),\n\n  /**\n   * Promise rules per qualifiers: Must be a `Promise` instance.\n   * @name rtvref.types.PROMISE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n   */\n  PROMISE: def('promise'),\n\n  // TODO[future]: Short-hand 'exact' with `[ARRAY, 2, [STRING]]` or `[2, [STRING]]` syntax?\n  /**\n   * <h3>Array Arguments</h3>\n   * @typedef {Object} rtvref.types.ARRAY_args\n   * @property {number} [length] Exact length. Ignored if not a\n   *  {@link rtvref.types.FINITE FINITE} number >= 0.\n   * @property {number} [min] Minimum inclusive length. Ignored if `exact` is\n   *  specified, or `min` is not a {@link rtvref.types.FINITE FINITE} number >= 0.\n   * @property {number} [max] Maximum inclusive length. Negative means no maximum.\n   *  Ignored if `exact` is specified, `max` is not a\n   *  {@link rtvref.types.FINITE FINITE} number, or `max` is less than `min`.\n   * @see {@link rtvref.types.ARRAY}\n   */\n\n  /**\n   * Array rules per qualifiers: Must be an `Array`. Empty arrays are permitted,\n   *  unless arguments prevent them.\n   *\n   * Arguments (optional): {@link rtvref.types.ARRAY_args},\n   *  {@link rtvref.types.typeset Array typeset}. Note that the `ARRAY` type must\n   *  be specified when using arguments (i.e. the shorthand notation cannot\n   *  be used).\n   *\n   * When describing arrays, either _shorthand_ or _full_ notation may be used.\n   *  In the shorthand notation, the `ARRAY` type isn't necessary, but\n   *  {@link rtvref.types.ARRAY_args arguments} can't be specified. In the full\n   *  notation, the `ARRAY` type is required, but arguments can optionally be\n   *  specified, as can the array that follows it.\n   *\n   * __NOTE__: It's important to realize that arrays are essentially\n   *  nested {@link rtvref.types.typeset Array typesets}. They represent a\n   *  set of types that will be used to validate each element of an array using\n   *  a short-circuit OR conjunction, looking for the first type that matches.\n   *\n   * <h4>Example: Simple array</h4>\n   *\n   * The 'value' property must be an array (possibly empty) of any type of value.\n   *\n   * <pre><code>{\n   *   value: [ARRAY]\n   * }\n   * </code></pre>\n   *\n   * __NOTE__: Since arrays are, in reality, nested\n   *  {@link rtvref.types.typeset Array typesets}, and since an empty array is\n   *  an invalid Array typeset, it's not possible to use the shorthand notation\n   *  to indicate what could be the equivalent: `[[]]`. The inner Array typeset\n   *  would be deemed _invalid_.\n   *\n   * <h4>Example: Shorthand notation</h4>\n   *\n   * The 'value' property must be an array (possibly empty) of finite numbers of\n   *  any value.\n   *\n   * <pre><code>{\n   *   value: [[FINITE]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Shorthand, mixed types</h4>\n   *\n   * The 'value' property must be either a boolean; or an array (possibly empty) of\n   *  finite numbers of any value, or non-empty strings.\n   *\n   * <pre><code>{\n   *   value: [BOOLEAN, [FINITE, STRING]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Full notation</h4>\n   *\n   * The 'value' property must be an array (possibly empty) of finite numbers of\n   *  any value, or non-empty strings.\n   *\n   * <pre><code>{\n   *   value: [ARRAY, [FINITE, STRING]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Full, mixed types, arguments</h4>\n   *\n   * The 'value' property must be either a boolean; or a non-empty array of finite\n   *  numbers of any value, or non-empty strings.\n   *\n   * <pre><code>{\n   *   value: [BOOLEAN, ARRAY, {min: 1}, [FINITE, STRING]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Full, no Array typeset</h4>\n   *\n   * The 'value' property must be a non-empty array of any type of value.\n   *\n   * <pre><code>{\n   *   value: [ARRAY, {min: 1}]\n   * }\n   * </code></pre>\n   *\n   * @name rtvref.types.ARRAY\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  ARRAY: def('array', true),\n\n  /**\n   * An _any_ object is anything that is __not__ a {@link rtvref.types primitive}, which\n   *  means it includes the `Array` type, as well as functions and arguments, and\n   *  other JavaScript _object_ types. To test for an array, use the\n   *  {@link rtvref.types.ARRAY ARRAY} type. To test for a function, use the\n   *  {@link rtvref.types.FUNCTION FUNCTION} type.\n   *\n   * The following values are considered any objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new function() {}` (class instance) (also see {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT})\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   *\n   * {@link rtvref.types.primitives Primitive} values __are not__ considered any objects,\n   *  especially when the qualifier is {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n   *  Note that `typeof null === 'object'` in JavaScript; the `ANY_OBJECT` type\n   *  allows testing for this undesirable fact.\n   *\n   * Any object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.ANY_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  ANY_OBJECT: def('anyObject', true, true),\n\n  /**\n   * An object is one that extends from `JavaScript.Object` (i.e. an _instance_\n   *  of _something_ that extends from Object) and is not a\n   *  {@link rtvref.types.FUNCTION function}, {@link rtvref.types.ARRAY array},\n   *  {@link rtvref.types.REGEXP regular expression}, function arguments object,\n   *  {@link rtvref.types.MAP map}, {@link rtvref.types.WEAK_MAP weak map},\n   *  {@link rtvref.types.SET set}, {@link rtvref.types.WEAK_SET weak set}, nor a\n   *  {@link rtvref.types primitive}.\n   *\n   * This is the __default__ (imputed) type for\n   *  {@link rtvref.shape_descriptor shape descriptors}, which means the object itself\n   *  (the value being tested), prior to being checked against its shape, will be\n   *  tested according to this type.\n   *\n   * The following values are considered objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `new function() {}` (class instance)\n   *\n   * The following values __are not__ considered objects:\n   *\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  OBJECT: def('object', true, true),\n\n  /**\n   * A _plain_ object is one that is created directly from the `Object` constructor,\n   *  whether using `new Object()` or the literal `{}`.\n   *\n   * The following values are considered plain objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   *\n   * The following values __are not__ considered plain objects:\n   *\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `new function() {}` (class instance)\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Plain object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.PLAIN_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  PLAIN_OBJECT: def('plainObject', true, true),\n\n  /**\n   * {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} arguments.\n   * @typedef {Object} rtvref.types.CLASS_OBJECT_args\n   * @property {function} [ctr] A reference to a constructor function. If specified,\n   *  the class object (instance) must have this class function in its inheritance\n   *  chain such that `<class_object> instanceof ctr === true`. Note that this\n   *  property is not serializable to JSON. If not specified, then the object\n   *  must be an {@link rtvref.types.OBJECT OBJECT} that is not a\n   *  {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT} among the other values that\n   *  are not considered class objects.\n   * @property {rtvref.shape_descriptor} [shape] A description of the class object's\n   *  shape.\n   */\n\n  /**\n   * A _class_ object is one that is created by invoking the `new` operator on a\n   *  function (other than a primitive type function), generating a new object,\n   *  commonly referred to as a _class instance_. This object's prototype\n   *  (`__proto__`) is a reference to that function's `prototype` and has a\n   *  `constructor` property that is `===` to the function.\n   *\n   * The following values are considered class objects:\n   *\n   * - `new function() {}`\n   *\n   * The following values __are not__ considered class objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Class object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.types.CLASS_OBJECT_args}\n   *\n   * @name rtvref.types.CLASS_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  CLASS_OBJECT: def('classObject', true, true),\n\n  /**\n   * A _map_ object is an {@link rtvref.types.OBJECT OBJECT} that is treated as a\n   *  hash map with an expected set of keys and values. Keys can be described\n   *  using a regular expression, and values can be described using a\n   *  {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n   *\n   * Map object rules per qualifiers: Same as {@link rtvref.types.OBJECT OBJECT} rules.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_args}\n   *\n   * @name rtvref.types.MAP_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP}\n   * @see {@link rtvref.types.WEAK_MAP}\n   */\n  MAP_OBJECT: def('mapObject', true, true),\n\n  /**\n   * An ES6 map supports any value as its keys, unlike a\n   *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n   *  be described using a regular expression (if they are strings), and values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted\n   *  by default.\n   *\n   * Map rules per qualifiers: Must be a `Map` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_args}\n   *\n   * @name rtvref.types.MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   * @see {@link rtvref.types.WEAK_MAP}\n   */\n  MAP: def('map', true),\n\n  /**\n   * An ES6 weak map supports any _object_ as its keys, unlike a\n   *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings,\n   *  and a {@link rtvref.types.MAP MAP} that supports any type of value.\n   *\n   * Weak map rules per qualifiers: Must be a `WeakMap` instance.\n   *\n   * @name rtvref.types.WEAK_MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   * @see {@link rtvref.types.MAP}\n   */\n  WEAK_MAP: def('weakMap'), // not iterable, so does not accept any collection args\n\n  /**\n   * An ES6 set is a collection of _unique_ values without associated keys. Values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted\n   *  by default.\n   *\n   * Set rules per qualifiers: Must be a `Set` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_args}\n   *\n   * @name rtvref.types.SET\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.WEAK_SET}\n   */\n  SET: def('set', true),\n\n  /**\n   * An ES6 weak set is a collection of weakly held _unique_ _objects_ without\n   *  associated keys.\n   *\n   * Weak set rules per qualifiers: Must be a `WeakSet` instance.\n   *\n   * @name rtvref.types.WEAK_SET\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.SET}\n   */\n  WEAK_SET: def('weakSet'), // not iterable, so does not accept any collection args\n\n  /**\n   * JSON rules per qualifiers: Must be a JSON value:\n   *\n   * - {@link rtvref.types.STRING string}, however __empty strings are permitted__,\n   *   even if the qualifier is `REQUIRED`;\n   * - {@link rtvref.types.BOOLEAN boolean};\n   * - {@link rtvref.types.FINITE finite number};\n   * - {@link rtvref.types.PLAIN_OBJECT plain object};\n   * - {@link rtvref.types.ARRAY array};\n   * - `null`\n   *\n   * Since this type checks for _any_ valid JSON value, empty string and `null`\n   *  values are permitted, even when the typeset is qualified as `REQUIRED`.\n   *  Therefore, the `REQUIRED` qualifier has the same effect as the `EXPECTED`\n   *  qualifier.\n   *\n   * @name rtvref.types.JSON\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  JSON: def('json')\n};\n\n//\n// ^^^^^^^ INSERT NEW TYPES ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Default object type: {@link rtvref.types.OBJECT}\n * @const {string} rtvref.types.DEFAULT_OBJECT_TYPE\n */\nexport const DEFAULT_OBJECT_TYPE = defs.OBJECT.value;\n\n/**\n * Enumeration (`string -> string`) of __object__ {@link rtvref.types types}. These\n *  are all the types that describe values which are essentially maps of various\n *  keys to values.\n * @name rtvref.types.objTypes\n * @type {rtvref.Enumeration}\n */\nexport const objTypes = new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    if (defs[name].isObject) {\n      types[name] = defs[name].value;\n    }\n  });\n  return types;\n}(), 'objTypes');\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.types types} that accept\n *  arguments.\n * @name rtvref.types.argTypes\n * @type {rtvref.Enumeration}\n */\nexport const argTypes = new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    if (defs[name].hasArgs) {\n      types[name] = defs[name].value;\n    }\n  });\n  return types;\n}(), 'argTypes');\n\n/**\n * Enumeration (`string -> string`) of all {@link rtvref.types types}.\n * @name rtvref.types.types\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    types[name] = defs[name].value;\n  });\n  return types;\n}(), 'types');\n","////// Qualifier Definitions\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Qualifiers</h2>\n * @namespace rtvref.qualifiers\n */\n\n/**\n * Required qualifier: Property _must_ exist and be of the expected type.\n *  Depending on the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, and does not\n *  allow its value to be `null` or `undefined`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.REQUIRED\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst REQUIRED = '!';\n\n/**\n * Expected qualifier: Property _should_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, does _not_ allow\n *  its value to be `undefined`, but does _allow_ its value to be `null`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.EXPECTED\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst EXPECTED = '+';\n\n/**\n * Optional qualifier: Property _may_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced (i.e. less so\n *  than with the `EXPECTED` qualifier).\n *\n * Unless otherwise stated in type-specific rules, this qualifier _allows_ a\n *  property value to be `null` as well as `undefined`, and does _not_ require\n *  the property to be defined anywhere in the prototype chain.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.OPTIONAL\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst OPTIONAL = '?';\n\n//\n// ^^^^^^^ INSERT NEW QUALIFIERS ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Default qualifier: {@link rtvref.qualifiers.REQUIRED}\n * @const {string} rtvref.qualifiers.DEFAULT_QUALIFIER\n */\nexport const DEFAULT_QUALIFIER = REQUIRED;\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.qualifiers qualifiers}.\n * @name rtvref.qualifiers.qualifiers\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration({\n  REQUIRED,\n  EXPECTED,\n  OPTIONAL\n}, 'qualifiers');\n","////// isFinite validator\n\nimport {default as _isFinite} from 'lodash/isFinite';\n\nimport types from '../types';\nimport qualifiers from '../qualifiers';\n\n/**\n * Type: {@link rtvref.types.FINITE FINITE}\n * @const {string} rtvref.validator.isFinite.type\n */\nexport const type = types.FINITE;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isFinite.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.FINITE FINITE} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validator.isFinite\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isFinite(v, q = qualifiers.REQUIRED, args) {\n  let valid = _isFinite(v); // eliminates NaN, +/-Infinity\n\n  if (valid && args) { // then check args\n    if (_isFinite(args.exact)) { // ignore if NaN, +/-Infinity\n      valid = (v === args.exact);\n    } else {\n      let min;\n      if (valid && _isFinite(args.min)) { // ignore if NaN, +/-Infinity\n        min = args.min;\n        valid = (v >= min);\n      }\n\n      if (valid && _isFinite(args.max)) { // ignore if NaN, +/-Infinity\n        if (min === undefined || args.max >= min) {\n          valid = (v <= args.max);\n        } // else, ignore\n      }\n    }\n  }\n\n  return valid;\n}\n","////// isArray validator\n\nimport {default as _isArray} from 'lodash/isArray';\n\nimport isFinite from './isFinite';\n\nimport types from '../types';\nimport qualifiers from '../qualifiers';\n\n/**\n * Type: {@link rtvref.types.ARRAY ARRAY}\n * @const {string} rtvref.validator.isArray.type\n */\nexport const type = types.ARRAY;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isArray.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ARRAY ARRAY} type.\n * @function rtvref.validator.isArray\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.ARRAY_args} [args] Type arguments.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isArray(v, q = qualifiers.REQUIRED, args) {\n  let valid = _isArray(v);\n\n  if (valid && args) { // then check args\n    if (isFinite(args.length) && args.length >= 0) {\n      valid = (v.length === args.length);\n    } else {\n      let min;\n      if (valid && isFinite(args.min) && args.min >= 0) {\n        min = args.min;\n        valid = (v.length >= min);\n      }\n\n      if (valid && isFinite(args.max) && args.max >= 0) {\n        if (min === undefined || args.max >= min) {\n          valid = (v.length <= args.max);\n        } // else, ignore\n      }\n    }\n  }\n\n  return valid;\n}\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar weakMapTag = '[object WeakMap]';\n\n/**\n * Checks if `value` is classified as a `WeakMap` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n * @example\n *\n * _.isWeakMap(new WeakMap);\n * // => true\n *\n * _.isWeakMap(new Map);\n * // => false\n */\nfunction isWeakMap(value) {\n  return isObjectLike(value) && getTag(value) == weakMapTag;\n}\n\nmodule.exports = isWeakMap;\n","////// isWeakMap validator\n\nimport {default as _isWeakMap} from 'lodash/isWeakMap';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * @const {string} rtvref.validator.isWeakMap.type\n */\nexport const type = types.WEAK_MAP;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isWeakMap.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.WEAK_MAP WEAK_MAP} type.\n * @function rtvref.validator.isWeakMap\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isWeakMap(v) {\n  return _isWeakMap(v);\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar weakSetTag = '[object WeakSet]';\n\n/**\n * Checks if `value` is classified as a `WeakSet` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n * @example\n *\n * _.isWeakSet(new WeakSet);\n * // => true\n *\n * _.isWeakSet(new Set);\n * // => false\n */\nfunction isWeakSet(value) {\n  return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n}\n\nmodule.exports = isWeakSet;\n","////// isWeakSet validator\n\nimport {default as _isWeakSet} from 'lodash/isWeakSet';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.WEAK_SET WEAK_SET}\n * @const {string} rtvref.validator.isWeakSet.type\n */\nexport const type = types.WEAK_SET;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isWeakSet.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.WEAK_SET WEAK_SET} type.\n * @function rtvref.validator.isWeakSet\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isWeakSet(v) {\n  return _isWeakSet(v);\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n","var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n","////// isRegExp validator\n\nimport {default as _isRegExp} from 'lodash/isRegExp';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.REGEXP REGEXP}\n * @const {string} rtvref.validator.isRegExp.type\n */\nexport const type = types.REGEXP;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isRegExp.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.REGEXP REGEXP} type.\n * @function rtvref.validator.isRegExp\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isRegExp(v) {\n  return _isRegExp(v);\n}\n","////// isObject validator\n\nimport {default as _isObjectLike} from 'lodash/isObjectLike';\n\n// avoid circular dependency with isMap and isSet validators by using lodash\nimport {default as _isMap} from 'lodash/isMap';\nimport {default as _isSet} from 'lodash/isSet';\n\nimport isArray from './isArray';\nimport isWeakMap from './isWeakMap';\nimport isWeakSet from './isWeakSet';\nimport isRegExp from './isRegExp';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.OBJECT OBJECT}\n * @const {string} rtvref.validator.isObject.type\n */\nexport const type = types.OBJECT;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isObject.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.OBJECT OBJECT} type.\n *\n * Determines if a value is an object that extends from `JavaScript.Object` and\n *  is not a function, array, regex, map, weak map, set, weak set, or primitive.\n *\n * @function rtvref.validator.isObject\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isObject(v) { // no qualifier rules, no args\n  return _isObjectLike(v) && // excludes primitives and functions\n      !isArray(v) && // excludes arrays which are otherwise object-like (typeof [] === 'object')\n      !_isMap(v) && !isWeakMap(v) && // excludes weak/maps\n      !_isSet(v) && !isWeakSet(v) && // excludes weak/sets\n      !isRegExp(v); // excludes regex\n}\n","////// isString validator\n\nimport isFinite from './isFinite';\n\nimport types from '../types';\nimport qualifiers from '../qualifiers';\n\n/**\n * Type: {@link rtvref.types.STRING STRING}\n * @const {string} rtvref.validator.isString.type\n */\nexport const type = types.STRING;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isString.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.STRING STRING} type.\n *\n * Determines if a value is a string literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new String('value')`, which is an object that is a string.\n *\n * @function rtvref.validator.isString\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.STRING_args} [args] Type arguments.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isString(v, q = qualifiers.REQUIRED, args) {\n  let valid = (typeof v === 'string');\n\n  if (valid) {\n    if (q === qualifiers.REQUIRED) {\n      valid = !!v; // cannot be empty when required\n    }\n\n    if (valid && args) { // then check args\n      if (isString(args.exact, qualifiers.EXPECTED)) {\n        valid = (v === args.exact);\n      } else {\n        let min;\n        if (valid && isFinite(args.min) && args.min >= 0) {\n          min = args.min;\n          valid = (v.length >= min);\n        }\n\n        if (valid && isFinite(args.max) && args.max >= 0) {\n          if (min === undefined || args.max >= min) {\n            valid = (v.length <= args.max);\n          } // else, ignore\n        }\n\n        if (valid && args.partial) {\n          valid = v.includes(args.partial);\n        }\n      }\n    }\n  }\n\n  return valid;\n}\n","////// isFunction validator\n\nimport {default as _isFunction} from 'lodash/isFunction';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.FUNCTION FUNCTION}\n * @const {string} rtvref.validator.isFunction.type\n */\nexport const type = types.FUNCTION;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isFunction.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.FUNCTION FUNCTION} type.\n * @function rtvref.validator.isFunction\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isFunction(v) {\n  return _isFunction(v);\n}\n","////// isBoolean validator\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.BOOLEAN BOOLEAN}\n * @const {string} rtvref.validator.isBoolean.type\n */\nexport const type = types.BOOLEAN;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isBoolean.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.BOOLEAN BOOLEAN} type.\n *\n * Determines if a value is a boolean literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Boolean(true)`, which is an object that is a boolean.\n *\n * @function rtvref.validator.isBoolean\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isBoolean(v) {\n  return (v === true || v === false);\n}\n","////// isTypeset validation module\n\nimport {default as _forEach} from 'lodash/forEach';\n\nimport isArray from '../validator/isArray';\nimport isObject from '../validator/isObject';\nimport isString from '../validator/isString';\nimport isFunction from '../validator/isFunction';\n\nimport {default as types, argTypes, objTypes, DEFAULT_OBJECT_TYPE} from '../types';\nimport qualifiers from '../qualifiers';\n\n/**\n * Determines if a value is a typeset.\n * @function rtvref.validation.isTypeset\n * @param {*} v Value to validate.\n * @param {Object} [options] Validation options.\n * @param {boolean} [options.deep=false] If truthy, deeply-validates any nested typesets. Note\n *  that typesets in nested shapes are also deeply-validated.\n * @param {boolean} [options.fullyQualified=false] If truthy, the typeset must be fully-qualified.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.typeset}\n */\nexport default function isTypeset(v, {deep = false, fullyQualified = false} = {}) {\n  // FIRST: make sure it's an acceptable type for a typeset: object (shape),\n  //  string (just a plain type name), function (validator), or array (non-empty)\n  let valid = !!(v && (isObject(v) || (isString(v) && types.check(v)) || isFunction(v) ||\n      (isArray(v) && v.length > 0)));\n\n  // THEN: check if needs to be fully-qualified, and check deep within if requested\n  if (valid && fullyQualified) {\n    // must now be an array with at least 2 elements: [qualifier, type]\n    if (isArray(v) && v.length >= 2) {\n      const usedTypes = {}; // @type {Object.<string,boolean>} map of simple type to `true`\n      let curType; // @type {string} current in-scope type\n      let argType; // @type {(string|undefined)} current in-scope type IIF it accepts args\n\n      // Updates the current in-scope type (curType) and marks it as used in usedTypes.\n      //  If the type has already been used, it sets valid to false.\n      // @param {string} type New in-scope type.\n      const updateCurType = function(type) {\n        // set the rule as the current in-scope type\n        curType = type;\n\n        if (usedTypes[curType]) {\n          // a type cannot appear more than once in a typeset (but nested is OK)\n          valid = false;\n        }\n        usedTypes[curType] = true;\n      };\n\n      // iterate through each element in the typeset array to make sure all required\n      //  rules/properties of a fully-qualified typeset are specified\n      _forEach(v, function(rule, i) {\n        if (i === 0) {\n          // first position must always be the qualifier\n          // more efficient to check for a string first than to always iterate\n          //  all qualifiers (or all types, below) when it isn't since we know\n          //  they're always strings\n          valid = isString(rule) && !!qualifiers.check(rule);\n        } else if (isString(rule)) {\n          // additional qualifier, or simple type\n          if (qualifiers.check(rule)) {\n            // cannot have more than one qualifier and qualifier must be in first position\n            //  (and this is not the first position because that's handled specially, above)\n            valid = false;\n          } else if (!types.check(rule)) {\n            // if not a qualifier, it must be a valid type (since it's a string)\n            valid = false;\n          } else {\n            // set the rule as the current in-scope type\n            updateCurType(rule);\n\n            // update the in-scope arg type: reset to undefined if it doesn't take\n            //  args; otherwise, update it (NOTE: currently, there are no types that\n            //  _require_ args, only ones that optionally have args, so we don't\n            //  have to ensure that args were given when we change the type)\n            argType = argTypes.check(rule);\n          }\n        } else if (isFunction(rule)) {\n          // must be a validator, but there can't be more than 1, it must be\n          //  in the last position (which enforces the 1 count), always after the\n          //  qualifier, and since the typeset must be FQ'd, we must have an\n          //  in-scope type\n          valid = !!(curType && (i + 1 === v.length));\n        } else if (isObject(rule)) {\n          // could be a shape, or type args (either way, it's a single object)\n          // since the typeset must be fully-qualified, argType must already be\n          //  a type that takes arguments, since arguments are always provided\n          //  via objects (NOTE: for object types, the args are the shapes themselves,\n          //  except for CLASS_OBJECT where the shape is specified within the args;\n          //  still, there is always only ever at most one object per type that\n          //  accepts args, never more)\n          if (argType) {\n            // consume the object as the in-scope arg type's arguments\n            argType = undefined;\n          } else {\n            // since the typeset must be fully-qualified and we don't already\n            //  have an in-scope arg type, the typeset is invalid\n            valid = false;\n          }\n\n          // only go deep if the object is a shape, which means the current in-scope\n          //  type must be an object type\n          if (valid && deep && objTypes.check(curType)) {\n            // if it's a class object, the shape is an optional sub-property of the object;\n            //  if it's a map object, there is no shape; otherwise, it's the object itself\n            const shape = (curType === types.CLASS_OBJECT) ? rule.shape :\n              ((curType === types.MAP_OBJECT) ? undefined : rule);\n\n            // validate all of the shape's typesets (each own-prop should be a typeset)\n            shape && _forEach(shape, function(ts, prop) {\n              valid = isTypeset(ts, {deep, fullyQualified}); // recursive\n              return valid; // break on first invalid\n            });\n          }\n        } else if (isArray(rule)) {\n          // nested typeset for an array type: in-scope type must be ARRAY\n          if (curType === types.ARRAY) {\n            // go deep if requested; otherwise, assume it's valid\n            valid = !deep || isTypeset(rule, {deep, fullyQualified});\n          } else {\n            valid = false;\n          }\n        } else {\n          // any other type in an array typeset is not supported\n          valid = false;\n        }\n\n        return valid; // break if no longer valid\n      });\n\n      // make sure at least one type was specified\n      valid = valid && !!curType;\n    } else {\n      // automatically invalid if not an array because a typeset must be in the\n      //  array form in order to be FQ'd\n      valid = false;\n    }\n\n  // NEXT: if it's an array, valid, and does not need to be FQ'd, check its\n  //  definition, and deep (if requested)\n  } else if (valid && !fullyQualified && isArray(v)) {\n    const usedTypes = {}; // @type {Object.<string,boolean>} map of simple type to `true`\n    let curType; // @type {string} current in-scope type\n    let argType; // @type {(string|undefined)} current in-scope type IIF it accepts args\n    let hasQualifier = false; // true if a qualifier is specified (not implied)\n\n    // Updates the current in-scope type (curType) and marks it as used in usedTypes.\n    //  If the type has already been used, it sets valid to false.\n    // @param {string} type New in-scope type.\n    const updateCurType = function(type) {\n      // set the rule as the current in-scope type\n      curType = type;\n\n      if (usedTypes[curType]) {\n        // a type cannot appear more than once in a typeset (but nested is OK)\n        valid = false;\n      }\n      usedTypes[curType] = true;\n    };\n\n    // iterate through each element in the typeset array to make sure all required\n    //  rules/properties of a typeset are specified\n    _forEach(v, function(rule, i) {\n      if (isString(rule)) {\n        if (qualifiers.check(rule)) {\n          hasQualifier = true;\n          valid = (i === 0); // must be in the first position\n        } else if (types.check(rule)) {\n          // set the rule as the current in-scope type\n          updateCurType(rule);\n          // update current in-scope arg type IIF it accepts args\n          // NOTE: currently, there are no types that _require_ args, only ones\n          //  that optionally have args, so we don't have to ensure that args\n          //  were given when we change the type\n          argType = argTypes.check(rule);\n        } else {\n          // some unknown/invalid qualifier or type\n          valid = false;\n        }\n      } else if (isFunction(rule)) {\n        // must be a validator, but there can't be more than 1, and it must be\n        //  in the last position (which enforces the 1 count), and always after\n        //  the qualifier (if any)\n        valid = (i + 1 === v.length);\n        if (valid && !curType) {\n          // if we have a validator but no in-scope type, ANY is implied\n          updateCurType(types.ANY);\n        }\n      } else if (isObject(rule)) {\n        // could be a shape, or type args (either way, it's just one object)\n        // NOTE: for object types, the args are the shapes themselves, except\n        //  for CLASS_OBJECT where the shape is specified within the args; still,\n        //  there is always only ever at most one object per type that accepts\n        //  args, never more\n        if (!argType) {\n          // since there's no in-scope arg type, the object must be a shape using\n          //  the default OBJECT type, but it must be in the first position (or\n          //  second if the first element was a qualifier)\n          updateCurType(DEFAULT_OBJECT_TYPE);\n          valid = valid && (i === 0 || (hasQualifier && i === 1));\n          // NOTE: do not set argType because the shape is the default object type's\n          //  args, so they should be consumed by the in-scope arg type\n        } else {\n          // consume the object as the in-scope arg type's arguments\n          // NOTE: currently, there are no types that _require_ args, only ones\n          //  that optionally have args, so we don't have to ensure that args\n          //  were given when we change the type\n          argType = undefined;\n        }\n\n        // only go deep if the object is a shape, which means the current in-scope\n        //  type must be an object type\n        if (valid && deep && objTypes.check(curType)) {\n          // if it's a class object, the shape is an optional sub-property of the object;\n          //  if it's a map object, there is no shape; otherwise, it's the object itself\n          const shape = (curType === types.CLASS_OBJECT) ? rule.shape :\n            ((curType === types.MAP_OBJECT) ? undefined : rule);\n\n          // validate all of the shape's typesets (each own-prop should be a typeset)\n          shape && _forEach(shape, function(ts, prop) {\n            valid = isTypeset(ts, {deep, fullyQualified}); // recursive\n            return valid; // break on first invalid\n          });\n        }\n      } else if (isArray(rule)) {\n        // if the current in-scope type is not ARRAY, set it since a nested array\n        //  implies the ARRAY type\n        if (curType !== types.ARRAY) {\n          updateCurType(types.ARRAY);\n          // in this case, the in-scope arg type should be updated to ARRAY since\n          //  arrays accept optional args, but since the current in-scope type\n          //  was not set, this must be a short-hand ARRAY notation, which means\n          //  args cannot be specified, therefore we update argType to undefined\n          //  to clear it from the previous type (if it was set) and clear it\n          //  from this type as well\n          argType = undefined;\n        }\n\n        if (valid && deep) {\n          valid = isTypeset(rule, {deep, fullyQualified}); // recursive\n        }\n      } else {\n        // any other type in an array typeset is not supported\n        valid = false;\n      }\n\n      return valid; // break if no longer valid\n    });\n\n    // make sure at least one type was specified\n    valid = valid && !!curType;\n\n  // NEXT: if it's a shape descriptor, check if deep is requested as long as it's\n  //  valid and does not need to be FQ'd (otherwise, 'v' must be an array and\n  //  would be invalid as a FQ'd typeset)\n  } else if (valid && deep && !fullyQualified && isObject(v)) {\n    // we need to deep-validate a shape descriptor, which means each one of its\n    //  own-properties must be a valid typeset\n    const props = Object.keys(v);\n    _forEach(props, function(prop) {\n      valid = isTypeset(v[prop], {deep, fullyQualified}); // recursive\n      return valid; // break if no longer valid\n    });\n  }\n\n  // ELSE: must valid (but non-array/object and doesn't need to be FQ'd), or invalid\n\n  return valid;\n}\n","////// isShape validation module\n\nimport isObject from '../validator/isObject';\n\n/**\n * Determines if a value is a {@link rtvref.shape_descriptor shape}.\n * @function rtvref.validation.isShape\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport default function isShape(v) {\n  return isObject(v);\n}\n","////// isTypeArgs validation module\n\nimport isObject from '../validator/isObject';\n\n/**\n * Determines if a value is a {@link rtvref.types.type_arguments type arguments}\n *  object.\n * @function rtvref.validation.isTypeArgs\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport default function isTypeArgs(v) {\n  return isObject(v);\n}\n","////// isValidator validation module\n\nimport isFunction from '../validator/isFunction';\n\n/**\n * Determines if a value is a {@link rtvref.types.custom_validator custom validator}.\n * @function rtvref.validation.isValidator\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport default function isValidator(v) {\n  // TODO[plugins]: should this module be renamed to isCustomValidator since it's\n  //  perhaps overloaded with 'validator' concept for plugins @see rtvref.validator?\n  return isFunction(v);\n}\n","////// RtvSuccess Class\n\n/**\n * Runtime Verification Success Indicator\n *\n * Describes a successful runtime verification of a value against a given\n *  {@link rtvref.shape_descriptor shape} or {@link rtvref.types.typeset typeset}\n *  (note that a shape is a type of typeset).\n *\n * @class rtvref.RtvSuccess\n */\nexport default class RtvSuccess {\n  // JSDoc is provided at the @class level\n  constructor() {\n    Object.defineProperties(this, {\n      /**\n       * Flag indicating the validation succeeded. Always `true`.\n       * @readonly\n       * @name rtvref.RtvSuccess#valid\n       * @type {boolean}\n       * @see {@link rtvref.RtvError#valid}\n       */\n      valid: {\n        enumerable: true,\n        configurable: true,\n        value: true\n      }\n    });\n  }\n\n  /**\n   * A string representation of this instance.\n   * @method rtvref.RtvSuccess#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    return '{rtvref.RtvSuccess}';\n  }\n}\n","////// RtvError Class\n\nimport isTypeset from './validation/isTypeset';\nimport isArray from './validator/isArray';\n\nimport {print} from './util';\n\n// @type {function} The super class.\nconst extendsFrom = Error;\n\n// Renders a path array as a string.\n// @param {Array.<string>} path\n// @returns {string}\nconst renderPath = function(path) {\n  return `/${path.join('/')}`;\n};\n\n/**\n * @external JS_Error\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n */\n\n/**\n * Runtime Verification Error Indicator\n *\n * Describes a failed runtime verification of a value against a given\n *  {@link rtvref.shape_descriptor shape} or {@link rtvref.types.typeset typeset}\n *  (note that a shape is a type of typeset).\n *\n * @class rtvref.RtvError\n * @extends {external:JS_Error}\n * @param {*} value The value being verified.\n * @param {rtvref.types.typeset} typeset The typeset used for verification.\n * @param {Array.<string>} path The path deep into `value` where the failure occurred.\n *  An empty array signifies the _root_ (top-level) value that was checked.\n * @param {rtvref.types.fully_qualified_typeset} cause The fully qualified typeset\n *  that caused the failure.\n * @throws {Error} If `typeset`, `path`, or `cause` is invalid.\n */\nconst RtvError = function(value, typeset, path, cause) {\n  // NOTE: We're using the old ES5 way of doing classical inheritance rather than\n  //  an ES6 'class' because extending from Error doesn't appear to work very well,\n  //  at least not with Babel 6.x. It seems OK in Node 9.x, however. Anyway,\n  //  declaring it as `class RtvError extends Error {...}` and then attempting to\n  //  override `toString()` does not work. Calls to this method, whether direct\n  //  or implicit, continue to call `Error.prototype.toString()`, as confirmed\n  //  by checking the prototype chain, which isn't properly constructed.\n\n  if (!isTypeset(typeset)) {\n    throw new Error(`Invalid typeset: ${print(typeset)}`);\n  }\n\n  if (!isArray(path)) {\n    throw new Error(`Invalid path: ${print(path)}`);\n  }\n\n  if (!isTypeset(cause, {fullyQualified: true})) {\n    throw new Error(`Invalid cause (expecting a fully-qualified typeset): ${print(cause)}`);\n  }\n\n  // NOTE: For some reason, calling `extendsFrom.call(this, message)` has\n  //  no effect on `this` whatsoever, perhaps because it's calling native code,\n  //  or there's something strange about the built-in Error type, so we just\n  //  call the super's constructor as a formality.\n  extendsFrom.call(this);\n  this.message = `Verification failed: value=${print(value)}, path=\"${renderPath(path)}\"`;\n  this.name = 'RtvError';\n\n  Object.defineProperties(this, {\n    /**\n     * Flag indicating the validation failed. Always `false`.\n     * @readonly\n     * @name rtvref.RtvError#valid\n     * @type {boolean}\n     * @see {@link rtvref.RtvSuccess#valid}\n     */\n    valid: {\n      enumerable: true,\n      configurable: true,\n      value: false\n    },\n\n    /**\n     * Value that failed verification.\n     * @readonly\n     * @name rtvref.RtvError#value\n     * @type {*}\n     */\n    value: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return value;\n      }\n    },\n\n    /**\n     * Reference to the typeset used for verification.\n     * @readonly\n     * @name rtvref.RtvError#typeset\n     * @type {rtvref.types.typeset}\n     */\n    typeset: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return typeset;\n      }\n    },\n\n    /**\n     * Path from `value` to the nested property that caused the failure. This\n     *  is a shallow clone of the original `path` specified.\n     * @readonly\n     * @name rtvref.RtvError#path\n     * @type {Array.<string>}\n     */\n    path: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return path.concat(); // shallow clone\n      }\n    },\n\n    // DEBUG TODO make sure the example is what it ends-up being...:\n    /**\n     * Fully qualified typeset that caused the failure. This will be a subset\n     *  of `typeset`, and possibly of a nested typeset within `typeset`\n     *  expressing only the direct cause of the failure.\n     *\n     * If `typeset` is `[[rtv.t.STRING]]` (a required array of required strings),\n     *  and `value` is `['a', 2]`, this property would be `[rtv.q.REQUIRED, rtv.t.STRING]`\n     *  because the failure would ultimately have been caused by the nested `rtv.t.STRING`\n     *  typeset.\n     *\n     * @readonly\n     * @name rtvref.RtvError#cause\n     * @type {rtvref.types.fully_qualified_typeset}\n     */\n    cause: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return cause;\n      }\n    }\n  });\n};\n\nRtvError.prototype = Object.create(extendsFrom.prototype);\nRtvError.prototype.constructor = RtvError;\n\n/**\n * A string representation of this instance.\n * @method rtvref.RtvError#toString\n * @returns {string} String representation.\n */\nRtvError.prototype.toString = function() {\n  return `{rtvref.RtvError value=${print(this.value)}, path=\"${renderPath(this.path)}\"}`;\n};\n\nexport default RtvError;\n","////// Main Implementation Module\n\nimport {default as _forEach} from 'lodash/forEach';\n\n// NOTE: These validators are used for internal purposes. Validation of actual\n//  VALUES being checked should always be done via the _validatorMap.\nimport isArray from './validator/isArray';\nimport isObject from './validator/isObject';\nimport isString from './validator/isString';\nimport isFunction from './validator/isFunction';\nimport isBoolean from './validator/isBoolean';\n\nimport isTypeset from './validation/isTypeset';\nimport isShape from './validation/isShape';\nimport isTypeArgs from './validation/isTypeArgs';\nimport isValidator from './validation/isValidator';\n\nimport {DEFAULT_OBJECT_TYPE, argTypes, default as types} from './types';\nimport {DEFAULT_QUALIFIER, default as qualifiers} from './qualifiers';\nimport {print} from './util';\nimport RtvSuccess from './RtvSuccess';\nimport RtvError from './RtvError';\n\n/**\n * <h2>RTV Implementation Module</h2>\n *\n * Provides the internal implementation for the externally-facing {@link rtv RTV}\n *  API, as well as utilities for {@link rtvref.validator type validators}.\n *\n * @namespace rtvref.impl\n */\n\n/**\n * [Internal] Map of validator type (string) to validator function.\n * @private\n * @name rtvref.impl._validatorMap\n * @type {Object.<string,rtvref.validator.type_validator>}\n */\nconst _validatorMap = {};\n\n/**\n * Get the qualifier given any kind of typeset.\n * @function rtvref.impl.getQualifier\n * @param {rtvref.types.typeset} typeset The typeset in question.\n * @returns {string} The applicable {@link rtvref.qualifiers qualifier} for the\n *  specified typeset.\n * @throws {Error} If `typeset` is not a valid typeset.\n */\nconst getQualifier = function(typeset) {\n  if (!isTypeset(typeset)) { // start by validating so we can be confident later\n    throw new Error(`Invalid typeset=\"${print(typeset)}\"`);\n  }\n\n  let qualifier = DEFAULT_QUALIFIER;\n\n  if (isArray(typeset)) {\n    // if there's a qualifier, it must be the first element, and since it's a\n    //  valid typeset, it cannot be an empty array\n    if (isString(typeset[0]) && qualifiers.check(typeset[0])) {\n      qualifier = typeset[0];\n    }\n  }\n  // else, it's either an object, function, or string, which implies the default\n  //  qualifier\n\n  return qualifier;\n};\n\n/**\n * Fully-qualifies a typeset, shallow (i.e. the first level only; nested typesets\n *  are not fully-qualified).\n *\n * This function does not modify the input `typeset`.\n *\n * @function rtvref.impl.fullyQualify\n * @param {rtvref.types.typeset} typeset Typeset to fully-qualify.\n * @param {rtvref.qualifiers} [qualifier=rtvref.qualifiers.DEFAULT_QUALIFIER]\n *  Qualifier to be used, especially if the typeset is\n *  a simple {@link rtvref.types type},\n *  a {@link rtvref.shape_descriptor shape}, or\n *  a {@link rtvref.types.custom_validator custom validator} that was\n *  cherry-picked out of a typeset whose qualifier should be used instead of\n *  the default one.\n * @returns {rtvref.types.fully_qualified_typeset} A new, fully-qualified typeset\n *  representing the input `typeset`. Only the first/immediate level of the\n *  input typeset is fully-qualified. The new array returned contains references\n *  to elements within the input typeset.\n * @throws {Error} If `typeset` is not a valid typeset.\n */\nconst fullyQualify = function(typeset, qualifier = DEFAULT_QUALIFIER) {\n  if (!isTypeset(typeset)) { // start by validating so we can be confident later\n    throw new Error(`Invalid typeset=\"${print(typeset)}\"`);\n  }\n\n  qualifiers.verify(qualifier);\n\n  // NOTE: from this point on, we ASSUME that the typeset is valid, which lets\n  //  us make assumptions about what we find within it; without this knowledge,\n  //  the algorithm below would not work\n\n  if (!isArray(typeset)) {\n    // must be either a string, shape, or function with an implied qualifier\n    if (isShape(typeset)) {\n      // must be a nested shape descriptor with default object type\n      return [qualifier, DEFAULT_OBJECT_TYPE, typeset];\n    }\n\n    // if a validator, it has an implied type of ANY\n    if (isValidator(typeset)) {\n      return [qualifier, types.ANY, typeset];\n    }\n\n    // string (basic type)\n    return [qualifier, typeset];\n  }\n\n  const fqts = []; // ALWAYS a new array\n  let curType; // @type {(string|undefined)} current type in scope or undefined if none\n\n  // typeset is an array: iterate its elements and build fqts iteratively\n  typeset.forEach(function(rule, i) {\n    // qualifiers are non-empty strings\n    if (i === 0 && (!isString(rule) || !qualifiers.check(rule))) {\n      // NOTE: since this is an Array typeset, it has its own qualifier; the\n      //  in-context `options.qualifier` would not apply to it\n      fqts.push(DEFAULT_QUALIFIER); // add implied qualifier\n    }\n\n    if (isString(rule)) {\n      // must be a type\n      curType = rule;\n      fqts.push(curType);\n    } else if (i === 0 && isShape(rule)) {\n      // nested shape descriptor using default object type\n      curType = DEFAULT_OBJECT_TYPE;\n      fqts.push(curType, rule);\n    } else if (isTypeArgs(rule)) {\n      // args for curType since typeset is an array and object is not in first position\n      fqts.push(rule);\n    } else if (isValidator(rule)) {\n      // validator: ANY is implied type if none specified\n      if (!curType) {\n        curType = types.ANY;\n        fqts.push(curType);\n      }\n\n      fqts.push(rule);\n    } else {\n      // must be an array\n      if (curType !== types.ARRAY) {\n        // add implied ARRAY type\n        curType = types.ARRAY;\n        fqts.push(curType);\n      }\n\n      fqts.push(rule);\n    }\n  });\n\n  return fqts;\n};\n\n/**\n * [Internal] Common options for the various `check*()` functions.\n * @private\n * @typedef rtvref.impl._checkOptions\n * @property {Array.<string>} path The current path into the typeset. Initially\n *  empty to signify the root (top-level) value being checked.\n * @property {boolean} isTypeset `true` if the typeset specified in the public\n *  parameters has already been validated and is a valid __shallow__ typeset;\n *  `false` otherwise (which means the typeset should first be validated before\n *  being processed).\n * @property {(string|undefined)} qualifier The {@link rtvref.qualifiers qualifier}\n *  in context; `undefined` if none. This property should be used when calling\n *  a `check*()` function for a typeset subtype where the typeset's qualifier\n *  should be attributed to the subtype rather than the\n *  {@link rtvref.qualifiers.DEFAULT_QUALIFIER default qualifier}.\n * @see {@link rtvref.impl.check}\n * @see {@link rtvref.impl.checkShape}\n * @see {@link rtvref.impl.checkType}\n */\n\n/**\n * [Internal] Gets check options for any of the `check*()` functions.\n * @private\n * @function rtvref.impl._getCheckOptions\n * @param {Object} [current] Current options, used as a basis for new options.\n * @param {Object} [override] Override options, which will overwrite any `current`\n *  options.\n * @returns {rtvref.impl._checkOptions} A full, new options object, based on\n *  `given` options, if any. Invalid given options will be ignored. The object\n *  returned may contain references to objects in `given` depending on property\n *  types.\n * @see {@link rtvref.impl.check}\n * @see {@link rtvref.impl.checkShape}\n * @see {@link rtvref.impl.checkType}\n * @throws {Error} If `current.path` or `override.path` is specified and not an array.\n */\nconst _getCheckOptions = function(current = {}, override = {}) {\n  if (current.path && !isArray(current.path)) {\n    throw new Error(`current.path must be an Array when specified, current.path=${print(current.path)}`);\n  }\n\n  if (override.path && !isArray(override.path)) {\n    throw new Error(`override.path must be an Array when specified, override.path=${print(override.path)}`);\n  }\n\n  return {\n    path: override.path || current.path || [],\n    isTypeset: !!override.isTypeset || !!current.isTypeset || false,\n    qualifier: override.qualifier || current.qualifier || undefined\n  };\n};\n\n/**\n * Checks a value using a simple type assuming the\n *  {@link rtvref.qualifiers.DEFAULT_QUALIFIER default qualifier}.\n * @function rtvref.impl.checkType\n * @param {*} value Value to check.\n * @param {string} type Simple type name, must be one of {@link rtvref.types.types}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} A success indicator if the\n *  `value` is compliant to the type; an error indicator if not.\n * @throws {Error} If `type` is not a valid type name.\n * @see {@link rtvref.types}\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst checkWithType = function(value, type /*, options*/) {\n  types.verify(type);\n\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  if (_validatorMap[type]) {\n    // call the validator for the specified type\n    const valid = _validatorMap[type](value, options.qualifier || DEFAULT_QUALIFIER);\n\n    if (valid) {\n      return new RtvSuccess();\n    }\n\n    return new RtvError(value, type, options.path, fullyQualify(type, options.qualifier));\n  }\n\n  throw new Error(`Missing validator for type=\"${print(type)}\"`);\n};\n\n/**\n * Checks a value using a {@link rtvref.shape_descriptor shape descriptor} and\n *  ensure the value's type is the default object type.\n * @function rtvref.impl.checkShape\n * @param {Object} value Value to check. Must be of the\n *  {@link rtvref.types.DEFAULT_OBJECT_TYPE default} object type.\n * @param {Object} shape Expected shape of the `value`. Must be an\n *  {@link rtvref.types.OBJECT OBJECT}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} A success indicator if the\n *  `value` is compliant to the shape; an error indicator if not.\n * @throws {Error} If `shape` is not an {@link rtvref.types.OBJECT OBJECT}.\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst checkWithShape = function(value, shape /*, options*/) {\n  if (!isShape(shape)) {\n    throw new Error(`Invalid shape=${print(shape)}`);\n  }\n\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n  const shapeType = DEFAULT_OBJECT_TYPE;\n\n  // value must be default object type\n  if (!checkWithType(value, shapeType)) { // NOTE: always check values with the _validatorMap\n    return new RtvError(value, shapeType, options.path,\n        fullyQualify(shapeType, options.qualifier));\n  }\n\n  let err; // @type {(RtvError|undefined)}\n\n  // only consider enumerable, own-properties of the shape\n  _forEach(shape, function(typeset, prop) {\n    // first, consider the qualifier and test the existence of the property\n    const qualifier = getQualifier(typeset);\n    if ((value[prop] === undefined && qualifier !== qualifiers.OPTIONAL) ||\n        (value[prop] === null && qualifier === qualifiers.REQUIRED)) {\n\n      // REQUIRED and EXPECTED require the property NOT to be undefined and to\n      //  be somewhere in the prototype chain; if it wasn't in the prototype chain,\n      //  it would still be undefined, so we don't need an 'in' operator check\n\n      // REQUIRED properties cannot have a value of null/undefined, and they must\n      //  exist somewhere in the prototype chain; if the property wasn't in the\n      //  prototype chain, the value would be undefined, so we don't need to test\n      //  this here either\n\n      err = new RtvError(value, typeset, options.path.concat(prop),\n          fullyQualify(typeset, qualifier));\n      return false; // break\n    }\n\n    // then, test the property's value against the typeset (indirectly recursive)\n    const result = check(value[prop], typeset, _getCheckOptions(options, { // eslint-disable-line no-use-before-define\n      path: options.path.concat(prop),\n      qualifier,\n      isTypeset: false // don't assume it's valid since we only check shallow as we go\n    }));\n\n    if (!result.valid) {\n      err = result;\n      return false; // break\n    }\n  });\n\n  return err || (new RtvSuccess());\n};\n\n/**\n * Extracts (modifies) the next complete type from an Array typeset.\n *\n * For example, if the given `typeset` is `[EXPECTED, STRING, {string_args}, FINITE]`,\n *  the returned array would be `[EXPECTED, STRING, {atring_args}]` and `typeset`\n *  would then be `[FINITE]`.\n *\n * @param {(rtvref.types.typeset|Array)} typeset An Array typeset from which to\n *  extract the next complete type. __This Array will be modified.__ Can also\n *  be an empty array (which is not a valid typeset, but is tolerated; see the\n *  return value for more information).\n * @param {(rtvref.qualifiers|boolean)} [qualifier] Optional, and can either\n *  be a valid qualifier, `true`, or `false`.\n *\n *  <h4>Parameter is specified, and is a qualifier</h4>\n *\n *  If __a qualifier is not found in `typeset`__, this qualifier will be used to\n *  qualify the returned sub-type Array typeset. If a qualifier is found in `typeset`,\n *  this parameter is ignored. If a qualifier is __not__ found in `typeset` and\n *  this parameter is specified, then this qualifier will be used to qualify the\n *  returned sub-type Array typeset.\n *\n *  __Examples:__\n *  - `typeset = [EXPECTED, STRING, FINITE];`\n *  - `extractNextType(typeset, REQUIRED) === [EXPECTED, STRING]`, `typeset === [FINITE]`\n *  - `extractNextType(typeset) === [FINITE]`, `typeset === []`\n *  - `typeset = [FINITE];`\n *  - `extractNextType(typeset, EXPECTED) === [EXPECTED, FINITE]`\n *\n *  <h4>Parameter is specified, and is a boolean</h4>\n *\n *  If `true`, the qualifier, if any, will be included in the returned sub-type\n *  Array typeset. If `false`, the qualifier, if any, will be ignored.\n *\n *  __Examples:__\n *  - `extractNextType([STRING], true) === [STRING]`\n *  - `extractNextType([REQUIRED, STRING], true) === [EXPECTED, STRING]`\n *  - `extractNextType([REQUIRED, STRING], false) === [STRING]`\n *\n * @returns {(rtvref.types.typeset|Array)} The extracted __Array typeset__ as a\n *  new Array, which is a sub-type of the given `typeset`. This sub-typeset is\n *  not necessarily fully-qualified. If `typeset` was an empty array, an empty\n *  array is returned (which is the only case where an invalid Array typeset\n *  is tolerated, so that this function is easy to use in loops, checking for\n *  the stopping condition where the returned sub-typeset is empty).\n * @throws {Error} If `typeset` is not empty and not a valid Array typeset.\n * @throws {Error} If `qualifier` is specified but not valid.\n */\nconst extractNextType = function(typeset, qualifier) {\n  if (qualifier && !isBoolean(qualifier)) {\n    qualifiers.verify(qualifier);\n  }\n\n  // check for an array first since that's must faster than isTypeset()\n  if (!isArray(typeset) || (typeset.length > 0 && !isTypeset(typeset))) {\n    throw new Error(`Invalid array typeset=${print(typeset)}`);\n  }\n\n  if (typeset.length === 0) {\n    return [];\n  }\n\n  const subtype = []; // subset type of `typeset`\n  let type = typeset.shift(); // NOTE: [].shift() === undefined\n\n  // FIRST: check for the qualifier, which must be the first element, if specified\n  if (qualifiers.check(type)) {\n    if (qualifier !== false) {\n      subtype.push(type); // include, and ignore the specified qualifier\n    }\n\n    // next type: typeset cannot be empty because it's valid and since\n    //  there's a qualifier, there must be at least one type in it too\n    type = typeset.shift();\n  } else {\n    // must be a type or the validator, which we'll check for below\n    // use the specified qualifier, if any, and if allowed\n    if (qualifier && !isBoolean(qualifier)) {\n      subtype.push(qualifier);\n    }\n  }\n\n  if (isString(type)) {\n    // simple type\n    subtype.push(type);\n\n    // check for args if applicable to type (as of now, there are no types that\n    //  require args)\n    if (argTypes.check(type) && typeset.length > 0 && isTypeArgs(typeset[0])) {\n      subtype.push(typeset.shift());\n    }\n\n    // check for ARRAY since it could be `[ARRAY, {args}, [...]]` as complete type\n    if (type === types.ARRAY && typeset.length > 0 && isArray(typeset[0])) {\n      subtype.push(typeset.shift());\n    }\n  } else if (isShape(type) || isArray(type) || isValidator(type)) {\n    // - Shape: if the given typeset was in its original form (nothing extracted from it)\n    //  then the first type could be a shape, in which case it has an implied type of\n    //  OBJECT and is itself the args for it\n    // - Array: a nested array is an Array typeset with an implied type of ARRAY and no args\n    // - Validator: a custom validator has an implied type of ANY and no args\n    subtype.push(type);\n  }\n\n  return subtype;\n};\n\n/**\n * Checks a value using an Array typeset.\n * @function rtvref.impl.checkTypeset\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} typeset The Array typeset to check against.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the `value`\n *  is compliant to the `typeset`; error indicator otherwise. An exception is\n *  __not__ thrown if the `value` is non-compliant.\n * @throws {Error} If `typeset` is not a valid Array typeset.\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst checkWithArray = function(value, typeset /*, options*/) {\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  // check for an array first since that's must faster than isTypeset()\n  if (!isArray(typeset) || !(options.isTypeset || isTypeset(typeset))) {\n    throw new Error(`Invalid array typeset=${print(typeset)}`);\n  }\n\n  let match; // @type {(rtvref.types.fully_qualified_typeset|undefined)}\n  const qualifier = getQualifier(typeset);\n\n  // consider each type in the typeset until we find one that matches the value\n  // NOTE: an Array typeset represents multiple possibilities for a type match\n  //  using a short-circuit OR conjunction\n  // NOTE: due to the isTypeset check above, we can assume that each 'type' is\n  //  a SHALLOW-valid typeset (meaning, if it's an Array typeset, we cannot\n  //  assume that itself is valid because the isTypeset check was just shallow)\n  const typesetCopy = typeset.concat(); // shallow clone so we can modify the array locally\n  let subtype = extractNextType(typesetCopy, false); // exclude qualifier we already have\n  const idx = -1; // DEBUG no longer needed\n  console.log('===== entering while, typesetCopy=%s, idx=%s, subtype=%s', print(typesetCopy), idx, print(subtype)); // DEBUG\n  let count = -1; // DEBUG remove\n  while (subtype.length > 0) {\n    count++;\n    if (count > 4) {\n      console.log('===== FORCE-BREAK on count>4, typesetCopy=%s, idx=%s, subtype=%s', print(typesetCopy), idx, print(subtype)); // DEBUG\n      break;\n    }\n    console.log('===== starting while, typesetCopy=%s, idx=%s, subtype=%s', print(typesetCopy), idx, print(subtype)); // DEBUG\n\n    // check for the validator, which will always come alone, and since the validator\n    //  must be at the end of an Array typeset, it also signals the end of all subtypes\n    if (subtype.length === 1 && isValidator(subtype[0])) {\n      console.log('===== is validator, typesetCopy=%s, idx=%s, subtype=%s', print(typesetCopy), idx, print(subtype)); // DEBUG\n      // if we reach the validator (which must be the very last element) in this\n      //  loop, none of the types matched, unless the validator is the only\n      //  type in the typeset, at which point it gets an implied type of ANY,\n      //  which matches any value\n      // NOTE: we have to test the original typeset for the ANY condition\n      if (typeset.length === 1 || (typeset.length === 2 && qualifiers.check(typeset[0]))) {\n        match = fullyQualify(types.ANY);\n      }\n\n      break; // break (since this must be the last element in typeset)\n    } else {\n      console.log('===== calling check, typesetCopy=%s, idx=%s, subtype=%s, value=%s', print(typesetCopy), idx, print(subtype), print(value)); // DEBUG\n      const result = check(value, subtype, _getCheckOptions(options, {\n        qualifier,\n        isTypeset: false // don't assume it's valid since we only check shallow as we go\n      }));\n\n      console.log('===== check result=%s, typesetCopy=%s, idx=%s, subtype=%s, value=%s', print(result), print(typesetCopy), idx, print(subtype), print(value)); // DEBUG\n      if (result.valid) {\n        match = fullyQualify(type, qualifier);\n        console.log('===== exiting loop on break, match=%s, typesetCopy=%s, idx=%s, subtype=%s, value=%s', print(match), print(typesetCopy), idx, print(subtype), print(value)); // DEBUG\n        break; // break on first match\n      }\n    }\n\n    // next subtype\n    subtype = extractNextType(typesetCopy);\n    console.log('===== looping, typesetCopy=%s, idx=%s, subtype=%s', print(typesetCopy), idx, print(subtype)); // DEBUG\n  };\n\n  let err; // @type {(RtvError|undefined)}\n\n  if (match) {\n    // check for a validator at the end of the Array typeset and invoke it\n    const lastType = typeset[typeset.length - 1];\n    if (isValidator(lastType)) {\n      if (!lastType(value, match, typeset)) {\n        // invalid in spite of the match since the validator said no\n        err = new RtvError(value, typeset, options.path, fullyQualify(typeset, qualifier));\n      }\n      // else, valid!\n    }\n    // else, valid, since we have a match\n  } else {\n    // no match\n    err = new RtvError(value, typeset, options.path, fullyQualify(typeset, qualifier));\n  }\n\n  return err || (new RtvSuccess());\n};\n\n/**\n * Checks a value against a typeset.\n * @function rtvref.impl.check\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} typeset Expected shape/type of the value.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the `value`\n *  is compliant to the `typeset`; error indicator otherwise. An exception is\n *  __not__ thrown if the `value` is non-compliant.\n * @throws {Error} If `typeset` is not a valid typeset.\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst check = function(value, typeset /*, options*/) {\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  try {\n    if (isTypeset(typeset)) {\n      options.isTypeset = true;\n\n      if (isString(typeset)) {\n        // simple type: check value is of the type\n        return checkWithType(value, typeset, options);\n      }\n\n      if (isValidator(typeset)) {\n        // custom validator: bare function implies the ANY type\n        const match = types.ANY;\n        const fqMatch = fullyQualify(match);\n\n        // value must be ANY type, and custom validator must return true\n        // NOTE: always check values against the _validatorMap\n        const result = checkWithType(value, match, options);\n        if (!result.valid) {\n          return result;\n        }\n\n        if (typeset(value, fqMatch, match)) {\n          return new RtvSuccess();\n        }\n\n        return new RtvError(value, match, options.path, fqMatch);\n      }\n\n      if (isShape(typeset)) {\n        // shape descriptor: check value against shape\n        return checkWithShape(value, typeset, options);\n      }\n\n      if (isArray(typeset)) {\n        // Array typeset: check value against all types in typeset\n        return checkWithArray(value, typeset, options);\n      }\n\n      throw new Error(`Missing handler for type of specified typeset=${print(typeset)}`);\n    } else {\n      throw new Error(`Invalid typeset=${print(typeset)} specified`);\n    }\n  } catch (checkErr) {\n    const err = new Error(`Cannot check value: ${checkErr.message}`);\n    err.rootCause = checkErr;\n    throw err;\n  }\n};\n\n/**\n * [Internal] Registers a validator, adding a new type that can be\n *  {@link rtvref.impl.check checked}.\n *\n * If a validator has already been registered for a particular type, the previous\n *  validator is replaced by the newer one.\n *\n * @private\n * @function rtvref.impl._registerType\n * @param {rtvref.validator} validator The validator representing the type to be\n *  registered.\n * @throws {Error} if `validator` does not have the expected interface.\n */\nconst _registerType = function(validator) {\n  // NOTE: we can't dogfood and describe a shape to check() because the types\n  //  needed may not have been registered yet\n  if (!isObject(validator) || !types.check(validator.type) ||\n      !isFunction(validator.config) || !isFunction(validator.default)) {\n\n    throw new Error(`Cannot register an invalid validator for type=\"${print(validator && validator.type)}\": missing at least one required property in [type, config, default]`);\n  }\n\n  _validatorMap[validator.type] = validator.default;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Define and export the module\n\n// define the module to be exported: properties/methods with an underscore prefix\n//  will be converted to non-enumerable properties/methods\nconst impl = {\n  // internal\n  _validatorMap, // exposed mainly to support unit testing\n  _registerType,\n  _getCheckOptions,\n  // public\n  fullyQualify,\n  extractNextType,\n  checkWithType,\n  checkWithShape,\n  checkWithArray,\n  check\n};\n\n// make properties/methods with underscore prefix internal by making them\n//  non-enumerable (but otherwise, a normal property)\nObject.keys(impl).forEach(function(prop) {\n  if (prop.indexOf('_') === 0) {\n    Object.defineProperty(impl, prop, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: impl[prop]\n    });\n  }\n});\n\nexport default impl;\n","////// isAny validator\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.ANY ANY}\n * @const {string} rtvref.validator.isAny.type\n */\nexport const type = types.ANY;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isAny.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ANY ANY} type.\n * @function rtvref.validator.isAny\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isAny(v) {\n  return true; // anything goes, even undefined and null\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","////// isSymbol validator\n\nimport {default as _isSymbol} from 'lodash/isSymbol';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.SYMBOL SYMBOL}\n * @const {string} rtvref.validator.isSymbol.type\n */\nexport const type = types.SYMBOL;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isSymbol.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.SYMBOL SYMBOL} type.\n * @function rtvref.validator.isSymbol\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isSymbol(v) {\n  return _isSymbol(v);\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","var isNumber = require('./isNumber');\n\n/**\n * Checks if `value` is `NaN`.\n *\n * **Note:** This method is based on\n * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n * `undefined` and other non-number values.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n * @example\n *\n * _.isNaN(NaN);\n * // => true\n *\n * _.isNaN(new Number(NaN));\n * // => true\n *\n * isNaN(undefined);\n * // => true\n *\n * _.isNaN(undefined);\n * // => false\n */\nfunction isNaN(value) {\n  // An `NaN` primitive is the only value that is not equal to itself.\n  // Perform the `toStringTag` check first to avoid errors with some\n  // ActiveX objects in IE.\n  return isNumber(value) && value != +value;\n}\n\nmodule.exports = isNaN;\n","////// isNumber validator\n\nimport {default as _isNumber} from 'lodash/isNumber';\nimport {default as _isNaN} from 'lodash/isNaN';\n\nimport types from '../types';\nimport qualifiers from '../qualifiers';\n\n/**\n * Type: {@link rtvref.types.NUMBER NUMBER}\n * @const {string} rtvref.validator.isNumber.type\n */\nexport const type = types.NUMBER;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isNumber.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.NUMBER NUMBER} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validator.isNumber\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isNumber(v, q = qualifiers.REQUIRED, args) {\n  let valid = (typeof v === 'number');\n\n  if (valid) {\n    if (q === qualifiers.REQUIRED) {\n      // cannot be NaN\n      valid = !_isNaN(v);\n    }\n\n    if (valid && args) { // then check args\n      if (_isNumber(args.exact)) { // NaN OK for this arg (careful: NaN !== NaN...)\n        valid = (v === args.exact) || (_isNaN(v) && _isNaN(args.exact));\n      } else {\n        let min;\n        if (valid && _isNumber(args.min) && !_isNaN(args.min)) {\n          min = args.min;\n          valid = (v >= min);\n        }\n\n        if (valid && _isNumber(args.max) && !_isNaN(args.max)) {\n          if (min === undefined || args.max >= min) {\n            valid = (v <= args.max);\n          } // else, ignore\n        }\n      }\n    }\n  }\n\n  return valid;\n}\n","////// isAnyObject validator\n\nimport {default as _isObject} from 'lodash/isObject';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.ANY_OBJECT ANY_OBJECT}\n * @const {string} rtvref.validator.isAnyObject.type\n */\nexport const type = types.ANY_OBJECT;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isAnyObject.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ANY_OBJECT ANY_OBJECT} type.\n *\n * Determines if a value is _any_ type of object except a primitive.\n *\n * @function rtvref.validator.isAnyObject\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isAnyObject(v) {\n  return _isObject(v);\n}\n","////// isMap validator\n\nimport {default as _isMap} from 'lodash/isMap';\n\nimport isFinite from './isFinite';\nimport isString from './isString';\n\nimport types from '../types';\nimport qualifiers from '../qualifiers';\nimport isTypeset from '../validation/isTypeset';\n\nlet impl; // @type {rtvref.impl}\n\n/**\n * Type: {@link rtvref.types.MAP MAP}\n * @const {string} rtvref.validator.isMap.type\n */\nexport const type = types.MAP;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isMap.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n//\n// Determines if a typeset represents a string, and only a string.\n// @param {rtvref.types.typeset} ts Typeset to check.\n// @return {boolean} `true` if so; `false` otherwise.\n//\nconst isStringTypeset = function(ts) {\n  const fqts = impl.fullyQualify(ts);\n\n  // must be `[qualifier, STRING]`, otherwise no\n  return (fqts.length === 2 && fqts[1] === types.STRING);\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.MAP MAP} type.\n * @function rtvref.validator.isMap\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.collection_args} [args] Type arguments.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isMap(v, q = qualifiers.REQUIRED, args) {\n  let valid = _isMap(v);\n\n  if (valid && args) { // then check args\n    // start with the easiest/most efficient test: length\n    if (valid && isFinite(args.length) && args.length >= 0) {\n      valid = (v.size === args.length);\n    }\n\n    // remaining args, if specified, require iterating potentially the entire map\n    if (valid) {\n      // get the typeset for keys\n      const tsKeys = isTypeset(args.keys) ? args.keys : undefined;\n      // get the key expression only if the keys are expected to be strings\n      const tsKeysIsString = !!(tsKeys && isStringTypeset(tsKeys));\n      const keyExp = (tsKeysIsString && isString(args.keyExp)) ?\n        args.keyExp : undefined;\n      // get the key expression flags only if we have a key expression\n      const keyFlagSpec = (keyExp && isString(args.keyFlagSpec)) ?\n        args.keyFlagSpec : undefined;\n      // get the typeset for values\n      const tsValues = isTypeset(args.values) ? args.values : undefined;\n\n      if (tsKeys || tsValues) {\n        const reKeys = keyExp ? new RegExp(keyExp, keyFlagSpec) : undefined;\n        const it = v.entries(); // iterator\n\n        for (let elem of it) {\n          const [key, value] = elem;\n\n          if (tsKeys) {\n            valid = impl.check(key, tsKeys).valid; // check key against typeset\n            if (valid && tsKeysIsString && reKeys) {\n              valid = reKeys.test(key); // check key against regex since it's a string\n            }\n          }\n\n          if (valid && tsValues) {\n            valid = impl.check(value, tsValues).valid; // check value against typeset\n          }\n\n          if (!valid) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  return valid;\n}\n","////// isSet validator\n\nimport {default as _isSet} from 'lodash/isSet';\n\nimport isFinite from './isFinite';\n\nimport types from '../types';\nimport qualifiers from '../qualifiers';\nimport isTypeset from '../validation/isTypeset';\n\nlet impl; // @type {rtvref.impl}\n\n/**\n * Type: {@link rtvref.types.SET SET}\n * @const {string} rtvref.validator.isSet.type\n */\nexport const type = types.SET;\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n * @function rtvref.validator.isSet.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.SET SET} type.\n * @function rtvref.validator.isSet\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.collection_args} [args] Type arguments.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isSet(v, q = qualifiers.REQUIRED, args) {\n  let valid = _isSet(v);\n\n  if (valid && args) { // then check args\n    // start with the easiest/most efficient test: length\n    if (valid && isFinite(args.length) && args.length >= 0) {\n      valid = (v.size === args.length);\n    }\n\n    // remaining args, if specified, require iterating potentially the entire set\n    if (valid) {\n      // get the typeset for values\n      const tsValues = isTypeset(args.values) ? args.values : undefined;\n\n      if (tsValues) {\n        const it = v.entries(); // iterator\n\n        for (let elem of it) {\n          const value = elem.value[1];\n          valid = impl.check(value, tsValues); // check value against typeset\n          if (!valid) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  return valid;\n}\n","////// Main entry point\n\nimport {version as VERSION} from '../package.json';\nimport impl from './lib/impl';\nimport types from './lib/types';\nimport qualifiers from './lib/qualifiers';\nimport RtvSuccess from './lib/RtvSuccess';\n\n// all known types\n// TODO[plugins]: In the future, with plugins, this should be dynamically-generated somehow.\nimport * as isAny from './lib/validator/isAny';\nimport * as isBoolean from './lib/validator/isBoolean';\nimport * as isString from './lib/validator/isString';\nimport * as isFunction from './lib/validator/isFunction';\nimport * as isRegExp from './lib/validator/isRegExp';\nimport * as isSymbol from './lib/validator/isSymbol';\nimport * as isFinite from './lib/validator/isFinite';\nimport * as isNumber from './lib/validator/isNumber';\nimport * as isArray from './lib/validator/isArray';\nimport * as isAnyObject from './lib/validator/isAnyObject';\nimport * as isObject from './lib/validator/isObject';\nimport * as isMap from './lib/validator/isMap';\nimport * as isWeakMap from './lib/validator/isWeakMap';\nimport * as isSet from './lib/validator/isSet';\nimport * as isWeakSet from './lib/validator/isWeakSet';\n\n/**\n * <h1>RTV.js Reference</h1>\n *\n * Members herein are _indirectly_ exposed through the {@link rtv} object.\n * @namespace rtvref\n */\n\n/**\n * <h2>Shape Descriptor</h2>\n *\n * Describes the shape (i.e. interface) of an object as a map of properties to\n *  {@link rtvref.types.typeset typesets}. Each typeset indicates whether the\n *  property is required, expected, or optional, using {@link rtvref.qualifiers qualifiers},\n *  along with possible types. Only enumerable, own-properties of the shape are\n *  considered part of the shape.\n *\n * When a value is {@link rtv.check checked} or {@link rtv.verify verified} against\n *  a given shape, _properties on the value that are not part of the shape are\n *  ignored_. If successfully checked/verified, the value is guaranteed to provide\n *  the properties described in the shape, and each property is guaranteed to be\n *  assigned to a value of at least one type described in each property's typeset.\n *\n * The shape descriptor itself must be an {@link rtvref.types.OBJECT OBJECT}.\n *\n * @typedef {Object} rtvref.shape_descriptor\n * @see {@link rtvref.validation.isShape}\n */\n\n/**\n * <h1>RTV.js</h1>\n *\n * Runtime Verification Library for browsers and Node.js.\n * @namespace rtv\n */\nconst rtv = {\n  /**\n   * Enumeration of {@link rtvref.types types}.\n   * @name rtv.t\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  t: types,\n\n  /**\n   * Enumeration of {@link rtvref.qualifiers qualifiers}.\n   * @name rtv.q\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  q: qualifiers,\n\n  /**\n   * Checks a value against a typeset for compliance.\n   * @function rtv.check\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the\n   *  `value` is compliant to the `shape`; `RtvError` if not. __Unlike\n   *  {@link rtv.verify verify()}, an exception is not thrown__ if the\n   *  `value` is non-compliant.\n   *\n   *  Since both {@link rtvref.RtvSuccess RtvSuccess}, returned when\n   *   the check succeeds, as well as {@link rtvref.RtvError RtvError}, returned\n   *   when the check fails, have a `valid: boolean` property in common, it's\n   *   easy to test for success/failure like this:\n   *   `if (rtv.check(2, rtv.t.FINITE).valid) {...}`.\n   *\n   *  __NOTE:__ This method always returns a success indicator if RTV.js is currently\n   *   {@link rtv.config.enabled disabled}.\n   *\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.verify}\n   * @see {@link rtv.config.enabled}\n   * @see {@link rtvref.types}\n   * @see {@link rtvref.shape_descriptor}\n   */\n  check(value, typeset) {\n    if (this.config.enabled) {\n      return impl.check(value, typeset);\n    }\n\n    return new RtvSuccess();\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.check}.\n   * @function rtv.c\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the\n   *  `value` is compliant to the `shape`; `RtvError` if not. __Unlike\n   *  {@link rtv.verify verify()}, an exception is not thrown__ if the\n   *  `value` is non-compliant.\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.check}\n   */\n  c(value, typeset) {\n    return this.check(value, typeset);\n  },\n\n  /**\n   * __Requires__ a value to be compliant to a shape.\n   *\n   * NOTE: This method does nothing if RTV.js is currently\n   *  {@link rtv.config.enabled disabled}.\n   *\n   * @function rtv.verify\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {rtvref.RtvSuccess} Success indicator IIF the `value` is compliant\n   *  to the `shape`. Otherwise, an {@link rtvref.RtvError RtvError} __is thrown__.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.check}\n   * @see {@link rtv.config.enabled}\n   * @see {@link rtvref.types}\n   * @see {@link rtvref.shape_descriptor}\n   */\n  verify(value, typeset) {\n    if (this.config.enabled) {\n      const result = this.check(value, typeset);\n      if (result instanceof RtvSuccess) {\n        return result;\n      }\n\n      throw result; // expected to be an RtvError\n    }\n\n    return new RtvSuccess();\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.verify}.\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {rtvref.RtvSuccess} Success indicator IIF the `value` is compliant\n   *  to the `shape`. Otherwise, an {@link rtvref.RtvError RtvError} __is thrown__.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @see {@link rtv.verify}\n   */\n  v(value, typeset) {\n    return this.verify(value, typeset);\n  },\n\n  /**\n   * RTV Library Configuration\n   * @namespace rtv.config\n   */\n  config: Object.defineProperties({}, {\n    /**\n     * Globally enables or disables {@link rtv.verify} and {@link rtv.check}.\n     *\n     * Use this, or the shortcut {@link rtv.e}, to enable code optimization\n     *  when building source with a bundler that supports _tree shaking_ like\n     *  {@link https://rollupjs.org/ Rollup} or {@link https://webpack.js.org/ Webpack}.\n     *\n     * <h4>Example</h4>\n     *\n     * By conditionally calling {@link rtv.verify} based on the state of\n     *  {@link rtv.config.enabled}, a bundler can be configured to completely\n     *  remove the code from a production build.\n     *\n     * // TODO: Add Rollup and Webpack examples.\n     *\n     * <pre><code>if (rtv.config.enabled) {\n     *  rtv.verify(jsonResult, expectedShape);\n     * }\n     *\n     * rtv.e && rtv.v(jsonResult, expectedShape); // even shorter\n     * </code></pre>\n     *\n     * @name rtv.config.enabled\n     * @type {boolean}\n     * @see {@link rtv.enabled}\n     */\n    enabled: (function() {\n      let value = true;\n      return {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return value;\n        },\n        set(newValue) {\n          rtv.verify(newValue, rtv.t.BOOLEAN);\n          value = newValue;\n        }\n      };\n    })()\n  }),\n\n  /**\n   * Shortcut proxy for reading {@link rtv.config.enabled}.\n   * @readonly\n   * @name rtv.e\n   * @type {boolean}\n   */\n  get e() {\n    return this.config.enabled;\n  },\n\n  /**\n   * Contextual RTV Generator // TODO[docs]\n   * @function rtv.Context\n   * @param {string} context\n   */\n  Context(context) {\n    // TODO: a version with same API (less 'config') that will include 'context' in errors thrown\n  }\n};\n\n/**\n * [Internal] Library version.\n * @private\n * @name rtv._version\n * @type {string}\n */\nObject.defineProperty(rtv, '_version', {\n  enumerable: false, // internal\n  configurable: true,\n  writable: true,\n  value: VERSION\n});\n\nexport default rtv;\n\n////////////////////////////////////////////////////////////////////////////////\n// Register all known types with impl\n\n(function() { // put in an IIFE so there's nothing unnecessarily retained in any closures\n  // TODO[plugins]: In the future, with plugins, this should be dynamically-generated somehow.\n  const validators = [\n    isAny,\n    isBoolean,\n    isString,\n    isFunction,\n    isRegExp,\n    isSymbol,\n    isFinite,\n    isNumber,\n    isArray,\n    isAnyObject,\n    isObject,\n    isMap,\n    isWeakMap,\n    isSet,\n    isWeakSet\n  ];\n\n  const publicImpl = {}; // impl for validators, excluding any internal parts\n\n  Object.keys(impl).forEach(function(k) { // only enumerable methods/properties\n    publicImpl[k] = impl[k];\n  });\n\n  validators.forEach(function(val) {\n    val.config({impl: publicImpl});\n    impl._registerType(val);\n  });\n})();\n"],"names":["createBaseFor","global","freeGlobal","Symbol","root","objectProto","nativeObjectToString","symToStringTag","getRawTag","objectToString","isObjectLike","baseGetTag","hasOwnProperty","baseIsArguments","stubFalse","MAX_SAFE_INTEGER","argsTag","isLength","nodeUtil","baseUnary","baseIsTypedArray","isArray","isArguments","isBuffer","isTypedArray","baseTimes","isIndex","overArg","isPrototype","nativeKeys","funcTag","isObject","isFunction","isArrayLike","arrayLikeKeys","baseKeys","baseFor","keys","createBaseEach","baseForOwn","identity","arrayEach","baseEach","castFunction","print","value","replacer","key","val","toString","undefined","result","JSON","stringify","Enumeration","map","name","Object","values","length","Error","forEach","indexOf","push","defineProperty","concat","$values","silent","check","$name","join","pairs","k","p","def","hasArgs","defs","DEFAULT_OBJECT_TYPE","OBJECT","objTypes","types","argTypes","REQUIRED","EXPECTED","OPTIONAL","DEFAULT_QUALIFIER","type","FINITE","config","settings","isFinite","v","args","valid","_isFinite","exact","min","max","ARRAY","_isArray","coreJsData","funcProto","funcToString","isMasked","toSource","getValue","baseIsNative","getNative","Promise","mapTag","objectTag","setTag","weakMapTag","dataViewTag","DataView","Map","Set","WeakMap","getTag","baseIsMap","baseIsSet","WEAK_MAP","isWeakMap","_isWeakMap","WEAK_SET","isWeakSet","_isWeakSet","regexpTag","baseIsRegExp","REGEXP","isRegExp","_isRegExp","_isObjectLike","_isMap","_isSet","STRING","isString","q","qualifiers","partial","includes","FUNCTION","_isFunction","BOOLEAN","isBoolean","isTypeset","deep","fullyQualified","usedTypes","curType","argType","updateCurType","rule","i","shape","CLASS_OBJECT","MAP_OBJECT","_forEach","ts","prop","hasQualifier","ANY","props","isShape","isTypeArgs","isValidator","RtvSuccess","defineProperties","extendsFrom","renderPath","path","RtvError","typeset","cause","call","message","prototype","create","constructor","_validatorMap","getQualifier","qualifier","fullyQualify","verify","fqts","_getCheckOptions","current","override","checkWithType","options","arguments","checkWithShape","shapeType","err","extractNextType","subtype","shift","checkWithArray","match","typesetCopy","idx","log","count","lastType","fqMatch","checkErr","rootCause","_registerType","validator","default","impl","isAny","SYMBOL","isSymbol","_isSymbol","numberTag","isNumber","NUMBER","_isNaN","_isNumber","ANY_OBJECT","isAnyObject","_isObject","MAP","isStringTypeset","isMap","size","tsKeys","tsKeysIsString","keyExp","keyFlagSpec","tsValues","reKeys","RegExp","it","entries","elem","test","SET","isSet","rtv","enabled","newValue","t","e","context","VERSION","validators","publicImpl"],"mappings":"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"}