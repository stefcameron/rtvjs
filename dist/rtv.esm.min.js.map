{"version":3,"file":"rtv.esm.min.js","sources":["../node_modules/lodash/isArray.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isObject.js","../node_modules/lodash/isFunction.js","../node_modules/lodash/_coreJsData.js","../node_modules/lodash/_isMasked.js","../node_modules/lodash/_toSource.js","../node_modules/lodash/_baseIsNative.js","../node_modules/lodash/_getValue.js","../node_modules/lodash/_getNative.js","../node_modules/lodash/_DataView.js","../node_modules/lodash/_Map.js","../node_modules/lodash/_Promise.js","../node_modules/lodash/_Set.js","../node_modules/lodash/_WeakMap.js","../node_modules/lodash/_getTag.js","../node_modules/lodash/_baseIsMap.js","../node_modules/lodash/_baseUnary.js","../node_modules/lodash/_nodeUtil.js","../node_modules/lodash/isMap.js","../node_modules/lodash/isWeakMap.js","../node_modules/lodash/_baseIsSet.js","../node_modules/lodash/isSet.js","../node_modules/lodash/isWeakSet.js","../node_modules/lodash/_baseIsRegExp.js","../node_modules/lodash/isRegExp.js","../node_modules/lodash/_arrayEach.js","../node_modules/lodash/_createBaseFor.js","../node_modules/lodash/_baseFor.js","../node_modules/lodash/_baseTimes.js","../node_modules/lodash/_baseIsArguments.js","../node_modules/lodash/isArguments.js","../node_modules/lodash/stubFalse.js","../node_modules/lodash/isBuffer.js","../node_modules/lodash/_isIndex.js","../node_modules/lodash/isLength.js","../node_modules/lodash/_baseIsTypedArray.js","../node_modules/lodash/isTypedArray.js","../node_modules/lodash/_arrayLikeKeys.js","../node_modules/lodash/_isPrototype.js","../node_modules/lodash/_overArg.js","../node_modules/lodash/_nativeKeys.js","../node_modules/lodash/_baseKeys.js","../node_modules/lodash/isArrayLike.js","../node_modules/lodash/keys.js","../node_modules/lodash/_baseForOwn.js","../node_modules/lodash/_createBaseEach.js","../node_modules/lodash/_baseEach.js","../node_modules/lodash/identity.js","../node_modules/lodash/_castFunction.js","../node_modules/lodash/forEach.js","../src/lib/Enumeration.js","../src/lib/types.js","../src/lib/qualifiers.js","../src/lib/validation.js","../src/lib/util.js","../src/lib/RtvSuccess.js","../src/lib/impl.js","../src/rtv.js"],"sourcesContent":["/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar weakMapTag = '[object WeakMap]';\n\n/**\n * Checks if `value` is classified as a `WeakMap` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n * @example\n *\n * _.isWeakMap(new WeakMap);\n * // => true\n *\n * _.isWeakMap(new Map);\n * // => false\n */\nfunction isWeakMap(value) {\n  return isObjectLike(value) && getTag(value) == weakMapTag;\n}\n\nmodule.exports = isWeakMap;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar weakSetTag = '[object WeakSet]';\n\n/**\n * Checks if `value` is classified as a `WeakSet` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n * @example\n *\n * _.isWeakSet(new WeakSet);\n * // => true\n *\n * _.isWeakSet(new Set);\n * // => false\n */\nfunction isWeakSet(value) {\n  return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n}\n\nmodule.exports = isWeakSet;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n","var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","//// Enumeration \\\\\\\\\n\n/**\n * Simple enumeration type. Own-properties on an instance are the keys in the\n *  specified `map`, with their associated values.\n *\n * <pre><code>const state = new Enumeration({\n *   READY: 1,\n *   RUNNING: 2,\n *   STOPPED: 3,\n *   COMPLETE: 4\n * });\n *\n * state.RUNNING; // 2\n * state.verify(3); // 3 (returns the value since found in enumeration)\n * state.verify(5); // ERROR thrown\n * state.check(3); // 3 (same as verify(3) since found in enumeration)\n * state.check(5); // undefined (silent failure)\n * state.$values; // [1, 2, 3, 4] (special non-enumerable own-property)\n * </code></pre>\n *\n * @class rtvref.Enumeration\n * @param {Object.<String,*>} map Object mapping keys to values. Values cannot\n *  be `undefined`.\n * @throws {Error} If `map` is falsy or empty.\n * @throws {Error} If `map` has a key that maps to `undefined`.\n * @throws {Error} If `map` contains a duplicate value.\n */\nexport default class Enumeration {\n  // JSDoc is provided at the @class level\n  constructor(map) {\n    map = map || {};\n\n    const keys = Object.keys(map);\n    const values = [];\n\n    if (keys.length === 0) {\n      throw new Error('map must contain at least one key');\n    }\n\n    // shallow-clone each key in the map into this\n    keys.forEach((key) => {\n      if (map[key] === undefined) {\n        throw new Error('map[' + key + '] cannot be undefined');\n      }\n\n      const value = map[key];\n      if (values.indexOf(value) >= 0) {\n        throw new Error('map[' + key + '] is a duplicate value: ' + value);\n      }\n\n      values.push(value);\n      this[key] = value;\n    });\n\n    /**\n     * List of enumeration values. Values are _references_ to values in this\n     *  enumeration.\n     *\n     * Note that this own-property is non-enumerable on purpose. Enumerable\n     *  properties on this instance are the keys in this enumeration.\n     *\n     * @readonly\n     * @name rtvref.Enumeration#$values\n     * @type Array.<String>\n     */\n    Object.defineProperty(this, '$values', {\n      enumerable: false,\n      configurable: true,\n      get() {\n        return values.concat(); // shallow clone\n      }\n    });\n  }\n\n  /**\n   * Checks if a value is in this enumeration.\n   * @method rtvref.Enumeration#check\n   * @param {*} value Value to check. Cannot be undefined.\n   * @returns {(*|undefined)} The specified value if it is in this enumeration, or `undefined`\n   *  if not. An exception is __not__ thrown if the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#verify}\n   */\n  check(value) {\n    if (this.$values.indexOf(value) >= 0) {\n      return value;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Validates a value as being in this enumeration. Throws an exception if the value\n   *  is not in this enumeration, unless `silent` is true.\n   * @method rtvref.Enumeration#verify\n   * @param {*} value Value to check. Cannot be undefined.\n   * @param {boolean} [silent=false] If truthy, returns `undefined` instead of throwing\n   *  an exception if the specified value is not in this enumeration.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined` if\n   *  `silent` is true and the value is not in this enumeration.\n   * @throws {Error} If not `silent` and the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#check}\n   */\n  verify(value, silent) {\n    const result = this.check(value);\n\n    if (result === undefined && !silent) {\n      throw new Error('Invalid value for enum[' + this.$values.join(', ') + ']: ' + value);\n    }\n\n    return result;\n  }\n\n  /**\n   * A string representation of this Enumeration.\n   * @method rtvref.Enumeration#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    const pairs = Object.keys(this).map((k) => [k, this[k]]);\n    return `{rtvref.Enumeration pairs=[${pairs.map((p) => `[${p}]`).join(', ')}]}`;\n  }\n}\n","//// Type Definitions \\\\\\\\\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Types</h2>\n * @namespace rtvref.types\n */\n\n/**\n * <h3>Primitives</h3>\n *\n * In RTV.js (as in {@link https://developer.mozilla.org/en-US/docs/Glossary/Primitive ECMAScript 2015}),\n *  a _primitive_ is considered one of the following types:\n *\n * - `undefined`\n * - `null`\n * - `string` (note that `new String('s')` does not produce a _primitive_, it\n *   produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `boolean` (note that `new Boolean(true)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `number` (note that `new Number(1)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `Symbol`\n *\n * @namespace rtvref.types.primitives\n */\n\n/**\n * <h3>Rules Per Qualifiers</h3>\n *\n * {@link rtvref.qualifiers Qualifiers} state basic rules. Unless otherwise stated,\n *  every type herein abides by those basic rules. Each type will also impose\n *  additional rules specific to the type of value it represents.\n *\n * For example, while the {@link rtvref.types.FINITE FINITE} type states that the\n *  value must not be `NaN`, `+Infinity`, nor `-Infinity`; it could be `null` if\n *  the qualifier used is `EXPECTED`; and it could be `undefined` if the qualifier\n *  used is `OPTIONAL`.\n *\n * @namespace rtvref.types.rules\n */\n\n/**\n * <h3>Type Arguments</a></h3>\n *\n * Some types will accept, or may even expect, one or more arguments. Each type\n *  will specify whether it has arguments, and if they're optional or required.\n *  Arguments are specified as a single object immediately following a type in an\n *  __Array__ {@link rtvref.types.typeset typeset} (i.e. an Array must be used as\n *  the typeset in order to provide arguments for a type).\n *\n * If a type does not accept any arguments, but an arguments object is provided,\n *  it will simply be ignored (i.e. it will __not__ be treated as a nested\n *  {@link rtvref.shape_descriptor shape descriptor}). This means that, in an\n *  Array-style {@link rtvref.types.typeset typeset}, a shape descriptor\n *  __must__ always be qualified by a type, even if it's the default type\n *  attributed to a shape descriptor.\n *\n * An arguments object immediately follows its type in a typeset, such as\n *  `[PLAIN_OBJECT, {hello: STRING}]`. This would specify the value must be a\n *  {@link rtvref.types.PLAIN_OBJECT plain object} with a shape that includes a\n *  property named 'hello', that property being a\n *  {@link rtvref.qualifiers.REQUIRED required} {@link rtvref.types.STRING string}.\n *\n * @typedef {Object} rtvref.types.type_arguments\n */\n\n/**\n * <h3>Collection Descriptor</h3>\n *\n * Describes the keys and values in a collection-based object, which is one of\n *  the following types:\n *\n * - {@link rtvref.types.MAP_OBJECT MAP_OBJECT}\n * - {@link rtvref.types.MAP MAP}\n * - {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * - {@link rtvref.types.SET SET} (with some exceptions)\n * - {@link rtvref.types.WEAK_SET WEAK_SET} (with some exceptions)\n *\n * Note that an {@link rtvref.types.ARRAY ARRAY} is __not__ included in this list\n *  because the array type has special syntax for describing the type of its items.\n *  See {@link rtvref.types.ARRAY_args ARRAY_args} instead.\n *\n * For example, the following descriptors both verify a collection of 3-letter\n *  string keys (upper- or lowercase) to finite numbers:\n *\n * - `{keyExp: '[a-z]{3}', keyExpFlags: 'i', values: FINITE}`\n * - `{keyExp: '[a-zA-Z]{3}', values: FINITE}`\n *\n * @typedef {Object} rtvref.types.collection_descriptor\n * @property {rtvref.types.typeset} [keys] Optional. A typeset describing each key\n *  in the collection.\n *\n * The type of collection being described may restrict the types that this typeset\n *  can include. For example, the {@link rtvref.types.MAP_OBJECT MAP_OBJECT} collection\n *  only supports the {@link rtvref.types.STRING STRING} type due to the nature of\n *  its JavaScript `Object`-based implementation.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {string} [keyExp] Optional. A string-based regular expression\n *  describing the names of keys (own-enumerable properties) found in the\n *  collection.\n *\n * By default, there are no restrictions on key names. This expression is only\n *  used if the `keys` typeset includes the {@link rtvref.types.STRING STRING} type.\n *\n * For example, to require numerical keys, the following expression could be\n *  used: `'^\\\\d+$'`.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {string} [keyExpFlags] Optional. A string specifying any flags to use\n *  with the regular expression specified in `keyExp`. If this property is _falsy_,\n *  default `RegExp` flags will be used. Ignored if `keyExp` is not specified, or\n *  does not apply per the `keys` typeset.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {rtvref.types.typeset} [values] Optional. A typeset describing each value\n *  in the collection. Defaults to the {@link rtvref.types.ANY ANY} type which allows\n *  _anything_. All values must match this typeset (but the collection is not\n *  required to have any entries/properties to be considered valid, unless\n *  `count` is specified).\n *\n * For example, to require arrays of non-empty string values, the following\n *  typeset could be used: `[[types.STRING]]`.\n *\n * @property {number} [count=-1] Optional. The number of entries expected in\n *  the collection. A negative value allows for any number of entries. Zero\n *  requires an empty collection.\n *\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n * @see {@link rtvref.types.SET}\n * @see {@link rtvref.types.WEAK_SET}\n */\n\n/**\n * <h3>Typeset</h3>\n *\n * Describes the possible types for a given value. It can be any one of the following\n *  JavaScript types:\n *\n * - `Object`: For the root or a nested {@link rtvref.shape_descriptor shape descriptor}\n *   of _implied_ {@link rtvref.types.OBJECT OBJECT} type (unless paired with a specific\n *   object type like {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, for example, when\n *   using the `Array` notation, e.g. `[PLAIN_OBJECT, {...}]`). If the object is empty\n *   (has no properties), nothing will be verified (anything will pass).\n * - `String`: For a single type, such as {@link rtvref.types.FINITE FINITE}\n *   for a finite number. Must be one of the types defined in {@link rtvref.types}.\n * - `Function`: For a {@link rtvref.types.property_validator property validator}\n *   that will verify the value of the property using custom code. Since the Array\n *   form is not being used (only the validator is being provided), it's always\n *   invoked immediately. Since a type is not provided, the {@link rtvref.types.ANY ANY}\n *   type is implied.\n * - `Array`: For multiple type possibilities, optionally {@link rtvref.qualifiers qualified},\n *   using an __OR__ conjunction, which means the value of the property being described must\n *   match at _least one_ of the types listed, but not all. Matching is done in a short-circuit\n *   fashion, from the first to the last element in the typeset. If a simpler type is likely,\n *   it's more performant to specify it first/earlier in the typeset to avoid a match attempt\n *   on a nested shape or Array.\n *   - Cannot be an empty Array.\n *   - A given type may not be included more than once in the typeset, but may appear\n *     again in a nested typeset (when a parent typeset describes an\n *     {@link rtfref.types.ARRAY Array} or type of {@link rtfref.types.OBJECT Object}).\n *   - An Array is necessary to {@link rtvref.qualifiers qualify} the typeset as not\n *     required (see _Typeset Qualifiers_ below).\n *   - An Array is necessary if a type needs or requires\n *     {@link rtvref.types.type_arguments arguments}.\n *   - If the __first__ element (or second, if a {@link rtvref.types.qualifiers qualifier}\n *     is provided, but the typeset is not\n *     {@link rtvref.types.fully_qualified_typeset fully-qualified}), is an `Object`,\n *     it's treated as a nested {@link rtvref.shape_descriptor shape descriptor}\n *     describing an object of the default {@link rtvref.types.OBJECT OBJECT} type.\n *     To include a shape descriptor at any other position within the array, it\n *     __must__ be preceded by a type, even if the default `OBJECT` type is being\n *     used (i.e. `OBJECT` must be specified as the type).\n *   - If an element is an `Array` (any position), it's treated as a __nested list__\n *     with an implied {@link rtvref.types.ARRAY ARRAY} type, e.g.\n *     `[BOOLEAN, [STRING, FINITE]]` would describe a property that should be a boolean,\n *     or an array of non-empty strings or finite numbers. See the `ARRAY` type\n *     reference for more information on _shorthand_ and _full_ notations.\n *   - If an element is a `Function`, it must be the __last__ element in the Array\n *     and will be treated as a {@link rtvref.types.property_validator property validator}.\n *     Only one validator can be specified for a given typeset (additional validators\n *     may appear in nested typesets).\n *\n * <h4>Typeset Qualifiers</h4>\n *\n * All typesets use an _implied_ {@link rtvref.qualifiers.REQUIRED REQUIRED}\n *  qualifier unless otherwise specified. To qualify a typeset, a\n *  {@link rtvref.qualifiers qualifier} may be specified as the __first__ element\n *  in the `Array` form (if specified, it must be the first element). For example,\n *  `{note: [EXPECTED, STRING]}` would describe an object with a 'note' property\n *  that is an expected, but not required, string, which could therefore be either\n *  empty or even `null`. The `Array` form must be used in order to qualify a\n *  typeset as other than required, and the qualifier applies to all immediate\n *  types in the typeset (which means each nested typeset can have its own qualifier).\n *\n * <h4>Example: Object</h4>\n *\n * <pre><code>const contactShape = {\n *   name: rtv.t.STRING, // required, non-empty, string\n *   tags: [rtv.t.ARRAY, [rtv.t.STRING]], // required array of non-empty strings\n *   // tags: [[rtv.t.STRING]], // same as above, but using shortcut array format\n *   details: { // required nested object of type `OBJECT` (default)\n *     birthday: [rtv.q.EXPECTED, rtv.t.DATE] // Date (could be null)\n *   },\n *   notes: [rtv.q.OPTIONAL, rtv.t.STRING, function(value) { // optional string...\n *     return !value || value.length < 500; // ...less than 500 characters long, if specified\n *   }]\n * };\n *\n * const contact = {\n *   name: 'John Doe',\n *   tags: ['colleagues', 'sports'],\n *   details: {\n *     birthday: null // not specified\n *   }\n * };\n *\n * rtv.verify(contact, contactShape); // OK\n *\n * const walletShape = {\n *   contacts: [[contactShape]], // list of contacts using nested shape\n *   address: {\n *     street: rtv.t.STRING\n *     // ...\n *   },\n *   money: rtv.t.FINITE\n * };\n *\n * rtv.verify({\n *   contacts: [contact],\n *   address: {street: '123 Main St'},\n *   money: 100\n * }, walletShape); // OK\n * </code></pre>\n *\n * <h4>Example: String</h4>\n *\n * <pre><code>rtv.verify('foo', rtv.t.STRING); // OK\n * rtv.verify('foo', rtv.t.FINITE); // ERROR\n * </code></pre>\n *\n * <h4>Example: Array</h4>\n *\n * <pre><code>const typeset = [rtv.t.STRING, rtv.t.FINITE]; // non-empty string, or finite number\n * rtv.verify('foo', typeset); // OK\n * rtv.verify(1, typeset); // OK\n * </code></pre>\n *\n * <h4>Example: Function</h4>\n *\n * <pre><code>rtv.verify(123, (v) => v > 100); // OK\n * rtv.verify('123', [rtv.t.STRING, (v) => parseInt(v) > 100); // OK\n * </code></pre>\n *\n * <h4>Example: Alternate Qualifier</h4>\n *\n * <pre><code>const person = {\n *   name: rtv.t.STRING, // required, non-empty\n *   age: [rtv.q.OPTIONAL, rtv.t.FINITE, (v) => v >= 18] // 18 or older, if specified\n * };\n * rtv.verify({name: 'Bob'}, person); // OK\n * rtv.verify({name: ''}, person); // ERROR\n * rtv.verify({name: 'Steve', age: 17}, person); // ERROR\n * rtv.verify({name: 'Steve', age: null}, person); // OK\n * </code></pre>\n *\n * @typedef {(Object|string|Array|Function)} rtvref.types.typeset\n */\n\n/**\n * <h3>Fully-Qualified Typeset</h3>\n *\n * A {@link rtvref.types.typeset typeset} expressed without any shortcut notations\n *  or implied/default types to make it easier to parse, especially as the `match`\n *  parameter given to a {@link rtvref.types.property_validator property validator}.\n *  A fully-qualified typeset always uses the array notation, and has a single\n *  {@link rtvref.qualifiers qualifier} as its first element, followed by\n *  at least one type, and at most one validator.\n *\n * For example:\n *\n * - `STRING` -> `[REQUIRED, STRING]`\n * - `{note: STRING}` -> `[REQUIRED, OBJECT, {note: [REQUIRED, STRING]}]`\n * - `[[FINITE]]` -> `[REQUIRED, ARRAY, [REQUIRED, FINITE]]`\n * - `(v) => !!v` -> `[REQUIRED, ANY, (v) => !!v]`\n *\n * @typedef {Array} rtvref.types.fully_qualified_typeset\n */\n\n/**\n * <h3>Property Validator</h3>\n *\n * A function used as a {@link rtvref.types.typeset typeset}, or as a subset to\n *  a typeset, to provide custom verification of the value being verified.\n *\n * A typeset may only have one validator, and the validator is only called if\n *  the value being verified was verified by at least one type in the typeset.\n *  The validator must be the __last__ element within the typeset (if the typeset\n *  is an array, and a validator is needed). The validator must also be\n *  specified _after_ the {@link rtvref.qualifiers qualifier} in a typeset Array.\n *  The validator is invoked immediately after the first type match, but only if\n *  a type match is made. If the typeset is not\n *  {@link rtvref.types.fully_qualified_typeset fully-qualified} and does not\n *  explicitly specify a type, the {@link rtvref.types.ANY ANY} type is implied.\n *\n * There is one disadvantage to using a property validator: It cannot be de/serialized\n *  via JSON, which means it cannot be transmitted or persisted. One option would be\n *  to customize the de/serialization to JSON by serializing the validator to a\n *  special object with properties that would inform the deserialization process\n *  on how to reconstruct the validator dynamically.\n *\n * @typedef {function} rtvref.types.property_validator\n * @param {*} value The value being verified.\n * @param {Array} match A __first-level__, {@link rtvref.types.fully_qualified_typeset fully-qualified}\n *  typeset describing the type that matched. This means the first level of this\n *  subset of `typeset` (the 3rd parameter) is fully-qualified, but any nested\n *  {@link rtvref.shape_descriptor shape descriptors} or arrays will not be (they\n *  will remain references to the same shapes/arrays in `typeset`). For example,\n *  if the given typeset was `[PLAIN_OBJECT, {note: STRING}]`, this parameter\n *  would be a new typeset array `[REQUIRED, PLAIN_OBJECT, {note: STRING}]`,\n *  and the `typeset` parameter would be the original `[PLAIN_OBJECT, {note: STRING}]`.\n * @param {rtvref.types.typeset} typeset Reference to the typeset used for\n *  verification. Note that the typeset may contain nested typeset(s), and may\n *  be part of a larger parent typeset (though there would be no reference to\n *  the parent typeset, if any). This typeset is as it was specified in the\n *  parent shape, and therefore it may not be fully-qualified.\n * @returns {boolean} `true` to verify the value, `false` to reject it.\n */\n\n// Creates a definition object.\n// @param {string} value Type value. Must not be empty.\n// @param {boolean} [hasArgs=false] If the type takes arguments.\n// @param {boolean} [isObject=false] If the type is an object type.\n// @returns {{value: boolean, hasArgs: boolean, isObject: boolean}} Type definition.\nconst def = function(value, hasArgs, isObject) {\n  return {\n    value,\n    hasArgs: !!hasArgs,\n    isObject: !!isObject\n  };\n};\n\n// map of type key (string) to type definition (see def() for shape)\nconst defs = {\n  /**\n   * The any type is special in that it allows _anything_, which includes `null`\n   *  and `undefined` values. Because of this, it's the most liberal in terms of\n   *  types as well as qualifiers. A more specific type should be used whenever\n   *  possible to ensure a higher degree of confidence in the value being validated.\n   *\n   * Any rules per qualifiers:\n   *\n   * - REQUIRED: Property must be defined _somewhere_ in the prototype chain, but\n   *   its value can be anything, including `null` and `undefined`.\n   * - EXPECTED: Same rules as REQUIRED.\n   * - OPTIONAL: Since this qualifier removes the property's need for existence\n   *   in the prototype chain, it renders the verification moot (i.e. the property\n   *   might as well not be included in the {@link rtvref.shape_descriptor shape descriptor}\n   *   unless a {@link rtvref.types.property_validator property validator} is being\n   *   used to do customized verification.\n   *\n   * @name rtvref.types.ANY\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  ANY: def('any'),\n\n  // TODO[future]: Add 'exp: string' and 'expFlags: string' args (strings because of JSON requirement...)\n  //  for a regular expression test. Similar prop names to collection_descriptor.\n  /**\n   * {@link rtvref.types.STRING STRING} arguments.\n   * @typedef {Object} rtvref.types.STRING_args\n   * @property {string} [exact] An exact value to match.\n   * @property {number} [min] Minimum length. Defaults to 1 for a `REQUIRED` string,\n   *  and 0 for an `EXPECTED` or `OPTIONAL` string. Ignored if `exact` is specified.\n   * @property {number} [max=-1] Maximum length. -1 means no maximum. Ignored if `exact`\n   *  is specified.\n   * @property {string} [partial] A partial value to match (must be somewhere within the string).\n   *  Ignored if `exact` is specified.\n   * @see {@link rtvref.qualifiers}\n   */\n\n  /**\n   * String rules per qualifiers:\n   *\n   * - REQUIRED: Must be a non-empty string.\n   * - EXPECTED | OPTIONAL: Can be an empty string.\n   *\n   * In all cases, the value must be a string {@link rtvref.types.primitives primitive}.\n   *  `new String('hello') !== 'hello'` because the former is an _object_, not a string.\n   *\n   * Arguments (optional): {@link rtvref.types.STRING_args}\n   *\n   * @name rtvref.types.STRING\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  STRING: def('string', true),\n\n  /**\n   * Boolean rules per qualifiers: Must be a boolean {@link rtvref.types.primitives primitive}.\n   *  `new Boolean(true) !== true` because the former is an _object_, not a boolean.\n   *\n   * @name rtvref.types.BOOLEAN\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  BOOLEAN: def('boolean'),\n\n  /**\n   * Symbol rules per qualifiers: Must be a symbol {@link rtvref.types.primitives primitive}.\n   * @name rtvref.types.SYMBOL\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  SYMBOL: def('symbol'),\n\n  /**\n   * Numeric value arguments. Applies to all numeric types.\n   * @typedef {Object} rtvref.types.numeric_args\n   * @property {string} [exact] An exact value to match.\n   * @property {number} [min] Minimum inclusive value. Default varies per type.\n   *  Ignored if `exact` is specified.\n   * @property {number} [max] Maximum inclusive value. Default varies per type.\n   *  Ignored if `exact` is specified.\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.FLOAT}\n   */\n\n  /**\n   * Number rules per qualifiers:\n   *\n   * - REQUIRED: Cannot be `NaN`, but could be `+Infinity`, `-Infinity`.\n   * - EXPECTED | OPTIONAL: Could be `NaN`, `+Infinity`, `-Infinity`.\n   *\n   * In all cases, the value must be a number {@link rtvref.types.primitives primitive}.\n   *  `new Number(1) !== 1` because the former is an _object_, not a number.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.NUMBER\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.FINITE}\n   */\n  NUMBER: def('number', true),\n\n  /**\n   * Finite rules per qualifiers: Cannot be `NaN`, `+Infinity`, `-Infinity`. The\n   *  value can be either a safe integer or a {@link rtvref.types.FLOAT floating point number}.\n   *  It must also be a number {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.FINITE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n   */\n  FINITE: def('finite', true),\n\n  /**\n   * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} integer,\n   *  but is not necessarily _safe_. It must also be a number {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.INT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.FLOAT}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n   */\n  INT: def('int', true),\n\n  /**\n   * Float rules per qualifiers: Must be a finite floating point number.\n   *  It must also be a number {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.FLOAT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.INT}\n   */\n  FLOAT: def('float', true),\n\n  /**\n   * Function rules per qualifiers: Must be a `function`.\n   * @name rtvref.types.FUNCTION\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  FUNCTION: def('function'),\n\n  /**\n   * RegExp rules per qualifiers: Must be a `RegExp` instance.\n   * @name rtvref.types.REGEXP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n   */\n  REGEXP: def('regexp'),\n\n  /**\n   * Date rules per qualifiers: Must be a `Date` instance.\n   * @name rtvref.types.DATE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n   */\n  DATE: def('date'),\n\n  /**\n   * Error rules per qualifiers: Must be an `Error` instance.\n   * @name rtvref.types.ERROR\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n   */\n  ERROR: def('error'),\n\n  /**\n   * Promise rules per qualifiers: Must be a `Promise` instance.\n   * @name rtvref.types.PROMISE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n   */\n  PROMISE: def('promise'),\n\n  // TODO[future]: Short-hand 'exact' with `[ARRAY, 2, [STRING]]` or `[2, [STRING]]` syntax?\n  /**\n   * {@link rtvref.types.ARRAY ARRAY} arguments.\n   * @typedef {Object} rtvref.types.ARRAY_args\n   * @property {number} [exact] Exact length.\n   * @property {number} [min=0] Minimum length. Ignored if `exact` is specified.\n   * @property {number} [max=-1] Maximum length. -1 means no maximum. Ignored if\n   *  `exact` is specified.\n   */\n\n  /**\n   * Array rules per qualifiers: Must be an `Array`. Empty arrays are permitted by\n   *  default.\n   *\n   * Arguments (optional): {@link rtvref.types.ARRAY_args}. Note that the `ARRAY`\n   *  type must be specified when using arguments (i.e. the shorthand notation\n   *  cannot be used).\n   *\n   * When describing arrays, either _shorthand_ or _full_ notation may be used.\n   *  In the shorthand notation, the `ARRAY` type isn't necessary, but\n   *  {@link rtvref.types.ARRAY_args arguments} can't be specified. In the full\n   *  notation, the `ARRAY` type is required, but arguments can optionally be\n   *  specified.\n   *\n   * <h4>Example: Shorthand notation</h4>\n   *\n   * The 'value' property must be an array (possibly empty) of finite numbers of\n   *  any value.\n   *\n   * <pre><code>{\n   *   value: [[FINITE]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Shorthand, mixed types</h4>\n   *\n   * The 'value' property must be either a boolean, or an array (possibly empty) of\n   *  finite numbers of any value.\n   *\n   * <pre><code>{\n   *   value: [BOOLEAN, [FINITE]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Full notation</h4>\n   *\n   * The 'value' property must be an array (possibly empty) of finite numbers of\n   *  any value.\n   *\n   * <pre><code>{\n   *   value: [ARRAY, [FINITE]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Full, mixed types, arguments</h4>\n   *\n   * The 'value' property must be either a boolean, or a non-empty array of finite\n   *  numbers of any value.\n   *\n   * <pre><code>{\n   *   value: [BOOLEAN, ARRAY, {min: 1}, [FINITE]]\n   * }\n   * </code></pre>\n   *\n   * @name rtvref.types.ARRAY\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  ARRAY: def('array', true),\n\n  /**\n   * An _any_ object is anything that is __not__ a {@link rtvref.types primitive}, which\n   *  means it includes the `Array` type, as well as functions and arguments, and\n   *  other JavaScript _object_ types. To test for an array, use the\n   *  {@link rtvref.types.ARRAY ARRAY} type. To test for a function, use the\n   *  {@link rtvref.types.FUNCTION FUNCTION} type.\n   *\n   * The following values are considered any objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new function() {}` (class instance) (also see {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT})\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   *\n   * {@link rtvref.types.primitives Primitive} values __are not__ considered any objects,\n   *  especially when the qualifier is {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n   *  Note that `typeof null === 'object'` in JavaScript; the `ANY_OBJECT` type\n   *  allows testing for this undesirable fact.\n   *\n   * Any object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.ANY_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  ANY_OBJECT: def('anyObject', true, true),\n\n  /**\n   * An object is one that extends from `JavaScript.Object` (i.e. an _instance_\n   *  of _something_ that extends from Object) and is not a\n   *  {@link rtvref.types.FUNCTION function}, {@link rtvref.types.ARRAY array},\n   *  {@link rtvref.types.REGEXP regular expression}, function arguments object,\n   *  {@link rtvref.types.MAP map}, {@link rtvref.types.WEAK_MAP weak map},\n   *  {@link rtvref.types.SET set}, {@link rtvref.types.WEAK_SET weak set}, nor a\n   *  {@link rtvref.types primitive}.\n   *\n   * This is the __default__ (imputed) type for\n   *  {@link rtvref.shape_descriptor shape descriptors}, which means the object itself\n   *  (the value being tested), prior to being checked against its shape, will be\n   *  tested according to this type.\n   *\n   * The following values are considered objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `new function() {}` (class instance)\n   *\n   * The following values __are not__ considered objects:\n   *\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  OBJECT: def('object', true, true),\n\n  /**\n   * A _plain_ object is one that is created directly from the `Object` constructor,\n   *  whether using `new Object()` or the literal `{}`.\n   *\n   * The following values are considered plain objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   *\n   * The following values __are not__ considered plain objects:\n   *\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `new function() {}` (class instance)\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Plain object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.PLAIN_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  PLAIN_OBJECT: def('plainObject', true, true),\n\n  /**\n   * {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} arguments.\n   * @typedef {Object} rtvref.types.CLASS_OBJECT_args\n   * @property {function} [ctr] A reference to a constructor function. If specified,\n   *  the class object (instance) must have this class function in its inheritance\n   *  chain such that `<class_object> instanceof <function> === true`. Note that\n   *  this property is not serializable to JSON. If not specified, then the object\n   *  must be an {@link rtvref.types.OBJECT OBJECT} that is not a\n   *  {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT} among the other values that\n   *  are not considered class objects.\n   * @property {rtvref.shape_descriptor} [shape] A description of the class object's\n   *  shape.\n   */\n\n  /**\n   * A _class_ object is one that is created by invoking the `new` operator on a\n   *  function (other than a primitive type function), generating a new object,\n   *  commonly referred to as a _class instance_. This object's prototype\n   *  (`__proto__`) is a reference to that function's `prototype` and has a\n   *  `constructor` property that is `===` to the function.\n   *\n   * The following values are considered class objects:\n   *\n   * - `new function() {}`\n   *\n   * The following values __are not__ considered class objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Class object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.types.CLASS_OBJECT_args}\n   *\n   * @name rtvref.types.CLASS_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   */\n  CLASS_OBJECT: def('classObject', true, true),\n\n  /**\n   * A _map_ object is an {@link rtvref.types.OBJECT OBJECT} that is treated as a\n   *  hash map with an expected set of keys and values. Keys can be described\n   *  using a regular expression, and values can be described using a\n   *  {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n   *\n   * Map object rules per qualifiers: Same as {@link rtvref.types.OBJECT OBJECT} rules.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_descriptor}\n   *\n   * @name rtvref.types.MAP_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP}\n   * @see {@link rtvref.types.WEAK_MAP}\n   */\n  MAP_OBJECT: def('mapObject', true, true),\n\n  /**\n   * JSON rules per qualifiers: Must be a JSON value:\n   *\n   * - {@link rtvref.types.STRING string}, however __empty strings are permitted__,\n   *   even if the qualifier is `REQUIRED`;\n   * - {@link rtvref.types.BOOLEAN boolean};\n   * - {@link rtvref.types.FINITE finite number};\n   * - {@link rtvref.types.PLAIN_OBJECT plain object};\n   * - {@link rtvref.types.ARRAY array};\n   * - `null`\n   *\n   * Since this type checks for _any_ valid JSON value, empty string and `null`\n   *  values are permitted, even when the typeset is qualified as `REQUIRED`.\n   *  Therefore, the `REQUIRED` qualifier has the same effect as the `EXPECTED`\n   *  qualifier.\n   *\n   * @name rtvref.types.JSON\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  JSON: def('json'),\n\n  /**\n   * An ES6 map supports any object as its keys, unlike a\n   *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n   *  be described using a regular expression (if they are strings), and values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted\n   *  by default.\n   *\n   * Map rules per qualifiers: Must be a `Map` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_descriptor}\n   *\n   * @name rtvref.types.MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   * @see {@link rtvref.types.WEAK_MAP}\n   */\n  MAP: def('map', true),\n\n  /**\n   * An ES6 weak map supports any object as its keys, unlike a\n   *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n   *  be described using a regular expression (if they are strings), and values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted\n   *  by default.\n   *\n   * Weak map rules per qualifiers: Must be a `WeakMap` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_descriptor}\n   *\n   * @name rtvref.types.WEAK_MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.MAP_OBJECT}\n   * @see {@link rtvref.types.MAP}\n   */\n  WEAK_MAP: def('weakMap', true),\n\n  /**\n   * An ES6 set is a collection of _unique_ values without associated keys. Values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted\n   *  by default.\n   *\n   * Set rules per qualifiers: Must be a `Set` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_descriptor}\n   *\n   * @name rtvref.types.SET\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.WEAK_SET}\n   */\n  SET: def('set', true),\n\n  /**\n   * An ES6 weak set is a collection of _unique_ values without associated keys. Values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted\n   *  by default.\n   *\n   * Weak set rules per qualifiers: Must be a `WeakSet` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_descriptor}\n   *\n   * @name rtvref.types.WEAK_SET\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.SET}\n   */\n  WEAK_SET: def('weakSet', true)\n};\n\n//\n// ^^^^^^^ INSERT NEW TYPES ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Default object type: {@link rtvref.types.OBJECT}\n * @const {string} rtvref.types.DEFAULT_OBJECT_TYPE\n */\nexport const DEFAULT_OBJECT_TYPE = defs.OBJECT.value;\n\n/**\n * Enumeration (`string -> string`) of __object__ {@link rtvref.types types}. These\n *  are all the types that describe values which are essentially maps of various\n *  keys to values.\n * @name rtvref.types.objTypes\n * @type {rtvref.Enumeration}\n */\nexport const objTypes = new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    if (defs[name].isObject) {\n      types[name] = defs[name].value;\n    }\n  });\n  return types;\n}());\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.types types} that accept\n *  arguments.\n * @name rtvref.types.argTypes\n * @type {rtvref.Enumeration}\n */\nexport const argTypes = new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    if (defs[name].hasArgs) {\n      types[name] = defs[name].value;\n    }\n  });\n  return types;\n}());\n\n/**\n * Enumeration (`string -> string`) of all {@link rtvref.types types}.\n * @name rtvref.types.types\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    types[name] = defs[name].value;\n  });\n  return types;\n}());\n","//// Qualifier Definitions \\\\\\\\\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Qualifiers</h2>\n * @namespace rtvref.qualifiers\n */\n\n/**\n * Required qualifier: Property _must_ exist and be of the expected type.\n *  Depending on the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, and does not\n *  allow its value to be `null` or `undefined`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.REQUIRED\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst REQUIRED = '!';\n\n/**\n * Expected qualifier: Property _should_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, does not allow\n *  its value to be `undefined`, but does _allow_ its value to be `null`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.EXPECTED\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst EXPECTED = '+';\n\n/**\n * Optional qualifier: Property _may_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced (i.e. less so\n *  than with the `EXPECTED` qualifier).\n *\n * Unless otherwise stated in type-specific rules, this qualifier _allows_ a\n *  property value to be `null` as well as `undefined`, and does _not_ require\n *  the property to be defined anywhere in the prototype chain. If the property\n *  is defined, then it is treated as an `EXPECTED` value.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.OPTIONAL\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst OPTIONAL = '?';\n\n//\n// ^^^^^^^ INSERT NEW TYPES ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Default qualifier: {@link rtvref.qualifiers.REQUIRED}\n * @const {string} rtvref.qualifiers.DEFAULT_QUALIFIER\n */\nexport const DEFAULT_QUALIFIER = REQUIRED;\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.qualifiers qualifiers}.\n * @name rtvref.qualifiers.qualifiers\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration({\n  REQUIRED,\n  EXPECTED,\n  OPTIONAL\n});\n","//// Validation Module \\\\\\\\\n\nimport {default as _isArray} from 'lodash/isArray';\nimport {default as _isSymbol} from 'lodash/isSymbol';\nimport {default as _isFunction} from 'lodash/isFunction';\nimport {default as _isObject} from 'lodash/isObject';\nimport {default as _isObjectLike} from 'lodash/isObjectLike';\nimport {default as _isMap} from 'lodash/isMap';\nimport {default as _isWeakMap} from 'lodash/isWeakMap';\nimport {default as _isSet} from 'lodash/isSet';\nimport {default as _isWeakSet} from 'lodash/isWeakSet';\nimport {default as _isRegExp} from 'lodash/isRegExp';\nimport {default as _forEach} from 'lodash/forEach';\n\nimport {default as types, argTypes, objTypes, DEFAULT_OBJECT_TYPE} from './types';\nimport qualifiers from './qualifiers';\n\n/**\n * RTV Validation Module\n *\n * @namespace rtv.validation\n */\n\n/**\n * Determines if a value is _anything_.\n * @function rtv.validation.isAny\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.ANY}\n */\nexport const isAny = function(v) {\n  return true; // anything goes, even undefined and null\n};\n\n/**\n * Determines if a value is a string literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new String('value')`, which is an object that is a string.\n * @function rtv.validation.isString\n * @param {*} v Value to validate.\n * @param {Object} [options] Validation options.\n * @param {boolean} [options.emptyOk=false] If truthy, an empty string is allowed.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.STRING}\n */\nexport const isString = function(v, {emptyOk} = {}) {\n  return !!((typeof v === 'string') && (emptyOk || v));\n};\n\n/**\n * Determines if a value is a boolean literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Boolean(true)`, which is an object that is a boolean.\n * @function rtv.validation.isBoolean\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.BOOLEAN}\n */\nexport const isBoolean = function(v) {\n  return (v === true || v === false);\n};\n\n/**\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n * @function rtv.validation.isNumber\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.NUMBER}\n */\nexport const isNumber = function(v) {\n  return (typeof v === 'number');\n};\n\n/**\n * Determines if a value is a symbol.\n * @function rtv.validation.isSymbol\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.SYMBOL}\n */\nexport const isSymbol = _isSymbol;\n\n/**\n * Determines if a value is a function.\n * @function rtv.validation.isFunction\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.SYMBOL}\n */\nexport const isFunction = _isFunction;\n\n/**\n * Determines if a value is an array.\n * @function rtv.validation.isArray\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.ARRAY}\n */\nexport const isArray = _isArray;\n\n/**\n * Determines if a value is a map.\n * @function rtv.validation.isMap\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.MAP}\n */\nexport const isMap = _isMap;\n\n/**\n * Determines if a value is a weak map.\n * @function rtv.validation.isWeakMap\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const isWeakMap = _isWeakMap;\n\n/**\n * Determines if a value is a set.\n * @function rtv.validation.isSet\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.SET}\n */\nexport const isSet = _isSet;\n\n/**\n * Determines if a value is a weak set.\n * @function rtv.validation.isWeakSet\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.WEAK_SET}\n */\nexport const isWeakSet = _isWeakSet;\n\n/**\n * Determines if a value is a regular expression object.\n * @function rtv.validation.isRegExp\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.REGEXP}\n */\nexport const isRegExp = _isRegExp;\n\n/**\n * Determines if a value is a JavaScript {@link rtvref.types.primitives primitive}.\n * @function rtv.validation.isPrimitive\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport const isPrimitive = function(v) {\n  return v === undefined ||\n      v === null ||\n      isString(v, {emptyOk: true}) || // empty strings are still strings in this case\n      isBoolean(v) ||\n      isNumber(v) ||\n      isSymbol(v);\n};\n\n/**\n * Determines if a value is _any_ type of object except a primitive.\n * @function rtv.validation.isAnyObject\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport const isAnyObject = _isObject;\n\n/**\n * Determines if a value is an object that extends from `JavaScript.Object` and\n *  is not a function, array, regex, map, weak map, set, weak set, or primitive.\n * @function rtv.validation.isObject\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport const isObject = function(v) {\n  return _isObjectLike(v) && // excludes primitives and functions\n      !isArray(v) && // excludes arrays which are otherwise object-like (typeof [] === 'object')\n      !isMap(v) && !isWeakMap(v) && // excludes weak/maps\n      !isSet(v) && !isWeakSet(v) && // excludes weak/sets\n      !isRegExp(v); // excludes regex\n};\n\n/**\n * Determines if a value is a typeset.\n * @function rtv.validation.isValidTypeset\n * @param {*} v Value to validate.\n * @param {Object} [options] Validation options.\n * @param {boolean} [options.deep=false] If truthy, deeply-validates any nested typesets. Note\n *  that typesets in nested shapes are also deeply-validated.\n * @param {boolean} [options.fullyQualified=false] If truthy, the typeset must be fully-qualified.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.typeset}\n */\nexport const isTypeset = function(v, {deep = false, fullyQualified = false} = {}) {\n  let valid = !!(isObject(v) || (isString(v) && types.check(v)) || isFunction(v) ||\n      (isArray(v) && v.length > 0));\n\n  // FIRST: check if needs to be fully-qualified, and check deep within if requested\n  if (valid && fullyQualified) {\n    // must now be an array with at least 2 elements: [qualifier, type]\n    if (isArray(v) && v.length >= 2) {\n      const usedTypes = {}; // @type {Object.<string,boolean>} map of simple type to `true`\n      let curType; // @type {string} current in-scope type\n      let argType; // @type {(string|undefined)} current in-scope type IIF it accepts args\n\n      // Updates the current in-scope type (curType) and marks it as used in usedTypes.\n      //  If the type has already been used, it sets valid to false.\n      // @param {string} type New in-scope type.\n      const updateCurType = function(type) {\n        // set the rule as the current in-scope type\n        curType = type;\n\n        if (usedTypes[curType]) {\n          // a type cannot appear more than once in a typeset (but nested is OK)\n          valid = false;\n        }\n        usedTypes[curType] = true;\n      };\n\n      // iterate through each element in the typeset array to make sure all required\n      //  rules/properties of a fully-qualified typeset are specified\n      _forEach(v, function(rule, i) {\n        if (i === 0) {\n          // first position must always be the qualifier\n          // more efficient to check for a string first than to always iterate\n          //  all qualifiers (or all types, below) when it isn't since we know\n          //  they're always strings\n          valid = isString(rule) && !!qualifiers.check(rule);\n        } else if (isString(rule)) {\n          // additional qualifier, or simple type\n          if (qualifiers.check(rule)) {\n            // cannot have more than one qualifier and qualifier must be in first position\n            //  (and this is not the first position because that's handled specially, above)\n            valid = false;\n          } else if (!types.check(rule)) {\n            // if not a qualifier, it must be a valid type (since it's a string)\n            valid = false;\n          } else {\n            // set the rule as the current in-scope type\n            updateCurType(rule);\n\n            // update the in-scope arg type: reset to undefined if it doesn't take\n            //  args; otherwise, update it (NOTE: currently, there are no types that\n            //  _require_ args, only ones that optionally have args, so we don't\n            //  have to ensure that args were given when we change the type)\n            argType = argTypes.check(rule);\n          }\n        } else if (isFunction(rule)) {\n          // must be a validator, but there can't be more than 1, it must be\n          //  in the last position (and always after the qualifier), and since\n          //  the typeset must be FQ'd, we must have an in-scope type\n          valid = !!(curType && (i + 1 === v.length));\n        } else if (isObject(rule)) {\n          // could be a shape, or type args (either way, it's a single object)\n          // since the typeset must be fully-qualified, argType must already be\n          //  a type that takes arguments, since arguments are always provided\n          //  via objects (NOTE: for object types, the args are the shapes themselves,\n          //  except for CLASS_OBJECT where the shape is specified within the args;\n          //  still, there is always only ever at most one object per type that\n          //  accepts args, never more)\n          if (argType) {\n            // consume the object as the in-scope arg type's arguments\n            argType = undefined;\n          } else {\n            // since the typeset must be fully-qualified and we don't already\n            //  have an in-scope arg type, the typeset is invalid\n            valid = false;\n          }\n\n          // only go deep if the object is a shape, which means the current in-scope\n          //  type must be an object type\n          if (valid && deep && objTypes.check(curType)) {\n            // if it's a class object, the shape is an optional sub-property of the object;\n            //  if it's a map object, there is no shape; otherwise, it's the object itself\n            const shape = (curType === types.CLASS_OBJECT) ? rule.shape :\n              ((curType === types.MAP_OBJECT) ? undefined : rule);\n\n            // validate all of the shape's typesets (each own-prop should be a typeset)\n            shape && _forEach(shape, function(ts, prop) {\n              valid = isTypeset(ts, {deep, fullyQualified}); // recursive\n              return valid; // break on first invalid\n            });\n          }\n        } else if (isArray(rule)) {\n          // nested typeset for an array type: in-scope type must be ARRAY\n          if (argType === types.ARRAY) {\n            // go deep if requested; otherwise, assume it's valid\n            valid = !deep || isTypeset(rule, {deep, fullyQualified});\n          } else {\n            valid = false;\n          }\n        } else {\n          // any other type in an array typeset is not supported\n          valid = false;\n        }\n\n        return valid; // break if no longer valid\n      });\n\n      // make sure at least one type was specified\n      valid = valid && !!curType;\n    } else {\n      // automatically invalid if not an array because a typeset must be in the\n      //  array form in order to be FQ'd\n      valid = false;\n    }\n\n  // NEXT: if it's an array, valid, and does not need to be FQ'd, check its\n  //  definition, and deep (if requested)\n  } else if (valid && !fullyQualified && isArray(v)) {\n    const usedTypes = {}; // @type {Object.<string,boolean>} map of simple type to `true`\n    let curType; // @type {string} current in-scope type\n    let argType; // @type {(string|undefined)} current in-scope type IIF it accepts args\n    let hasQualifier = false; // true if a qualifier is specified (not implied)\n\n    // Updates the current in-scope type (curType) and marks it as used in usedTypes.\n    //  If the type has already been used, it sets valid to false.\n    // @param {string} type New in-scope type.\n    const updateCurType = function(type) {\n      // set the rule as the current in-scope type\n      curType = type;\n\n      if (usedTypes[curType]) {\n        // a type cannot appear more than once in a typeset (but nested is OK)\n        valid = false;\n      }\n      usedTypes[curType] = true;\n    };\n\n    // iterate through each element in the typeset array to make sure all required\n    //  rules/properties of a typeset are specified\n    _forEach(v, function(rule, i) {\n      if (isString(rule)) {\n        if (qualifiers.check(rule)) {\n          hasQualifier = true;\n          valid = (i === 0); // must be in the first position\n        } else if (types.check(rule)) {\n          // set the rule as the current in-scope type\n          updateCurType(rule);\n          // update current in-scope arg type IIF it accepts args\n          // NOTE: currently, there are no types that _require_ args, only ones\n          //  that optionally have args, so we don't have to ensure that args\n          //  were given when we change the type\n          argType = argTypes.check(rule);\n        } else {\n          // some unknown/invalid qualifier or type\n          valid = false;\n        }\n      } else if (isFunction(rule)) {\n        // must be a validator, but there can't be more than 1, and it must be\n        //  in the last position (and always after the qualifier, if any)\n        valid = (i + 1 === v.length);\n        if (valid && !curType) {\n          // if we have a validator but no in-scope type, ANY is implied\n          updateCurType(types.ANY);\n        }\n      } else if (isObject(rule)) {\n        // could be a shape, or type args (either way, it's just one object)\n        // NOTE: for object types, the args are the shapes themselves, except\n        //  for CLASS_OBJECT where the shape is specified within the args; still,\n        //  there is always only ever at most one object per type that accepts\n        //  args, never more\n        if (!argType) {\n          // since there's no in-scope arg type, the object must be a shape using\n          //  the default OBJECT type, but it must be in the first position (or\n          //  second if the first element was a qualifier)\n          updateCurType(DEFAULT_OBJECT_TYPE);\n          valid = valid && (i === 0 || (hasQualifier && i === 1));\n          // NOTE: do not set argType because the shape is the default object type's\n          //  args, so they should be consumed by the in-scope arg type\n        } else {\n          // consume the object as the in-scope arg type's arguments\n          // NOTE: currently, there are no types that _require_ args, only ones\n          //  that optionally have args, so we don't have to ensure that args\n          //  were given when we change the type\n          argType = undefined;\n        }\n\n        // only go deep if the object is a shape, which means the current in-scope\n        //  type must be an object type\n        if (valid && deep && objTypes.check(curType)) {\n          // if it's a class object, the shape is an optional sub-property of the object;\n          //  if it's a map object, there is no shape; otherwise, it's the object itself\n          const shape = (curType === types.CLASS_OBJECT) ? rule.shape :\n            ((curType === types.MAP_OBJECT) ? undefined : rule);\n\n          // validate all of the shape's typesets (each own-prop should be a typeset)\n          shape && _forEach(shape, function(ts, prop) {\n            valid = isTypeset(ts, {deep, fullyQualified}); // recursive\n            return valid; // break on first invalid\n          });\n        }\n      } else if (isArray(rule)) {\n        // if the current in-scope type is not ARRAY, set it since a nested array\n        //  implies the ARRAY type\n        if (curType !== types.ARRAY) {\n          updateCurType(types.ARRAY);\n          // in this case, the in-scope arg type should be updated to ARRAY since\n          //  arrays accept optional args, but since the current in-scope type\n          //  was not set, this must be a short-hand ARRAY notation, which means\n          //  args cannot be specified, therefore we update argType to undefined\n          //  to clear it from the previous type (if it was set) and clear it\n          //  from this type as well\n          argType = undefined;\n        }\n\n        if (valid && deep) {\n          valid = isTypeset(rule, {deep, fullyQualified}); // recursive\n        }\n      } else {\n        // any other type in an array typeset is not supported\n        valid = false;\n      }\n\n      return valid; // break if no longer valid\n    });\n\n    // make sure at least one type was specified\n    valid = valid && !!curType;\n\n  // NEXT: if it's a shape descriptor, check if deep is requested as long as it's\n  //  valid and does not need to be FQ'd (otherwise, 'v' must be an array and\n  //  would be invalid as a FQ'd typeset)\n  } else if (valid && deep && !fullyQualified && isObject(v)) {\n    // we need to deep-validate a shape descriptor, which means each one of its\n    //  own-properties must be a valid typeset\n    const props = Object.keys(v);\n    _forEach(props, function(prop) {\n      valid = isTypeset(v[prop], {deep, fullyQualified}); // recursive\n      return valid; // break if no longer valid\n    });\n  }\n  // else, must be invalid, or valid but non-array and doesn't need to be FQ'd\n  //  (and we can't go deep because it isn't an array)\n\n  return valid;\n};\n","//// Utilities \\\\\\\\\n\n// NOTE: Ideally, this module has no dependencies.\n\n/**\n * RTV Utilities Module\n * @private\n * @namespace rtv.util\n */\n\n/**\n * Pretty-print a value.\n * @function rtv.util.print\n * @param {*} value Value to print.\n * @returns {string} Pretty-printed value. It's not perfect and may not catch\n *  all types, but attempts to be good enough.\n */\nexport const print = function(value) {\n  const replacer = function replacer(key, val) {\n    if (typeof val === 'function') {\n      return '<function>';\n    } else if (typeof val === 'symbol') {\n      return `<<${val.toString()}>>`;\n    } else if (val === null || val === undefined) {\n      return val + '';\n    }\n\n    return val;\n  };\n\n  // do an initial pass to see if we have a string\n  const result = replacer(undefined, value);\n\n  // if it's just a string, return it\n  if (typeof result === 'string') {\n    return result;\n  }\n\n  // otherwise, stringify it\n  return JSON.stringify(value, replacer);\n};\n","//// RtvSuccess Class \\\\\\\\\n\n/**\n * Runtime Verification Success Indicator\n *\n * Describes a successful runtime verification of a value against a given\n *  {@link rtvref.shape_descriptor shape} or {@link rtvref.types.typeset typeset}\n *  (note that a shape is a type of typeset).\n *\n * @class rtvref.RtvSuccess\n */\nexport default class RtvSuccess {\n  // JSDoc is provided at the @class level\n  constructor() {\n    Object.defineProperties(this, {\n      /**\n       * Flag indicating the validation succeeded. Always `true`.\n       * @readonly\n       * @name rtvref.RtvSuccess#valid\n       * @type {boolean}\n       */\n      valid: {\n        enumerable: true,\n        configurable: true,\n        value: true\n      }\n    });\n  }\n\n  /**\n   * A string representation of this instance.\n   * @method rtvref.RtvSuccess#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    return '{rtvref.RtvSuccess}';\n  }\n}\n","//// Main Implementation Module \\\\\\\\\n\nimport {isString, isBoolean, isArray, isFunction, isObject, isTypeset} from './validation';\nimport {DEFAULT_OBJECT_TYPE, default as types} from './types';\nimport {DEFAULT_QUALIFIER, default as qualifiers} from './qualifiers';\nimport {print} from './util';\nimport RtvSuccess from './RtvSuccess';\n\n/**\n * RTV Implementation Module\n * @private\n * @namespace rtv.impl\n */\n\n/**\n * Fully-qualifies a typeset, shallow (i.e. the first level only; nested typesets\n *  are not fully-qualified).\n *\n * This function does not modify the input `typeset`.\n *\n * @function rtv.impl.fullyQualify\n * @param {rtvref.types.typeset} typeset Typeset to fully-qualify.\n * @returns {rtvref.types.fully_qualified_typeset} A new, fully-qualified typeset\n *  representing the input `typeset`. Only the first/immediate level of the\n *  input typeset is fully-qualified. The new array returned contains references\n *  to elements within the input typeset.\n * @throws {Error} If `typeset` is not a valid typeset.\n */\nexport const fullyQualify = function(typeset) {\n  if (!isTypeset(typeset)) { // start by validating so we can be confident later\n    throw new Error(`Invalid typeset='${print(typeset)}'`);\n  }\n\n  // NOTE: from this point on, we ASSUME that the typeset is valid, which lets\n  //  us make assumptions about what we find within it; without this knowledge,\n  //  the algorithm below would not work\n\n  if (!isArray(typeset)) {\n    // must be either a string, object, or function with an implied qualifier\n    if (isObject(typeset)) {\n      // must be a nested shape descriptor with default object type\n      return [DEFAULT_QUALIFIER, DEFAULT_OBJECT_TYPE, typeset];\n    }\n\n    // if a function, it has an implied type of ANY\n    if (isFunction(typeset)) {\n      return [DEFAULT_QUALIFIER, types.ANY, typeset];\n    }\n\n    // string (basic type)\n    return [DEFAULT_QUALIFIER, typeset];\n  }\n\n  const fqts = []; // ALWAYS a new array\n  let curType; // @type {(string|undefined)} current type in scope or undefined if none\n\n  // typeset is an array: iterate its elements and build fqts iteratively\n  typeset.forEach(function(rule, i) {\n    if (i === 0 && (!isString(rule) || !qualifiers.check(rule))) { // qualifiers are non-empty strs\n      fqts.push(DEFAULT_QUALIFIER); // add implied qualifier\n    }\n\n    if (isString(rule)) {\n      // must be a type\n      curType = rule;\n      fqts.push(curType);\n    } else if (isObject(rule)) {\n      if (i === 0) {\n        // must be a nested shape descriptor using default object type\n        curType = DEFAULT_OBJECT_TYPE;\n        fqts.push(curType, rule);\n      } else {\n        // must be args for curType since typeset is an array and object is not\n        //  in first position\n        fqts.push(rule);\n      }\n    } else if (isFunction(rule)) { // must be a validator, ANY is implied type if none specified\n      if (!curType) {\n        curType = types.ANY;\n        fqts.push(curType);\n      }\n\n      fqts.push(rule);\n    } else { // must be an array\n      if (curType !== types.ARRAY) {\n        // add implied ARRAY type\n        curType = types.ARRAY;\n        fqts.push(curType);\n      }\n\n      fqts.push(rule);\n    }\n  });\n\n  return fqts;\n};\n\n/**\n * Checks a value against a simple type.\n * @function rtv.impl.checkSimple\n * @param {*} value Value to check.\n * @param {string} typeset Simple typeset name, must be one of {@link rtvref.types.types}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} A success indicator if the\n *  `value` is compliant to the type; an error indicator if not.\n * @throws {Error} If `typeset` is not a valid type name.\n * @see {@link rtvref.types}\n */\nexport const checkSimple = function(value, typeset) {\n  types.verify(typeset);\n\n  let valid = false;\n  if (typeset === types.STRING) {\n    valid = isString(value);\n  } else if (typeset === types.BOOLEAN) {\n    valid = isBoolean(value);\n  } else {\n    throw new Error(`Missing handler for '${print(typeset)}' type`);\n  }\n\n  if (valid) {\n    return new RtvSuccess();\n  }\n\n  // TODO return RtvError if fails\n};\n\n/**\n * Checks a value against a shape/typeset.\n * @function rtv.impl.check\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} typeset Expected shape/type of the value.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the `value`\n *  is compliant to the `typeset`; error indicator otherwise. An exception is\n *  __not__ thrown if the `value` is non-compliant.\n * @throws {Error} If `typeset` is not a valid typeset.\n * @see {@link rtvref.types.typeset}\n * @see {@link rtvref.shape_descriptor}\n */\nexport const check = function(value, typeset) {\n  // TODO: on check failure (with a valid typeset), return a special RtvError object that\n  //  contains extra properties to indicate what didn't match, what was expected,\n  //  the shape that was checked, the value that was checked, etc.\n  //  If check succeeds, return boolean `true`. rtv.check/verify can then test\n  //  for the return type since impl shouldn't be exposed externally anyway.\n  try {\n    if (isTypeset(typeset)) {\n      if (isString(typeset)) {\n        return checkSimple(value, typeset);\n      }\n\n      // TODO other typeset types\n\n      throw new Error(`Missing handler for typeset='${print(typeset)}' type specified`);\n    } else {\n      throw new Error(`Invalid typeset='${print(typeset)}' specified`);\n    }\n  } catch (checkErr) {\n    const err = new Error(`Cannot check value: ${checkErr.message}`);\n    err.rootCause = checkErr;\n    throw err;\n  }\n};\n","//// Main entry point \\\\\\\\\n\nimport {version as VERSION} from '../package.json';\nimport * as impl from './lib/impl';\nimport types from './lib/types';\nimport qualifiers from './lib/qualifiers';\nimport RtvSuccess from './lib/RtvSuccess';\n\n/**\n * <h1>RTV.js Reference</h1>\n *\n * Members herein are _indirectly_ exposed through the {@link rtv} object.\n * @namespace rtvref\n */\n\n/**\n * <h2>Shape Descriptor</h2>\n *\n * Describes the shape (i.e. interface) of an object as a map of properties to\n *  {@link rtvref.types.typeset typesets}. Each typeset indicates whether the\n *  property is required, expected, or optional, using {@link rtvref.qualifiers qualifiers},\n *  along with possible types. Only enumerable, own-properties of the shape are\n *  considered part of the shape.\n *\n * When a value is {@link rtv.check checked} or {@link rtv.verify verified} against\n *  a given shape, _properties on the value that are not part of the shape are\n *  ignored_. If successfully checked/verified, the value is guaranteed to provide\n *  the properties described in the shape, and each property is guaranteed to be\n *  assigned to a value of at least one type described in each property's typeset.\n *\n * @typedef {Object} rtvref.shape_descriptor\n */\n\n/**\n * <h1>RTV.js</h1>\n *\n * Runtime Verification Library for browsers and Node.js.\n * @namespace rtv\n */\nconst rtv = {\n  /**\n   * Enumeration of {@link rtvref.types types}.\n   * @name rtv.t\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  t: types,\n\n  /**\n   * Enumeration of {@link rtvref.qualifiers qualifiers}.\n   * @name rtv.q\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  q: qualifiers,\n\n  /**\n   * Checks a value against a typeset for compliance.\n   * @function rtv.check\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the\n   *  `value` is compliant to the `shape`; `RtvError` if not. __Unlike\n   *  {@link rtv.verify verify()}, an exception is not thrown__ if the\n   *  `value` is non-compliant.\n   *\n   *  Since both {@link rtvref.RtvSuccess RtvSuccess}, returned when\n   *   the check succeeds, as well as {@link rtvref.RtvError RtvError}, returned\n   *   when the check fails, have a `valid: boolean` property in common, it's\n   *   easy to test for success/failure like this:\n   *   `if (rtv.check(2, rtv.t.FINITE).valid) {...}`.\n   *\n   *  __NOTE:__ This method always returns a success indicator if RTV.js is currently\n   *   {@link rtv.config.enabled disabled}.\n   *\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.verify}\n   * @see {@link rtv.config.enabled}\n   * @see {@link rtvref.types}\n   * @see {@link rtvref.shape_descriptor}\n   */\n  check(value, typeset) {\n    if (this.config.enabled) {\n      return impl.check(value, typeset);\n    }\n\n    return new RtvSuccess();\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.check}.\n   * @function rtv.c\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the\n   *  `value` is compliant to the `shape`; `RtvError` if not. __Unlike\n   *  {@link rtv.verify verify()}, an exception is not thrown__ if the\n   *  `value` is non-compliant.\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.check}\n   */\n  c(value, typeset) {\n    return this.check(value, typeset);\n  },\n\n  /**\n   * __Requires__ a value to be compliant to a shape.\n   *\n   * NOTE: This method does nothing if RTV.js is currently\n   *  {@link rtv.config.enabled disabled}.\n   *\n   * @function rtv.verify\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {rtvref.RtvSuccess} Success indicator IIF the `value` is compliant\n   *  to the `shape`. Otherwise, an {@link rtvref.RtvError RtvError} __is thrown__.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.check}\n   * @see {@link rtv.config.enabled}\n   * @see {@link rtvref.types}\n   * @see {@link rtvref.shape_descriptor}\n   */\n  verify(value, typeset) {\n    if (this.config.enabled) {\n      const result = this.check(value, typeset);\n      if (result instanceof RtvSuccess) {\n        return result;\n      }\n\n      throw result; // expected to be an RtvError\n    }\n\n    return new RtvSuccess();\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.verify}.\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {rtvref.RtvSuccess} Success indicator IIF the `value` is compliant\n   *  to the `shape`. Otherwise, an {@link rtvref.RtvError RtvError} __is thrown__.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @see {@link rtv.verify}\n   */\n  v(value, typeset) {\n    return this.verify(value, typeset);\n  },\n\n  /**\n   * RTV Library Configuration\n   * @namespace rtv.config\n   */\n  config: Object.defineProperties({}, {\n    /**\n     * Globally enables or disables {@link rtv.verify} and {@link rtv.check}.\n     *\n     * Use this, or the shortcut {@link rtv.e}, to enable code optimization\n     *  when building source with a bundler that supports _tree shaking_ like\n     *  {@link https://rollupjs.org/ Rollup} or {@link https://webpack.js.org/ Webpack}.\n     *\n     * <h4>Example</h4>\n     *\n     * By conditionally calling {@link rtv.verify} based on the state of\n     *  {@link rtv.config.enabled}, a bundler can be configured to completely\n     *  remove the code from a production build.\n     *\n     * // TODO: Add Rollup and Webpack examples.\n     *\n     * <pre><code>if (rtv.config.enabled) {\n     *  rtv.verify(jsonResult, expectedShape);\n     * }\n     *\n     * rtv.e && rtv.v(jsonResult, expectedShape); // even shorter\n     * </code></pre>\n     *\n     * @name rtv.config.enabled\n     * @type {boolean}\n     * @see {@link rtv.enabled}\n     */\n    enabled: (function() {\n      let value = true;\n      return {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return value;\n        },\n        set(newValue) {\n          rtv.verify(newValue, rtv.t.BOOLEAN);\n          value = newValue;\n        }\n      };\n    })()\n  }),\n\n  /**\n   * Shortcut proxy for reading {@link rtv.config.enabled}.\n   * @readonly\n   * @name rtv.e\n   * @type {boolean}\n   */\n  get e() {\n    return this.config.enabled;\n  },\n\n  /**\n   * Contextual RTV Generator // TODO[docs]\n   * @function rtv.Context\n   * @param {string} context\n   */\n  Context(context) {\n    // TODO: a version with same API (less 'config') that will include 'context' in errors thrown\n  }\n};\n\n/**\n * [internal] Library version.\n * @name rtv._version\n * @type {string}\n */\nObject.defineProperty(rtv, '_version', {\n  enumerable: false, // internal\n  configurable: true,\n  value: VERSION\n});\n\nexport default rtv;\n"],"names":["isArray","Array","freeGlobal","global","Object","freeSelf","self","root","Function","Symbol","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","toStringTag","undefined","getRawTag","value","isOwn","call","tag","unmasked","e","result","objectToString","nullTag","undefinedTag","baseGetTag","isObjectLike","isObject","type","asyncTag","funcTag","genTag","proxyTag","isFunction","coreJsData","maskSrcKey","uid","exec","keys","IE_PROTO","isMasked","func","funcProto","funcToString","toSource","reRegExpChar","reIsHostCtor","reIsNative","RegExp","replace","baseIsNative","test","getValue","object","key","getNative","DataView","Map","Promise","Set","WeakMap","mapTag","objectTag","promiseTag","setTag","weakMapTag","dataViewTag","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","Ctor","constructor","ctorString","baseIsMap","baseUnary","freeExports","exports","nodeType","freeModule","module","freeProcess","process","nodeUtil","binding","nodeIsMap","isMap","isWeakMap","baseIsSet","nodeIsSet","isSet","weakSetTag","isWeakSet","regexpTag","baseIsRegExp","nodeIsRegExp","isRegExp","arrayEach","array","iteratee","index","length","createBaseFor","fromRight","keysFunc","iterable","props","baseFor","baseTimes","n","argsTag","baseIsArguments","propertyIsEnumerable","isArguments","arguments","stubFalse","Buffer","isBuffer","MAX_SAFE_INTEGER","reIsUint","isIndex","isLength","arrayTag","boolTag","dateTag","errorTag","numberTag","stringTag","arrayBufferTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","typedArrayTags","baseIsTypedArray","nodeIsTypedArray","isTypedArray","arrayLikeKeys","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","push","isPrototype","overArg","transform","arg","nativeKeys","baseKeys","isArrayLike","baseForOwn","createBaseEach","eachFunc","collection","baseEach","identity","castFunction","forEach","Enumeration","map","values","Error","indexOf","defineProperty","this","concat","$values","silent","check","join","k","_this2","p","def","hasArgs","defs","DEFAULT_OBJECT_TYPE","OBJECT","objTypes","types","name","argTypes","REQUIRED","EXPECTED","OPTIONAL","isString","v","emptyOk","isBoolean","_isFunction","_isArray","_isMap","_isWeakMap","_isSet","_isWeakSet","_isRegExp","_isObjectLike","isTypeset","deep","fullyQualified","valid","usedTypes","curType","argType","rule","i","qualifiers","shape","CLASS_OBJECT","MAP_OBJECT","_forEach","ts","prop","ARRAY","hasQualifier","updateCurType","ANY","print","replacer","val","JSON","stringify","RtvSuccess","defineProperties","checkSimple","typeset","verify","STRING","BOOLEAN","checkErr","err","message","rootCause","rtv","config","enabled","impl","newValue","t","context","VERSION"],"mappings":"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"}