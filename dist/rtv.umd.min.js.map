{"version":3,"file":"rtv.umd.min.js","sources":["../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isArray.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isString.js","../src/rtv.js","../src/lib/types.js","../src/lib/qualiiers.js","../src/lib/Enumeration.js"],"sourcesContent":["/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n","//// Main entry point \\\\\\\\\n\nimport isString from 'lodash/isString';\nimport {version as VERSION} from '../package.json';\nimport * as typeMap from './lib/types';\nimport * as qualifierMap from './lib/qualiiers';\nimport Enumeration from './lib/Enumeration';\n\n/**\n * RTV.js - Reference\n *\n * Members herein are _indirectly_ exposed through the {@link rtv} object.\n * @namespace rtvref\n */\n\n/**\n * Shape Descriptor\n *\n * // TODO: document rtvref.shape_descriptor (already referenced)\n *\n * @typedef {Object} rtvref.shape_descriptor\n */\n\nconst types = new Enumeration(typeMap);\nconst qualifiers = new Enumeration(qualifierMap);\n\n/**\n * RTV.js - Runtime Verification Library.\n * @namespace rtv\n */\nconst rtv = {\n  /**\n   * Enumeration of {@link rtvref.types types}.\n   * @name rtv.t\n   * @type {rtvref.Enumeration}\n   */\n  t: types,\n\n  /**\n   * Enumeration of {@link rtvref.qualifiers qualifiers}.\n   * @name rtv.q\n   * @type {rtvref.Enumeration}\n   */\n  q: qualifiers,\n\n  /**\n   * Checks a value against a shape for compliance.\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value.\n   * @returns {Boolean} `true` if the `value` is compliant to the `shape`; `false`\n   *  otherwise. An exception is __not__ thrown if the `value` is non-compliant.\n   * @see rtv.verify\n   */\n  check(value, shape) {\n    // TODO: testing 'check'\n    return isString(value) && !!value;\n  },\n\n  /**\n   * __Requires__ a value to be compliant to a shape.\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value.\n   * @returns {Boolean} `true` if the `value` is compliant to the `shape`; otherwise,\n   *  an exception is thrown.\n   * @throws {Error} If the `value` is not compliant to the `shape`.\n   * @see rtv.verify\n   */\n  verify(value, shape) {\n    // TODO: testing 'verify'\n    if (this.config.enabled) {\n      if (!this.check(value, shape)) {\n        throw new Error('value must be a ' + types.STRING + ': ' + value);\n      }\n    }\n  },\n\n  // TODO: docs\n  config: Object.defineProperties({}, {\n    enabled: (function() {\n      let value = true;\n      return {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return value;\n        },\n        set(newValue) {\n          rtv.verify(newValue, types.BOOLEAN);\n          value = newValue;\n        }\n      };\n    })()\n  }),\n\n  // TODO: docs\n  Context(context) {\n    // TODO: a version with same API (less 'config') that will include 'context' in errors thrown\n  }\n};\n\n/**\n * [internal] Library version.\n * @name rtv._version\n * @type {String}\n */\nObject.defineProperty(rtv, '_version', {\n  enumerable: false, // internal\n  configurable: true,\n  value: VERSION\n});\n\nexport default rtv;\n","//// Type Definitions \\\\\\\\\n\n/**\n * Types\n *\n * <h4>Primitives</h4>\n *\n * In RTV.js, a primitive is considered to be one of the following types:\n *\n * - `string` (note that `new String('s')` does not produce a _primitive_, it\n *   produces an _object_, and should generally be avoided).\n * - `boolean` (note that `new Boolean(true)` does not produce a _primitive_,\n *   it produces an _object_, and should generally be avoided).\n * - `number` (note that `new Number(1)` does not produce a _primitive_,\n *   it produces an _object_, and should generally be avoided).\n * - `Symbol`\n * - `null`\n * - `undefined`\n *\n * <h4>Rules Per Qualifiers</h4>\n *\n * {@link rtvref.qualifiers Qualifiers} state basic rules. Unless otherwise stated,\n *  every type herein abides by those basic rules. Each type will also impose\n *  additional rules specific to the type of value it represents.\n *\n * For example, while the {@link rtvref.types.FINITE FINITE} type states that the\n *  value must not be `NaN`, `+Infinity`, nor `-Infinity`, it could be `null` if\n *  the qualifier used is `EXPECTED`, and it could be `undefined` if the qualifier\n *  used is `OPTIONAL`.\n *\n * <h4>Arguments</h4>\n *\n * Some types will accept, or may even expect, arguments. An argument immediately\n *  follows the type in the description, such as `PLAIN_OBJECT, {hello: STRING}`.\n *  This would specify that the value must be a {@link rtvref.types.PLAIN_OBJECT plain object}\n *  with a shape that includes a property named 'hello', that property being a\n *  {@link rtvref.qualifiers.REQUIRED required} {@link rtvref.types.STRING string}.\n *\n * Optional and required arguments are specified for each type, where applicable.\n *\n * @namespace rtvref.types\n */\n\n/**\n * Collection Descriptor\n *\n * Describes the keys and values in a collection-based object, which is one of\n *  the following types:\n *\n * - {@link rtvref.types.MAP_OBJECT MAP_OBJECT}\n * - {@link rtvref.types.MAP MAP}\n * - {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * - {@link rtvref.types.SET SET} (with some exceptions)\n * - {@link rtvref.types.WEAK_SET WEAK_SET} (with some exceptions)\n *\n * Note that an {@link rtvref.types.ARRAY ARRAY} is __not__ included in this list\n *  because the array type has special syntax for describing the type of its items.\n *\n * For example, the following descriptors both verify a collection of 3-letter\n *  string keys (upper- or lowercase) to finite numbers:\n *\n * - `{keyExp: '[a-z]{3}', keyExpFlags: 'i', values: rtv.t.FINITE}`\n * - `{keyExp: '[a-zA-Z]{3}', values: rtv.t.FINITE}`\n *\n * @typedef {Object} rtvref.types.collection_descriptor\n * @property {rtvref.types.typeset} [keys] Optional. A typeset describing each key\n *  in the collection.\n *\n * The type of collection being described may restrict the types that this typeset\n *  can include. For example, the {@link rtvref.types.MAP_OBJECT MAP_OBJECT} collection\n *  only supports the {@link rtvref.types.STRING STRING} type due to the nature of\n *  its JavaScript Object-based implementation.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {String} [keyExp] Optional. A string-based regular expression\n *  describing the names of keys (own-enumerable properties) found in the\n *  collection.\n *\n * By default, there are no restrictions on key names. This expression is only\n *  used if the `keys` typeset includes the {@link rtvref.types.STRING STRING} type.\n *\n * For example, to require numerical keys, the following expression could be\n *  used: `'^\\\\d+$'`.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {String} [keyExpFlags] Optional. A string specifying any flags to use\n *  with the regular expression specified in `keyExp`. If this property is _falsy_,\n *  default `RegExp` flags will be used. Ignored if `keyExp` is not specified, or\n *  does not apply per the `keys` typeset.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {rtvref.types.typeset} [values] Optional. A typeset describing each value\n *  in the collection. Defaults to the {@link rtvref.types.ANY ANY} type which allows\n *  _anything_. All values must match this typeset (but the collection is not\n *  required to have any entries/properties to be considered valid, unless\n *  `count` is specified).\n *\n * For example, to require arrays of non-empty string values, the following\n *  typeset could be used: `[[types.STRING]]`.\n *\n * @property {Number} [count=-1] Optional. The number of entries expected in\n *  the collection. A negative value allows for any number of entries. Zero\n *  requires an empty collection.\n *\n * @see rtvref.types.MAP_OBJECT\n * @see rtvref.types.MAP\n * @see rtvref.types.WEAK_MAP\n * @see rtvref.types.SET\n * @see rtvref.types.WEAK_SET\n */\n\n/**\n * Typeset\n *\n * Describes the possible types for a given value. It can be any one of the following\n *  JavaScript types:\n *\n * - `Object`: For the root or a nested {@link rtvref.shape_descriptor shape descriptor}\n *   of implied {@link rtvref.types.OBJECT OBJECT} type (unless qualified with a specific\n *   object type like {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, for example).\n * - `String`: For a single type, such as {@link rtvref.types.FINITE 'FINITE'}\n *   for a finite number.\n * - `Array`: For multiple type possibilities, using an OR conjunction, which\n *   means the value of the property being described must be one of the types listed.\n *   Note that when a nested array is encountered (i.e. an array within a typeset),\n *   it is treated as the shortcut {@link rtvref.types.ARRAY ARRAY} form, implying an\n *   array of values of some type, e.g. `values: [[STRING, FINITE]]` would describe\n *   a 'values' property that could be an array of non-empty strings or finite numbers.\n * - `Function`: For a {@link rtvref.types.property_validator property validator}\n *   that will certify the value of the property using custom code.\n *\n * <h4>Example: Objects</h4>\n *\n * <pre><code>const contactShape = {\n *   name: rtv.t.STRING, // required, non-empty, string\n *   tags: [rtv.t.ARRAY, [rtv.t.STRING]], // required array of non-empty strings\n *   // tags: [[rtv.t.STRING]], // same as above, but using shortcut array format\n *   details: { // required nested object of type `rtv.t.OBJECT` (default)\n *     birthday: [rtv.q.EXPECTED, rtv.t.DATE] // Date (could be null)\n *   },\n *   notes: [rtv.q.OPTIONAL, rtv.t.STRING, function(value) { // optional string...\n *     return !value || value.length < 500; // ...less than 500 characters long, if specified\n *   }]\n * };\n *\n * const contact = {\n *   name: 'John Doe',\n *   tags: ['colleagues', 'sports'],\n *   details: {\n *     birthday: null // not specified\n *   }\n * };\n *\n * rtv.verify(contact, contactShape); // OK\n *\n * const walletShape = {\n *   contacts: [[contactShape]], // list of contacts using nested shape\n *   address: {\n *     street: rtv.t.STRING\n *     // ...\n *   },\n *   money: rtv.t.FINITE\n * };\n *\n * rtv.verify({\n *   contacts: [contact],\n *   address: {street: '123 Main St'},\n *   money: 100\n * }, walletShape); // OK\n * </code></pre>\n *\n * <h4>Example: String</h4>\n *\n * <pre><code>rtv.verify('foo', rtv.t.STRING); // OK\n * rtv.verify('foo', rtv.t.FINITE); // ERROR\n * </code></pre>\n *\n * <h4>Example: Array</h4>\n *\n * <pre><code>const typeset = [rtv.t.STRING, rtv.t.FINITE]; // non-empty string, or finite number\n * rtv.verify('foo', typeset); // OK\n * rtv.verify(1, typeset); // OK\n * </code></pre>\n *\n * @typedef {Object} rtvref.types.typeset\n */\n\n/**\n * Property Validator\n *\n * // TODO: document rtvref.types.property_validator (already referenced)\n *\n * Note one disadvantage: cannot be de/serialized via JSON.\n *\n * @typedef {Function} rtvref.types.property_validator\n */\n\n/**\n * The any type is special in that it allows _anything_, which includes `null`\n *  and `undefined` values. Because of this, it's the most liberal in terms of\n *  types as well as qualifiers. A more specific type should be used whenever\n *  possible to ensure a higher degree of confidence in the value being validated.\n *\n * Any rules per qualifiers:\n *\n * - REQUIRED: Property must be defined _somewhere_ in the prototype chain, but\n *   its value can be anything, including `null` and `undefined`.\n * - EXPECTED: Same rules as REQUIRED.\n * - OPTIONAL: Since this qualifier removes the property's need for existence\n *   in the prototype chain, it renders the verification moot (i.e. the property\n *   might as well not be included in the {@link rtvref.shape_descriptor shape descriptor}\n *   unless a {@link rtvref.types.property_validator property validator} is being\n *   used to do customized verification.\n *\n * @name rtvref.types.ANY\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const ANY = 'any';\n\n/**\n * String rules per qualifiers:\n *\n * - REQUIRED: Must be a non-empty string.\n * - EXPECTED | OPTIONAL: Can be an empty string.\n *\n * @name rtvref.types.STRING\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const STRING = 'string';\n\n/**\n * Boolean rules per qualifiers: Must be a boolean.\n * @name rtvref.types.BOOLEAN\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const BOOLEAN = 'boolean';\n\n/**\n * Number rules per qualifiers:\n *\n * - REQUIRED: Cannot be `NaN`, but could be `+Infinity`, `-Infinity`.\n * - EXPECTED | OPTIONAL: Could be `NaN`, `+Infinity`, `-Infinity`.\n *\n * @name rtvref.types.NUMBER\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.FINITE}\n */\nexport const NUMBER = 'number';\n\n/**\n * Symbol rules per qualifiers: Must be a symbol.\n * @name rtvref.types.SYMBOL\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const SYMBOL = 'symbol';\n\n/**\n * Finite rules per qualifiers: Cannot be `NaN`, `+Infinity`, `-Infinity`. The\n *  value can be either a safe integer or a {@link rtvref.types.FLOAT floating point number}.\n * @name rtvref.types.FINITE\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.NUMBER}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n */\nexport const FINITE = 'finite';\n\n/**\n * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} integer,\n *  but is not necessarily _safe_.\n * @name rtvref.types.INT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.FINITE}\n * @see {@link rtvref.types.FLOAT}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n */\nexport const INT = 'int';\n\n/**\n * Float rules per qualifiers: Must be a finite floating point number.\n * @name rtvref.types.FLOAT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.INT}\n */\nexport const FLOAT = 'float';\n\n/**\n * An _any_ object is anything that is not a {@link rtvref.types primitive}, which\n *  means it includes the `Array` type, as well as functions and arguments. To\n *  test for an array, use the {@link rtvref.types.ARRAY ARRAY} type. To\n *  test for a function, use the {@link rtvref.types.FUNCTION FUNCTION} type.\n *\n * The following values are considered any objects:\n *\n * - `{}`\n * - `new Object()`\n * - `[]`\n * - `new Array()`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `/re/`\n * - `new RegExp('re')`\n * - `new function() {}` (class instance)\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n *\n * The following values __are not__ considered any objects (because they are\n *  considered to be {@link rtvref.types primitives}):\n *\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null` (NOTE: `typeof null === 'object'` in JavaScript; the `ANY_OBJECT`\n *   type allows testing for this undesirable fact)\n * - `undefined`\n *\n * Any object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional):\n *\n * - A nested shape description.\n *\n * @name rtvref.types.ANY_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const ANY_OBJECT = 'anyObject';\n\n/**\n * An object is one that extends from `JavaScript.Object` and is not\n *  a {@link rtvref.types.FUNCTION function}, {@link rtvref.types.ARRAY array},\n *  {@link rtvref.types.REGEXP regular expression}, function arguments object,\n *  {@link rtvref.types.MAP map}, {@link rtvref.types.WEAK_MAP weak map},\n *  {@link rtvref.types.SET set}, {@link rtvref.types.WEAK_SET weak set}, nor a\n *  {@link rtvref.types primitive}.\n *\n * This is the __default__ (imputed) type for\n *  {@link rtvref.shape_descriptor shape descriptors}, which means the object itself\n *  (the value being tested), prior to being checked against its shape, will be\n *  tested according to this type.\n *\n * The following values are considered objects:\n *\n * - `{}`\n * - `new Object()`\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `new function() {}` (class instance)\n *\n * The following values __are not__ considered objects:\n *\n * - `[]`\n * - `new Array()`\n * - `/re/`\n * - `new RegExp('re')`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null`\n * - `undefined`\n *\n * Object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional):\n *\n * - A nested shape description.\n *\n * @name rtvref.types.OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const OBJECT = 'object';\n\n/**\n * A _plain_ object is one that is created directly from the `Object` constructor,\n *  whether using `new Object()` or the literal `{}`.\n *\n * The following values are considered plain objects:\n *\n * - `{}`\n * - `new Object()`\n *\n * The following values __are not__ considered plain objects:\n *\n * - `[]`\n * - `new Array()`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `/re/`\n * - `new RegExp('re')`\n * - `new function() {}` (class instance)\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null`\n * - `undefined`\n *\n * Plain object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional):\n *\n * - A nested shape description.\n *\n * @name rtvref.types.PLAIN_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const PLAIN_OBJECT = 'plainObject';\n\n/**\n * A _class_ object is one that is created by invoking the `new` operator on a\n *  function (other than a primitive type function), generating a new object,\n *  commonly referred to as a _class instance_. This object's prototype\n *  (`__proto__`) is a reference to that function's `prototype`.\n *\n * The following values are considered class objects:\n *\n * - `new function() {}`\n *\n * The following values __are not__ considered class objects:\n *\n * - `{}`\n * - `new Object()`\n * - `[]`\n * - `new Array()`\n * - `function(){}`\n * - `arguments` (function arguments)\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `/re/`\n * - `new RegExp('re')`\n * - `new Set()`\n * - `new WeakSet()`\n * - `new Map()`\n * - `new WeakMap()`\n * - `Symbol('s')`\n * - `true`\n * - `1`\n * - `''`\n * - `null`\n * - `undefined`\n *\n * Class object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional, specify one or the other, or both __in order__):\n *\n * - A reference to a constructor function. If specified, the class object\n *   (instance) must have this class function in its inheritance chain such\n *   that `<class_object> instanceof <function> === true`.\n * - A nested shape description.\n *\n * @name rtvref.types.CLASS_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const CLASS_OBJECT = 'classObject';\n\n/**\n * A _map_ object is an {@link rtvref.types.OBJECT OBJECT} that is treated as a\n *  hash map with an expected set of keys and values. Keys can be described\n *  using a regular expression, and values can be described using a\n *  {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Map object rules per qualifiers: Same as {@link rtvref.types.OBJECT OBJECT} rules.\n *\n * Argument (optional):\n *\n * - A {@link rtvref.types.collection_descriptor collection descriptor} specifying\n *   the rules for the keys and/or values found in the map. If not specified,\n *   the default collection descriptor options apply. __NOTE:__ Since a map object\n *   is based on a JavaScript Object (which only supports string-based keys), the\n *   collection descriptor's `keys` type defaults to (and is required to be)\n *   {@link rtvref.types.STRING STRING}.\n *\n * @name rtvref.types.MAP_OBJECT\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const MAP_OBJECT = 'mapObject';\n\n// TODO: Is there a way that ARRAY could take a parameter, that being the\n//  required length of the array, defaulting to -1 for any length? Perhaps\n//  only when using the full form as `[ARRAY, 2, [STRING]]` instead of the\n//  short form as `[[STRING]]`? If so, then this would be up to par with\n//  the MAP_OBJECT where a count can be specified...\n/**\n * Array rules per qualifiers: Must be an `Array`. Empty arrays are permitted.\n * @name rtvref.types.ARRAY\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const ARRAY = 'array';\n\n/**\n * JSON rules per qualifiers: Must be a JSON value:\n *\n * - {@link rtvref.types.STRING string}, however __empty strings__ are permitted,\n *   even if the qualifier is `REQUIRED`;\n * - {@link rtvref.types.BOOLEAN boolean};\n * - {@link rtvref.types.FINITE finite number};\n * - {@link rtvref.types.PLAIN_OBJECT plain object};\n * - {@link rtvref.types.ARRAY array};\n * - `null`\n *\n * Since this type checks for _any_ valid JSON value, empty string and `null`\n *  values are permitted, even when the typeset is qualified as `REQUIRED`.\n *  Therefore, the `REQUIRED` qualifier has the same effect as the `EXPECTED`\n *  qualifier.\n *\n * @name rtvref.types.JSON\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const JSON = 'json';\n\n/**\n * Function rules per qualifiers: Must be a `function`.\n * @name rtvref.types.FUNCTION\n * @const {String}\n * @see {@link rtvref.qualifiers}\n */\nexport const FUNCTION = 'function';\n\n/**\n * RegExp rules per qualifiers: Must be a `RegExp` instance.\n * @name rtvref.types.REGEXP\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n */\nexport const REGEXP = 'regexp';\n\n/**\n * Date rules per qualifiers: Must be a `Date` instance.\n * @name rtvref.types.DATE\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n */\nexport const DATE = 'date';\n\n/**\n * Error rules per qualifiers: Must be an `Error` instance.\n * @name rtvref.types.ERROR\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n */\nexport const ERROR = 'error';\n\n/**\n * Promise rules per qualifiers: Must be a `Promise` instance.\n * @name rtvref.types.PROMISE\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\nexport const PROMISE = 'promise';\n\n/**\n * An ES6 map supports any object as its keys, unlike a\n *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n *  be described using a regular expression (if they are strings), and values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Map rules per qualifiers: Must be a `Map` instance.\n *\n * Argument (optional):\n *\n * - A {@link rtvref.types.collection_descriptor collection descriptor} specifying\n *   the rules for the keys and/or values found in the map. If not specified,\n *   the default collection descriptor options apply.\n *\n * @name rtvref.types.MAP\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const MAP = 'map';\n\n/**\n * An ES6 weak map supports any object as its keys, unlike a\n *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n *  be described using a regular expression (if they are strings), and values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Weak map rules per qualifiers: Must be a `WeakMap` instance.\n *\n * Argument (optional):\n *\n * - A {@link rtvref.types.collection_descriptor collection descriptor} specifying\n *   the rules for the keys and/or values found in the map. If not specified,\n *   the default collection descriptor options apply.\n *\n * @name rtvref.types.WEAK_MAP\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n */\nexport const WEAK_MAP = 'weakMap';\n\n/**\n * An ES6 set is a collection of _unique_ values without associated keys. Values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted.\n *\n * Set rules per qualifiers: Must be a `Set` instance.\n *\n * Argument (optional):\n *\n * - A {@link rtvref.types.collection_descriptor collection descriptor} specifying\n *   the rules for the values found in the set (note that key-related rules are\n *   ignored since they are not applicable). If not specified, the default\n *   collection descriptor options apply.\n *\n * @name rtvref.types.SET\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.WEAK_SET}\n */\nexport const SET = 'set';\n\n/**\n * An ES6 weak set is a collection of _unique_ values without associated keys. Values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted.\n *\n * Weak set rules per qualifiers: Must be a `WeakSet` instance.\n *\n * Argument (optional):\n *\n * - A {@link rtvref.types.collection_descriptor collection descriptor} specifying\n *   the rules for the values found in the set (note that key-related rules are\n *   ignored since they are not applicable). If not specified, the default\n *   collection descriptor options apply.\n *\n * @name rtvref.types.WEAK_SET\n * @const {String}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.SET}\n */\nexport const WEAK_SET = 'weakSet';\n","//// Qualifier Definitions \\\\\\\\\n\n/**\n * Qualifiers\n * @namespace rtvref.qualifiers\n */\n\n/**\n * Required qualifier: Property _must_ exist and be of the expected type.\n *  Depending on the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, and does not\n *  allow its value to be `null` or `undefined`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.REQUIRED\n * @const {String}\n * @see {@link rtvref.types}\n */\nexport const REQUIRED = '!';\n\n/**\n * Expected qualifier: Property _should_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, does not allow\n *  its value to be `undefined`, but does _allow_ its value to be `null`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.EXPECTED\n * @const {String}\n * @see {@link rtvref.types}\n */\nexport const EXPECTED = '+';\n\n/**\n * Optional qualifier: Property _may_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced (i.e. less so\n *  than with the `EXPECTED` qualifier).\n *\n * Unless otherwise stated in type-specific rules, this qualifier _allows_ a\n *  property value to be `null` as well as `undefined`, and does _not_ require\n *  it to be defined anywhere in the prototype chain. If the property is defined,\n *  then it is treated as an `EXPECTED` value.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.OPTIONAL\n * @const {String}\n * @see {@link rtvref.types}\n */\nexport const OPTIONAL = '?';\n","//// Enumeration \\\\\\\\\n\n/**\n * Simple enumeration type.\n * @class rtvref.Enumeration\n * @param {Object.<String,*>} map Object mapping keys to values. Values cannot\n *  be `undefined`.\n * @throws {Error} If `map` is falsy or empty.\n * @throws {Error} If `map` has a key that maps to `undefined`.\n */\nclass Enumeration {\n  constructor(map) {\n    map = map || {};\n\n    const keys = Object.keys(map);\n    const values = [];\n\n    if (keys.length === 0) {\n      throw new Error('map must contain at least one key');\n    }\n\n    // shallow-clone each key in the map into this\n    keys.forEach((key) => {\n      if (map[key] === undefined) {\n        throw new Error('map[' + key + '] cannot be undefined');\n      }\n\n      const value = map[key];\n      values.push(value);\n      this[key] = value;\n    });\n\n    /**\n     * [internal] List of enumeration values.\n     * @name rtvref.Enumeration#_values\n     * @type Array.<String>\n     */\n    Object.defineProperty(this, '_values', {\n      enumerable: false, // internal\n      configurable: true,\n      value: values\n    });\n  }\n\n  /**\n   * Validates a value as being in this enumeration. Throws an exception if the value\n   *  is not in this enumeration, unless `silent` is true.\n   * @method rtvref.Enumeration#verify\n   * @param {*} value Value to check. Cannot be undefined.\n   * @param {Boolean} [silent=false] If truthy, returns `undefined` instead of throwing\n   *  an exception if the specified value is not in this enumeration.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined` if\n   *  `silent` is true and the value is not in this enumeration.\n   */\n  verify(value, silent) {\n    if (this._values.indexOf(value) >= 0) {\n      return value;\n    } else if (silent) {\n      return undefined;\n    }\n\n    throw new Error('invalid value for enum[' + this._values.join(', ') + ']: ' + value);\n  }\n\n  /**\n   * A string representation of this Enumeration.\n   * @returns {string} String representation.\n   */\n  toString() {\n    const pairs = Object.keys(this).map((k) => [k, this[k]]);\n    return `{Enumeration pairs=[${pairs.map((p) => `[${p}]`).join(', ')}]}`;\n  }\n}\n\nexport default Enumeration;\n"],"names":["global","Object","freeSelf","self","freeGlobal","Function","Symbol","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","toStringTag","undefined","value","isOwn","call","tag","unmasked","e","result","nullTag","undefinedTag","getRawTag","objectToString","Array","isArray","stringTag","isObjectLike","baseGetTag","Enumeration","map","keys","values","length","Error","forEach","key","push","defineProperty","this","silent","_values","indexOf","join","k","_this2","p","types","typeMap","qualifiers","qualifierMap","rtv","shape","isString","config","enabled","check","STRING","defineProperties","newValue","verify","BOOLEAN","context"],"mappings":";;;;;0WACkC,iBAAVA,GAAsBA,GAAUA,EAAOC,SAAWA,QAAUD,ECEhFE,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKF,SAAWA,QAAUE,QAGjEC,GAAcF,GAAYG,SAAS,cAATA,ICHnBC,OCAdC,EAAcN,OAAOO,UAGrBC,EAAiBF,EAAYE,eAO7BC,EAAuBH,EAAYI,SAGnCC,EAAiBN,EAASA,EAAOO,iBAAcC,EA6BnD,MApBA,SAAmBC,GACjB,IAAIC,EAAQP,EAAeQ,KAAKF,EAAOH,GACnCM,EAAMH,EAAMH,GAEhB,IACEG,EAAMH,QAAkBE,EACxB,IAAIK,GAAW,EACf,MAAOC,IAET,IAAIC,EAASX,EAAqBO,KAAKF,GAQvC,OAPII,IACEH,EACFD,EAAMH,GAAkBM,SAEjBH,EAAMH,IAGVS,GClCLX,EAPcT,OAAOO,UAOcG,SAavC,MAJA,SAAwBI,GACtB,OAAOL,EAAqBO,KAAKF,ICb/BO,EAAU,gBACVC,EAAe,qBAGfX,EAAiBN,EAASA,EAAOO,iBAAcC,EAkBnD,MATA,SAAoBC,GAClB,OAAa,MAATA,OACeD,IAAVC,EAAsBQ,EAAeD,EAEtCV,GAAkBA,KAAkBX,OAAOc,GAC/CS,EAAUT,GACVU,EAAeV,MCDPW,MAAMC,QCKpB,MAJA,SAAsBZ,GACpB,OAAgB,MAATA,GAAiC,iBAATA,GCpB7Ba,EAAY,kBAwBhB,ICkDUb,IDvDV,SAAkBA,GAChB,MAAuB,iBAATA,IACVY,EAAQZ,IAAUc,EAAad,IAAUe,EAAWf,IAAUa,wBEsMjD,aAYG,iBAQC,iBAaD,gBAQA,gBAWA,aAYH,YASE,mBAwDK,mBA6DJ,sBAoDM,2BAyDA,yBA6BF,kBAaL,aAsBD,gBAQI,kBASF,cASF,aASC,gBASE,cAsBJ,eAsBK,cAoBL,eAoBK,sCCtrBA,aAgBA,aAkBA,0VC7ClBG,wBACQC,0BACJA,UAEAC,EAAOhC,OAAOgC,KAAKD,GACnBE,QAEc,IAAhBD,EAAKE,aACD,IAAIC,MAAM,uCAIbC,QAAQ,SAACC,WACKxB,IAAbkB,EAAIM,SACA,IAAIF,MAAM,OAASE,EAAM,6BAG3BvB,EAAQiB,EAAIM,KACXC,KAAKxB,KACPuB,GAAOvB,WAQPyB,eAAeC,KAAM,uBACd,gBACE,QACPP,6CAcJnB,EAAO2B,MACRD,KAAKE,QAAQC,QAAQ7B,IAAU,SAC1BA,EACF,IAAI2B,QAIL,IAAIN,MAAM,0BAA4BK,KAAKE,QAAQE,KAAK,MAAQ,MAAQ9B,8EAQhEd,OAAOgC,KAAKQ,MAAMT,IAAI,SAACc,UAAOA,EAAGC,EAAKD,MAChBd,IAAI,SAACgB,aAAUA,QAAMH,KAAK,oBH/C5DI,EAAQ,IAAIlB,EAAYmB,GACxBC,EAAa,IAAIpB,EAAYqB,GAM7BC,KAMDJ,IAOAE,iBAUGpC,EAAOuC,UAEJC,EAASxC,MAAYA,mBAYvBA,EAAOuC,MAERb,KAAKe,OAAOC,UACThB,KAAKiB,MAAM3C,EAAOuC,SACf,IAAIlB,MAAM,mBAAqBa,EAAMU,OAAS,KAAO5C,WAMzDd,OAAO2D,8BAEP7C,GAAQ,eAEE,gBACE,wBAELA,gBAEL8C,KACEC,OAAOD,EAAUZ,EAAMc,WACnBF,wBAORG,aAUV/D,OAAOuC,eAAea,EAAK,wBACb,gBACE"}