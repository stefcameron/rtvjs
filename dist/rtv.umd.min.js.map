{"version":3,"file":"rtv.umd.min.js","sources":["../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObject.js","../node_modules/lodash/isFunction.js","../node_modules/lodash/_isMasked.js","../node_modules/lodash/_coreJsData.js","../node_modules/lodash/_toSource.js","../node_modules/lodash/_baseIsNative.js","../node_modules/lodash/_getValue.js","../node_modules/lodash/_getNative.js","../node_modules/lodash/_DataView.js","../node_modules/lodash/_Map.js","../node_modules/lodash/_Promise.js","../node_modules/lodash/_Set.js","../node_modules/lodash/_WeakMap.js","../node_modules/lodash/_getTag.js","../src/rtv.js","../node_modules/lodash/_nodeUtil.js","../node_modules/lodash/isMap.js","../node_modules/lodash/isSet.js","../node_modules/lodash/isRegExp.js","../src/lib/Enumeration.js","../src/lib/qualifiers.js","../src/lib/validation.js","../src/lib/types.js","../src/lib/impl.js"],"sourcesContent":["/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","//// Main entry point \\\\\\\\\n\nimport {version as VERSION} from '../package.json';\nimport * as impl from './lib/impl';\nimport types from './lib/types';\nimport qualifiers from './lib/qualifiers';\n\n/**\n * <h1>RTV.js Reference</h1>\n *\n * Members herein are _indirectly_ exposed through the {@link rtv} object.\n * @namespace rtvref\n */\n\n/**\n * <h2>Shape Descriptor</h2>\n *\n * Describes the shape (i.e. interface) of an object as a map of properties to\n *  {@link rtvref.types.typeset typesets}. Each typeset indicates whether the\n *  property is required, expected, or optional, using {@link rtvref.qualifiers qualifiers},\n *  along with possible types.\n *\n * When a value is {@link rtv.check checked} or {@link rtv.verify verified} against\n *  a given shape, properties that are not part of the shape are ignored. If\n *  successfully checked/verified, the value is guaranteed to provide the properties\n *  described in the shape, and each property is guaranteed to be assigned to a\n *  value of at least one type described in each property's typeset.\n *\n * @typedef {Object} rtvref.shape_descriptor\n */\n\n/**\n * <h1>RTV.js</h1>\n *\n * Runtime Verification Library for browsers and Node.js.\n * @namespace rtv\n */\nconst rtv = {\n  /**\n   * Enumeration of {@link rtvref.types types}.\n   * @name rtv.t\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  t: types,\n\n  /**\n   * Enumeration of {@link rtvref.qualifiers qualifiers}.\n   * @name rtv.q\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  q: qualifiers,\n\n  /**\n   * Checks a value against a shape for compliance.\n   * @function rtv.check\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value.\n   * @returns {(boolean|rtvref.RtvError)} `true` if the `value` is compliant to\n   *  the `shape`; `RtvError` if not. An exception is __not__ thrown if the\n   *  `value` is non-compliant. Test for `rtv.check(...) !== true`.\n   *\n   * __NOTE:__ This method always returns `true` if RTV.js is currently\n   *  {@link rtv.config.enabled disabled}.\n   *\n   * @throws {Error} If `shape` is not a valid typeset.\n   * @see {@link rtv.verify}\n   */\n  check(value, shape) {\n    if (this.config.enabled) {\n      return impl.check(value, shape);\n    }\n\n    return true;\n  },\n\n  /**\n   * __Requires__ a value to be compliant to a shape.\n   *\n   * NOTE: This method does nothing if RTV.js is currently\n   *  {@link rtv.config.enabled disabled}.\n   *\n   * @function rtv.verify\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value. Normally,\n   *  this is a {@link rtvref.shape_descriptor shape descriptor}.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @throws {Error} If `shape` is not a valid typeset.\n   * @see {@link rtv.check}\n   * @see {@link rtv.config.enabled}\n   */\n  verify(value, shape) {\n    if (this.config.enabled) {\n      const result = this.check(value, shape);\n      if (result !== true) {\n        throw result; // expected to be an RtvError\n      }\n    }\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.verify}.\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} shape Expected shape of the value.\n   * @throws {Error} If the `value` is not compliant to the `shape`.\n   */\n  v(value, shape) {\n    this.verify(value, shape);\n  },\n\n  /**\n   * RTV Library Configuration\n   * @namespace rtv.config\n   */\n  config: Object.defineProperties({}, {\n    /**\n     * Globally enables or disables {@link rtv.verify} and {@link rtv.check}.\n     *\n     * Use this, or the shortcut {@link rtv.e}, to enable code optimization\n     *  when building source with a bundler that supports _tree shaking_ like\n     *  {@link https://rollupjs.org/ Rollup} or {@link https://webpack.js.org/ Webpack}.\n     *\n     * <h4>Example</h4>\n     *\n     * By conditionally calling {@link rtv.verify} based on the state of\n     *  {@link rtv.config.enabled}, a bundler can be configured to completely\n     *  remove the code from a production build.\n     *\n     * // TODO: Add Rollup and Webpack examples.\n     *\n     * <pre><code>if (rtv.config.enabled) {\n     *  rtv.verify(jsonResult, expectedShape);\n     * }\n     *\n     * rtv.e && rtv.v(jsonResult, expectedShape); // even shorter\n     * </code></pre>\n     *\n     * @name rtv.config.enabled\n     * @type {boolean}\n     * @see {@link rtv.enabled}\n     */\n    enabled: (function() {\n      let value = true;\n      return {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return value;\n        },\n        set(newValue) {\n          rtv.verify(newValue, rtv.t.BOOLEAN);\n          value = newValue;\n        }\n      };\n    })()\n  }),\n\n  /**\n   * Shortcut proxy for reading {@link rtv.config.enabled}.\n   * @readonly\n   * @name rtv.e\n   * @type {boolean}\n   */\n  get e() {\n    return this.config.enabled;\n  },\n\n  /**\n   * Contextual RTV Generator // TODO[docs]\n   * @function rtv.Context\n   * @param {string} context\n   */\n  Context(context) {\n    // TODO: a version with same API (less 'config') that will include 'context' in errors thrown\n  }\n};\n\n/**\n * [internal] Library version.\n * @name rtv._version\n * @type {string}\n */\nObject.defineProperty(rtv, '_version', {\n  enumerable: false, // internal\n  configurable: true,\n  value: VERSION\n});\n\nexport default rtv;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n","//// Enumeration \\\\\\\\\n\n/**\n * Simple enumeration type. Own-properties on an instance are the keys in the\n *  specified `map`, with their associated values.\n *\n * <pre><code>const state = new Enumeration({\n *   READY: 1,\n *   RUNNING: 2,\n *   STOPPED: 3,\n *   COMPLETE: 4\n * });\n *\n * state.RUNNING; // 2\n * state.verify(3); // 3 (returns the value since found in enumeration)\n * state.verify(5); // ERROR thrown\n * state.check(3); // 3 (same as verify(3) since found in enumeration)\n * state.check(5); // undefined (silent failure)\n * state.$values; // [1, 2, 3, 4] (special non-enumerable own-property)\n * </code></pre>\n *\n * @class rtvref.Enumeration\n * @param {Object.<String,*>} map Object mapping keys to values. Values cannot\n *  be `undefined`.\n * @throws {Error} If `map` is falsy or empty.\n * @throws {Error} If `map` has a key that maps to `undefined`.\n * @throws {Error} If `map` contains a duplicate value.\n */\nexport default class Enumeration {\n  // JSDoc is provided at the @class level\n  constructor(map) {\n    map = map || {};\n\n    const keys = Object.keys(map);\n    const values = [];\n\n    if (keys.length === 0) {\n      throw new Error('map must contain at least one key');\n    }\n\n    // shallow-clone each key in the map into this\n    keys.forEach((key) => {\n      if (map[key] === undefined) {\n        throw new Error('map[' + key + '] cannot be undefined');\n      }\n\n      const value = map[key];\n      if (values.indexOf(value) >= 0) {\n        throw new Error('map[' + key + '] is a duplicate value: ' + value);\n      }\n\n      values.push(value);\n      this[key] = value;\n    });\n\n    /**\n     * List of enumeration values. Values are _references_ to values in this\n     *  enumeration.\n     *\n     * Note that this own-property is non-enumerable on purpose. Enumerable\n     *  properties on this instance are the keys in this enumeration.\n     *\n     * @readonly\n     * @name rtvref.Enumeration#$values\n     * @type Array.<String>\n     */\n    Object.defineProperty(this, '$values', {\n      enumerable: false,\n      configurable: true,\n      get() {\n        return values.concat(); // shallow clone\n      }\n    });\n  }\n\n  /**\n   * Checks if a value is in this enumeration.\n   * @method rtvref.Enumeration#check\n   * @param {*} value Value to check. Cannot be undefined.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined`\n   *  if not. An exception is __not__ thrown if the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#verify}\n   */\n  check(value) {\n    if (this.$values.indexOf(value) >= 0) {\n      return value;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Validates a value as being in this enumeration. Throws an exception if the value\n   *  is not in this enumeration, unless `silent` is true.\n   * @method rtvref.Enumeration#verify\n   * @param {*} value Value to check. Cannot be undefined.\n   * @param {boolean} [silent=false] If truthy, returns `undefined` instead of throwing\n   *  an exception if the specified value is not in this enumeration.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined` if\n   *  `silent` is true and the value is not in this enumeration.\n   * @throws {Error} If not `silent` and the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#check}\n   */\n  verify(value, silent) {\n    const result = this.check(value);\n\n    if (result === undefined && !silent) {\n      throw new Error('Invalid value for enum[' + this.$values.join(', ') + ']: ' + value);\n    }\n\n    return result;\n  }\n\n  /**\n   * A string representation of this Enumeration.\n   * @method rtvref.Enumeration#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    const pairs = Object.keys(this).map((k) => [k, this[k]]);\n    return `{rtvref.Enumeration pairs=[${pairs.map((p) => `[${p}]`).join(', ')}]}`;\n  }\n}\n","//// Qualifier Definitions \\\\\\\\\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Qualifiers</h2>\n * @namespace rtvref.qualifiers\n */\n\n/**\n * Required qualifier: Property _must_ exist and be of the expected type.\n *  Depending on the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, and does not\n *  allow its value to be `null` or `undefined`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.REQUIRED\n * @const {string}\n * @see {@link rtvref.types}\n */\nexport const REQUIRED = '!';\n\n/**\n * Expected qualifier: Property _should_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _requires_ the\n *  property to be defined _somewhere_ within the prototype chain, does not allow\n *  its value to be `undefined`, but does _allow_ its value to be `null`.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.EXPECTED\n * @const {string}\n * @see {@link rtvref.types}\n */\nexport const EXPECTED = '+';\n\n/**\n * Optional qualifier: Property _may_ exist and be of the expected type.\n *  Depending on the type, some requirements may not be enforced (i.e. less so\n *  than with the `EXPECTED` qualifier).\n *\n * Unless otherwise stated in type-specific rules, this qualifier _allows_ a\n *  property value to be `null` as well as `undefined`, and does _not_ require\n *  the property to be defined anywhere in the prototype chain. If the property\n *  is defined, then it is treated as an `EXPECTED` value.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.OPTIONAL\n * @const {string}\n * @see {@link rtvref.types}\n */\nexport const OPTIONAL = '?';\n\n//\n// ^^^^^^^ INSERT NEW TYPES ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.qualifiers qualifiers}.\n * @name rtvref.qualifiers.qualifiers\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration({\n  REQUIRED,\n  EXPECTED,\n  OPTIONAL\n});\n","//// Validation Module \\\\\\\\\n\nimport {default as _isArray} from 'lodash/isArray';\nimport {default as _isSymbol} from 'lodash/isSymbol';\nimport {default as _isFunction} from 'lodash/isFunction';\nimport {default as _isObject} from 'lodash/isObject';\nimport {default as _isObjectLike} from 'lodash/isObjectLike';\nimport {default as _isMap} from 'lodash/isMap';\nimport {default as _isWeakMap} from 'lodash/isWeakMap';\nimport {default as _isSet} from 'lodash/isSet';\nimport {default as _isWeakSet} from 'lodash/isWeakSet';\nimport {default as _isRegExp} from 'lodash/isRegExp';\n\nimport qualifiers from './qualifiers';\n\n/**\n * RTV Validation Module\n * @private\n * @namespace rtv.validation\n */\n\n/**\n * Determines if a value is _anything_.\n * @function rtv.validation.isAny\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.ANY}\n */\nexport const isAny = function(v) {\n  return true; // anything goes, even undefined and null\n};\n\n/**\n * Determines if a value is a string literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new String('value')`, which is an object that is a string.\n * @function rtv.validation.isString\n * @param {*} v Value to validate.\n * @param {boolean} [emptyOK=false] If truthy, an empty string is allowed.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.STRING}\n */\nexport const isString = function(v, emptyOK) {\n  return !!((typeof v === 'string') && (emptyOK || v));\n};\n\n/**\n * Determines if a value is a boolean literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Boolean(true)`, which is an object that is a boolean.\n * @function rtv.validation.isBoolean\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.BOOLEAN}\n */\nexport const isBoolean = function(v) {\n  return (v === true || v === false);\n};\n\n/**\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n * @function rtv.validation.isNumber\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.NUMBER}\n */\nexport const isNumber = function(v) {\n  return (typeof v === 'number');\n};\n\n/**\n * Determines if a value is a symbol.\n * @function rtv.validation.isSymbol\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.SYMBOL}\n */\nexport const isSymbol = _isSymbol;\n\n/**\n * Determines if a value is a function.\n * @function rtv.validation.isFunction\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.SYMBOL}\n */\nexport const isFunction = _isFunction;\n\n/**\n * Determines if a value is an array.\n * @function rtv.validation.isArray\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.ARRAY}\n */\nexport const isArray = _isArray;\n\n/**\n * Determines if a value is a map.\n * @function rtv.validation.isMap\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.MAP}\n */\nexport const isMap = _isMap;\n\n/**\n * Determines if a value is a weak map.\n * @function rtv.validation.isWeakMap\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const isWeakMap = _isWeakMap;\n\n/**\n * Determines if a value is a set.\n * @function rtv.validation.isSet\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.SET}\n */\nexport const isSet = _isSet;\n\n/**\n * Determines if a value is a weak set.\n * @function rtv.validation.isWeakSet\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.WEAK_SET}\n */\nexport const isWeakSet = _isWeakSet;\n\n/**\n * Determines if a value is a regular expression object.\n * @function rtv.validation.isRegExp\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.REGEXP}\n */\nexport const isRegExp = _isRegExp;\n\n/**\n * Determines if a value is a JavaScript {@link rtvref.types.primitives primitive}.\n * @function rtv.validation.isPrimitive\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport const isPrimitive = function(v) {\n  return v === undefined ||\n      v === null ||\n      isString(v, true) || // empty strings are still strings in this case\n      isBoolean(v) ||\n      isNumber(v) ||\n      isSymbol(v);\n};\n\n/**\n * Determines if a value is _any_ type of object except a primitive.\n * @function rtv.validation.isAnyObject\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport const isAnyObject = _isObject;\n\n/**\n * Determines if a value is an object that extends from `JavaScript.Object` and\n *  is not a function, array, regex, map, weak map, set, weak set, or primitive.\n * @function rtv.validation.isObject\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport const isObject = function(v) {\n  return _isObjectLike(v) && // excludes primitives and functions\n      !isArray(v) && // excludes arrays which are otherwise object-like (typeof [] === 'object')\n      !isMap(v) && !isWeakMap(v) && // excludes weak/maps\n      !isSet(v) && !isWeakSet(v) && // excludes weak/sets\n      !isRegExp(v); // excludes regex\n};\n\n/**\n * Determines if a value is a typeset.\n * @function rtv.validation.isValidTypeset\n * @param {*} v Value to validate.\n * @param {boolean} [fullyQualified=false] If truthy, the typeset must be fully-qualified.\n * @param {boolean} [deep=false] If truthy, deeply-validates any nested typesets.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.typeset}\n */\nexport const isTypeset = function(v, fullyQualified, deep) {\n  let valid = isObject(v) || isString(v) || isFunction(v) || (isArray(v) && v.length > 0);\n\n  if (valid && fullyQualified) {\n    // TODO this needs MUCH more work/refinement...\n    valid = isArray(v) && v.length > 1 && !!qualifiers.check(v[0]);\n  }\n\n  return valid;\n};\n","//// Type Definitions \\\\\\\\\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Types</h2>\n * @namespace rtvref.types\n */\n\n/**\n * <h3>Primitives</h3>\n *\n * In RTV.js (as in {@link https://developer.mozilla.org/en-US/docs/Glossary/Primitive ECMAScript 2015}),\n *  a _primitive_ is considered one of the following types:\n *\n * - `undefined`\n * - `null`\n * - `string` (note that `new String('s')` does not produce a _primitive_, it\n *   produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `boolean` (note that `new Boolean(true)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `number` (note that `new Number(1)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `Symbol`\n *\n * @namespace rtvref.types.primitives\n */\n\n/**\n * <h3>Rules Per Qualifiers</h3>\n *\n * {@link rtvref.qualifiers Qualifiers} state basic rules. Unless otherwise stated,\n *  every type herein abides by those basic rules. Each type will also impose\n *  additional rules specific to the type of value it represents.\n *\n * For example, while the {@link rtvref.types.FINITE FINITE} type states that the\n *  value must not be `NaN`, `+Infinity`, nor `-Infinity`; it could be `null` if\n *  the qualifier used is `EXPECTED`; and it could be `undefined` if the qualifier\n *  used is `OPTIONAL`.\n *\n * @namespace rtvref.types.rules\n */\n\n/**\n * <h3>Type Arguments</a></h3>\n *\n * Some types will accept, or may even expect, one or more arguments. Each type\n *  will specify whether it has arguments, and if they're optional or required.\n *  Arguments are specified as a single object immediately following a type in an\n *  __Array__ {@link rtvref.types.typeset typeset} (i.e. an Array must be used as\n *  the typeset in order to provide arguments for a type).\n *\n * If a type does not accept any arguments, but an arguments object is provided,\n *  it will simply be ignored (i.e. it will __not__ be treated as a nested\n *  {@link rtvref.shape_descriptor shape descriptor}). This means that, in an\n *  `Array`-style {@link rtvref.types.typeset typeset}, a shape descriptor\n *  __must__ always be qualified by a type, even if it's the default type\n *  attributed to a shape descriptor.\n *\n * An arguments object immediately follows its type in a typeset, such as\n *  `[PLAIN_OBJECT, {hello: STRING}]`. This would specify the value must be a\n *  {@link rtvref.types.PLAIN_OBJECT plain object} with a shape that includes a\n *  property named 'hello', that property being a\n *  {@link rtvref.qualifiers.REQUIRED required} {@link rtvref.types.STRING string}.\n *\n * @typedef {Object} rtvref.types.type_arguments\n */\n\n/**\n * <h3>Collection Descriptor</h3>\n *\n * Describes the keys and values in a collection-based object, which is one of\n *  the following types:\n *\n * - {@link rtvref.types.MAP_OBJECT MAP_OBJECT}\n * - {@link rtvref.types.MAP MAP}\n * - {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * - {@link rtvref.types.SET SET} (with some exceptions)\n * - {@link rtvref.types.WEAK_SET WEAK_SET} (with some exceptions)\n *\n * Note that an {@link rtvref.types.ARRAY ARRAY} is __not__ included in this list\n *  because the array type has special syntax for describing the type of its items.\n *  See {@link rtvref.types.ARRAY_args ARRAY_args} instead.\n *\n * For example, the following descriptors both verify a collection of 3-letter\n *  string keys (upper- or lowercase) to finite numbers:\n *\n * - `{keyExp: '[a-z]{3}', keyExpFlags: 'i', values: rtv.t.FINITE}`\n * - `{keyExp: '[a-zA-Z]{3}', values: rtv.t.FINITE}`\n *\n * @typedef {Object} rtvref.types.collection_descriptor\n * @property {rtvref.types.typeset} [keys] Optional. A typeset describing each key\n *  in the collection.\n *\n * The type of collection being described may restrict the types that this typeset\n *  can include. For example, the {@link rtvref.types.MAP_OBJECT MAP_OBJECT} collection\n *  only supports the {@link rtvref.types.STRING STRING} type due to the nature of\n *  its JavaScript `Object`-based implementation.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {string} [keyExp] Optional. A string-based regular expression\n *  describing the names of keys (own-enumerable properties) found in the\n *  collection.\n *\n * By default, there are no restrictions on key names. This expression is only\n *  used if the `keys` typeset includes the {@link rtvref.types.STRING STRING} type.\n *\n * For example, to require numerical keys, the following expression could be\n *  used: `'^\\\\d+$'`.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {string} [keyExpFlags] Optional. A string specifying any flags to use\n *  with the regular expression specified in `keyExp`. If this property is _falsy_,\n *  default `RegExp` flags will be used. Ignored if `keyExp` is not specified, or\n *  does not apply per the `keys` typeset.\n *\n * NOTE: This property is ignored when the collection is a {@link rtvref.types.SET SET}\n *  or a {@link rtvref.types.WEAK_SET WEAK_SET} because sets do not have keys.\n *\n * @property {rtvref.types.typeset} [values] Optional. A typeset describing each value\n *  in the collection. Defaults to the {@link rtvref.types.ANY ANY} type which allows\n *  _anything_. All values must match this typeset (but the collection is not\n *  required to have any entries/properties to be considered valid, unless\n *  `count` is specified).\n *\n * For example, to require arrays of non-empty string values, the following\n *  typeset could be used: `[[types.STRING]]`.\n *\n * @property {number} [count=-1] Optional. The number of entries expected in\n *  the collection. A negative value allows for any number of entries. Zero\n *  requires an empty collection.\n *\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n * @see {@link rtvref.types.SET}\n * @see {@link rtvref.types.WEAK_SET}\n */\n\n/**\n * <h3>Typeset</h3>\n *\n * Describes the possible types for a given value. It can be any one of the following\n *  JavaScript types:\n *\n * - `Object`: For the root or a nested {@link rtvref.shape_descriptor shape descriptor}\n *   of _implied_ {@link rtvref.types.OBJECT OBJECT} type (unless qualified with a specific\n *   object type like {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, for example, when\n *   using the `Array` notation, e.g. `[PLAIN_OBJECT, {...}]`). If the object is empty\n *   (has no properties), nothing will be verified (anything will pass).\n * - `String`: For a single type, such as {@link rtvref.types.FINITE 'FINITE'}\n *   for a finite number. Must be one of the types defined in {@link rtvref.types}.\n * - `Function`: For a {@link rtvref.types.property_validator property validator}\n *   that will verify the value of the property using custom code. Only one validator\n *   can be specified for a given typeset, and it will only be called if the value\n *   was verified against at least one of the other types listed (regardless of the\n *   validator function's position when specified in a typeset array). If no other types\n *   were listed (i.e. using the `Array` form, as described above), then the validator\n *   is called immediately.\n * - `Array`: For multiple type possibilities, optionally {@link rtvref.qualifiers qualified},\n *   using an __OR__ conjunction, which means the value of the property being described must\n *   be at _least one_ of the types listed, but not all. Matching is done in a short-circuit\n *   fashion, from the first to the last element in the typeset. If a simpler type is\n *   likely, it's more performant to specify those first in the typeset to avoid a match\n *   attempt on a nested shape or Array.\n *   - Cannot be an empty Array.\n *   - An Array is necessary to {@link rtvref.qualifiers qualify} the typeset as not\n *     required (see _Typeset Qualifiers_ below).\n *   - An Array is also necessary if a type needs or requires\n *     {@link rtvref.types.type_arguments arguments}.\n *   - If the first element is an `Object`, it's treated as a nested\n *     {@link rtvref.shape_descriptor shape descriptor} describing an object of the\n *     default `OBJECT` type. To include a shape descriptor at any other position\n *     within the array, it __must__ be preceded by a type, even if the default\n *     `OBJECT` type is being used (i.e. `OBJECT` must be specified as the type).\n *   - If the first element is an `Array`, it's treated as a nested list with an\n *     implied `ARRAY` type, e.g. `[BOOLEAN, [STRING, FINITE]]` would describe a\n *     property that should be a boolean, or an array of non-empty strings or finite\n *     numbers.\n *   - If the first element is a `Function`, it's treated as a property validator.\n *\n * <h4>Typeset Qualifiers</h4>\n *\n * All typesets use an _implied_ {@link rtvref.qualifiers.REQUIRED required}\n *  qualifier unless otherwise specified. To qualify a typeset, a\n *  {@link rtvref.qualifiers qualifier} may be specified as the __first__ element\n *  in the `Array` form (if specified, it must be the first element). For example,\n *  `{note: [EXPECTED, STRING]}` would describe an object with a 'note' property\n *  that is an expected, but not required, string, which could therefore be either\n *  empty or even `null`. The `Array` form must be used in order to qualify a\n *  typeset as other than required, and the qualifier applies to all immediate\n *  types in the typeset (which means each nested typeset can have its own qualifier).\n *\n * <h4>Example: Object</h4>\n *\n * <pre><code>const contactShape = {\n *   name: rtv.t.STRING, // required, non-empty, string\n *   tags: [rtv.t.ARRAY, [rtv.t.STRING]], // required array of non-empty strings\n *   // tags: [[rtv.t.STRING]], // same as above, but using shortcut array format\n *   details: { // required nested object of type `rtv.t.OBJECT` (default)\n *     birthday: [rtv.q.EXPECTED, rtv.t.DATE] // Date (could be null)\n *   },\n *   notes: [rtv.q.OPTIONAL, rtv.t.STRING, function(value) { // optional string...\n *     return !value || value.length < 500; // ...less than 500 characters long, if specified\n *   }]\n * };\n *\n * const contact = {\n *   name: 'John Doe',\n *   tags: ['colleagues', 'sports'],\n *   details: {\n *     birthday: null // not specified\n *   }\n * };\n *\n * rtv.verify(contact, contactShape); // OK\n *\n * const walletShape = {\n *   contacts: [[contactShape]], // list of contacts using nested shape\n *   address: {\n *     street: rtv.t.STRING\n *     // ...\n *   },\n *   money: rtv.t.FINITE\n * };\n *\n * rtv.verify({\n *   contacts: [contact],\n *   address: {street: '123 Main St'},\n *   money: 100\n * }, walletShape); // OK\n * </code></pre>\n *\n * <h4>Example: String</h4>\n *\n * <pre><code>rtv.verify('foo', rtv.t.STRING); // OK\n * rtv.verify('foo', rtv.t.FINITE); // ERROR\n * </code></pre>\n *\n * <h4>Example: Array</h4>\n *\n * <pre><code>const typeset = [rtv.t.STRING, rtv.t.FINITE]; // non-empty string, or finite number\n * rtv.verify('foo', typeset); // OK\n * rtv.verify(1, typeset); // OK\n * </code></pre>\n *\n * <h4>Example: Function</h4>\n *\n * <pre><code>rtv.verify(123, (v) => v > 100); // OK\n * rtv.verify('123', [rtv.t.STRING, (v) => parseInt(v) > 100); // OK\n * </code></pre>\n *\n * <h4>Example: Alternate Qualifier</h4>\n *\n * <pre><code>const person = {\n *   name: rtv.t.STRING, // required, non-empty\n *   age: [rtv.q.OPTIONAL, rtv.t.FINITE, (v) => v >= 18] // 18 or older, if specified\n * };\n * rtv.verify({name: 'Bob'}, person); // OK\n * rtv.verify({name: ''}, person); // ERROR\n * rtv.verify({name: 'Steve', age: 17}, person); // ERROR\n * rtv.verify({name: 'Steve', age: null}, person); // OK\n * </code></pre>\n *\n * @typedef {(Object|string|Array|Function)} rtvref.types.typeset\n */\n\n/**\n * <h3>Fully-Qualified Typeset</h3>\n *\n * A {@link rtvref.types.typeset typeset} expressed without any shortcut notations\n *  to make it easier to parse, especially as the `match` parameter given to a\n *  {@link rtvref.types.property_validator property validator}.\n *\n * For example:\n *\n * - `STRING` -> `[REQUIRED, STRING]`\n * - `{note: STRING}` -> `[REQUIRED, OBJECT, {note: [REQUIRED, STRING]}]`\n * - `[[FINITE]]` -> `[REQUIRED, ARRAY, [REQUIRED, FINITE]]`\n *\n * @typedef {Array} rtvref.types.fully_qualified_typeset\n */\n\n/**\n * <h3>Property Validator</h3>\n *\n * A function used as a {@link rtvref.types.typeset typeset}, or as a subset to\n *  a typeset, to provide custom verification of the value being verified.\n *\n * A typeset may only have one validator, and the validator is only called if\n *  the value being verified was verified by at least one type in the typeset.\n *  The position of the validator within the typeset (if the typeset is an array),\n *  does not change when the validator is invoked (i.e. before one type or after\n *  another; it's always called last, if called at all).\n *\n * There is one disadvantage to using a property validator: It cannot be de/serialized\n *  via JSON, which means it cannot be transmitted or persisted. One option would be\n *  to customize the de/serialization to JSON by serializing the validator to a\n *  special object with properties that would inform the deserialization process\n *  on how to reconstruct the validator dynamically.\n *\n * @typedef {function} rtvref.types.property_validator\n * @param {*} value The value being verified.\n * @param {Array} match A __first-level__, {@link rtvref.types.fully_qualified_typeset fully-qualified}\n *  typeset describing the type that matched. This means the first level of this\n *  subset of `typeset` (the 3rd parameter) is fully-qualified, but any nested\n *  {@link rtvref.shape_descriptor shape descriptors} or arrays will not be (they\n *  will remain references to the same shapes/arrays in `typeset`). For example,\n *  if the given typeset was `[PLAIN_OBJECT, {note: STRING}]`, this parameter\n *  would be a new typeset array `[REQUIRED, PLAIN_OBJECT, {note: STRING}]`,\n *  and the `typeset` parameter would be the original `[PLAIN_OBJECT, {note: STRING}]`.\n * @param {rtvref.types.typeset} typeset Reference to the typeset used for\n *  verification. Note that the typeset may contain nested typeset(s), and may\n *  be part of a larger parent typeset (though there would be no reference to\n *  the parent typeset, if any). This typeset is as it was specified in the\n *  parent shape, and therefore it may not be fully-qualified.\n * @returns {boolean} `true` to verify the value, `false` to reject it.\n */\n\n/**\n * The any type is special in that it allows _anything_, which includes `null`\n *  and `undefined` values. Because of this, it's the most liberal in terms of\n *  types as well as qualifiers. A more specific type should be used whenever\n *  possible to ensure a higher degree of confidence in the value being validated.\n *\n * Any rules per qualifiers:\n *\n * - REQUIRED: Property must be defined _somewhere_ in the prototype chain, but\n *   its value can be anything, including `null` and `undefined`.\n * - EXPECTED: Same rules as REQUIRED.\n * - OPTIONAL: Since this qualifier removes the property's need for existence\n *   in the prototype chain, it renders the verification moot (i.e. the property\n *   might as well not be included in the {@link rtvref.shape_descriptor shape descriptor}\n *   unless a {@link rtvref.types.property_validator property validator} is being\n *   used to do customized verification.\n *\n * @name rtvref.types.ANY\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const ANY = 'any';\n\n// TODO[future]: Add 'exp: string' and 'expFlags: string' args (strings because of JSON requirement...)\n//  for a regular expression test. Similar prop names to collection_descriptor.\n/**\n * {@link rtvref.types.STRING STRING} arguments.\n * @typedef {Object} rtvref.types.STRING_args\n * @property {string} [exact] An exact value to match.\n * @property {number} [min] Minimum length. Defaults to 1 for a `REQUIRED` string,\n *  and 0 for an `EXPECTED` or `OPTIONAL` string. Ignored if `exact` is specified.\n * @property {number} [max=-1] Maximum length. -1 means no maximum. Ignored if `exact`\n *  is specified.\n * @property {string} [partial] A partial value to match (must be somewhere within the string).\n *  Ignored if `exact` is specified.\n * @see {@link rtvref.qualifiers}\n */\n\n/**\n * String rules per qualifiers:\n *\n * - REQUIRED: Must be a non-empty string.\n * - EXPECTED | OPTIONAL: Can be an empty string.\n *\n * In all cases, the value must be a string {@link rtvref.types.primitives primitive}.\n *  `new String('hello') !== 'hello'` because the former is an _object_, not a string.\n *\n * Arguments (optional): {@link rtvref.types.STRING_args}\n *\n * @name rtvref.types.STRING\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const STRING = 'string';\n\n/**\n * Boolean rules per qualifiers: Must be a boolean {@link rtvref.types.primitives primitive}.\n *  `new Boolean(true) !== true` because the former is an _object_, not a boolean.\n *\n * @name rtvref.types.BOOLEAN\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const BOOLEAN = 'boolean';\n\n/**\n * Symbol rules per qualifiers: Must be a symbol {@link rtvref.types.primitives primitive}.\n * @name rtvref.types.SYMBOL\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const SYMBOL = 'symbol';\n\n/**\n * Numeric value arguments. Applies to all numeric types.\n * @typedef {Object} rtvref.types.numeric_args\n * @property {string} [exact] An exact value to match.\n * @property {number} [min] Minimum inclusive value. Default varies per type.\n *  Ignored if `exact` is specified.\n * @property {number} [max] Maximum inclusive value. Default varies per type.\n *  Ignored if `exact` is specified.\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.NUMBER}\n * @see {@link rtvref.types.FINITE}\n * @see {@link rtvref.types.INT}\n * @see {@link rtvref.types.FLOAT}\n */\n\n/**\n * Number rules per qualifiers:\n *\n * - REQUIRED: Cannot be `NaN`, but could be `+Infinity`, `-Infinity`.\n * - EXPECTED | OPTIONAL: Could be `NaN`, `+Infinity`, `-Infinity`.\n *\n * In all cases, the value must be a number {@link rtvref.types.primitives primitive}.\n *  `new Number(1) !== 1` because the former is an _object_, not a number.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.NUMBER\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.FINITE}\n */\nexport const NUMBER = 'number';\n\n/**\n * Finite rules per qualifiers: Cannot be `NaN`, `+Infinity`, `-Infinity`. The\n *  value can be either a safe integer or a {@link rtvref.types.FLOAT floating point number}.\n *  It must also be a number {@link rtvref.types.primitives primitive}.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.FINITE\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.NUMBER}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n */\nexport const FINITE = 'finite';\n\n/**\n * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} integer,\n *  but is not necessarily _safe_. It must also be a number {@link rtvref.types.primitives primitive}.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.INT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.FINITE}\n * @see {@link rtvref.types.FLOAT}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger Number.isSafeInteger()}\n */\nexport const INT = 'int';\n\n/**\n * Float rules per qualifiers: Must be a finite floating point number.\n *  It must also be a number {@link rtvref.types.primitives primitive}.\n *\n * Arguments (optional): {@link rtvref.types.numeric_args}\n *\n * @name rtvref.types.FLOAT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.INT}\n */\nexport const FLOAT = 'float';\n\n/**\n * Function rules per qualifiers: Must be a `function`.\n * @name rtvref.types.FUNCTION\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const FUNCTION = 'function';\n\n/**\n * RegExp rules per qualifiers: Must be a `RegExp` instance.\n * @name rtvref.types.REGEXP\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n */\nexport const REGEXP = 'regexp';\n\n/**\n * Date rules per qualifiers: Must be a `Date` instance.\n * @name rtvref.types.DATE\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n */\nexport const DATE = 'date';\n\n/**\n * Error rules per qualifiers: Must be an `Error` instance.\n * @name rtvref.types.ERROR\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n */\nexport const ERROR = 'error';\n\n/**\n * Promise rules per qualifiers: Must be a `Promise` instance.\n * @name rtvref.types.PROMISE\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\nexport const PROMISE = 'promise';\n\n// TODO[future]: Short-hand 'exact' with `[ARRAY, 2, [STRING]]` or `[2, [STRING]]` syntax?\n/**\n * {@link rtvref.types.ARRAY ARRAY} arguments.\n * @typedef {Object} rtvref.types.ARRAY_args\n * @property {number} [exact] Exact length.\n * @property {number} [min=0] Minimum length. Ignored if `exact` is specified.\n * @property {number} [max=-1] Maximum length. -1 means no maximum. Ignored if\n *  `exact` is specified.\n */\n\n/**\n * Array rules per qualifiers: Must be an `Array`. Empty arrays are permitted by\n *  default.\n *\n * Arguments (optional): {@link rtvref.types.ARRAY_args}\n *\n * @name rtvref.types.ARRAY\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const ARRAY = 'array';\n\n/**\n * An _any_ object is anything that is __not__ a {@link rtvref.types primitive}, which\n *  means it includes the `Array` type, as well as functions and arguments, and\n *  other JavaScript _object_ types. To test for an array, use the\n *  {@link rtvref.types.ARRAY ARRAY} type. To test for a function, use the\n *  {@link rtvref.types.FUNCTION FUNCTION} type.\n *\n * The following values are considered any objects:\n *\n * - `{}`\n * - `new Object()`\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n * - `arguments` (function arguments)\n * - `new function() {}` (class instance) (also see {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT})\n * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n * - `new Set()` (also see {@link rtvref.types.SET SET})\n * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n *\n * {@link rtvref.types.primitives Primitive} values __are not__ considered any objects,\n *  especially when the qualifier is {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n *  Note that `typeof null === 'object'` in JavaScript; the `ANY_OBJECT` type\n *  allows testing for this undesirable fact.\n *\n * Any object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.shape_descriptor}\n *\n * @name rtvref.types.ANY_OBJECT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const ANY_OBJECT = 'anyObject';\n\n/**\n * An object is one that extends from `JavaScript.Object` (i.e. an _instance_\n *  of _something_ that extends from Object) and is not a\n *  {@link rtvref.types.FUNCTION function}, {@link rtvref.types.ARRAY array},\n *  {@link rtvref.types.REGEXP regular expression}, function arguments object,\n *  {@link rtvref.types.MAP map}, {@link rtvref.types.WEAK_MAP weak map},\n *  {@link rtvref.types.SET set}, {@link rtvref.types.WEAK_SET weak set}, nor a\n *  {@link rtvref.types primitive}.\n *\n * This is the __default__ (imputed) type for\n *  {@link rtvref.shape_descriptor shape descriptors}, which means the object itself\n *  (the value being tested), prior to being checked against its shape, will be\n *  tested according to this type.\n *\n * The following values are considered objects:\n *\n * - `{}`\n * - `new Object()`\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `new function() {}` (class instance)\n *\n * The following values __are not__ considered objects:\n *\n * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n * - `arguments` (function arguments)\n * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n * - `new Set()` (also see {@link rtvref.types.SET SET})\n * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n * - all {@link rtvref.types.primitives primitives}\n *\n * Object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.shape_descriptor}\n *\n * @name rtvref.types.OBJECT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const OBJECT = 'object';\n\n/**\n * A _plain_ object is one that is created directly from the `Object` constructor,\n *  whether using `new Object()` or the literal `{}`.\n *\n * The following values are considered plain objects:\n *\n * - `{}`\n * - `new Object()`\n *\n * The following values __are not__ considered plain objects:\n *\n * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `new function() {}` (class instance)\n * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n * - `arguments` (function arguments)\n * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n * - `new Set()` (also see {@link rtvref.types.SET SET})\n * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n * - all {@link rtvref.types.primitives primitives}\n *\n * Plain object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.shape_descriptor}\n *\n * @name rtvref.types.PLAIN_OBJECT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const PLAIN_OBJECT = 'plainObject';\n\n/**\n * {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} arguments.\n * @typedef {Object} rtvref.types.CLASS_OBJECT_args\n * @property {function} [ctr] A reference to a constructor function. If specified,\n *  the class object (instance) must have this class function in its inheritance\n *  chain such that `<class_object> instanceof <function> === true`. Note that\n *  this property is not serializable to JSON.\n * @property {rtvref.shape_descriptor} [shape] A description of the class object's\n *  shape.\n */\n\n/**\n * A _class_ object is one that is created by invoking the `new` operator on a\n *  function (other than a primitive type function), generating a new object,\n *  commonly referred to as a _class instance_. This object's prototype\n *  (`__proto__`) is a reference to that function's `prototype` and has a\n *  `constructor` property that is `===` to the function.\n *\n * The following values are considered class objects:\n *\n * - `new function() {}`\n *\n * The following values __are not__ considered class objects:\n *\n * - `{}`\n * - `new Object()`\n * - `new String('')`\n * - `new Boolean(true)`\n * - `new Number(1)`\n * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n * - `arguments` (function arguments)\n * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n * - `new Set()` (also see {@link rtvref.types.SET SET})\n * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n * - all {@link rtvref.types.primitives primitives}\n *\n * Class object rules per qualifiers:\n *\n * - REQUIRED: Per the lists above.\n * - EXPECTED: `null` is allowed.\n * - OPTIONAL: `undefined` is allowed.\n *\n * Arguments (optional): {@link rtvref.types.CLASS_OBJECT_args}\n *\n * @name rtvref.types.CLASS_OBJECT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.MAP_OBJECT}\n */\nexport const CLASS_OBJECT = 'classObject';\n\n/**\n * A _map_ object is an {@link rtvref.types.OBJECT OBJECT} that is treated as a\n *  hash map with an expected set of keys and values. Keys can be described\n *  using a regular expression, and values can be described using a\n *  {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n *\n * Map object rules per qualifiers: Same as {@link rtvref.types.OBJECT OBJECT} rules.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.MAP_OBJECT\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.ANY_OBJECT}\n * @see {@link rtvref.types.OBJECT}\n * @see {@link rtvref.types.PLAIN_OBJECT}\n * @see {@link rtvref.types.CLASS_OBJECT}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const MAP_OBJECT = 'mapObject';\n\n/**\n * JSON rules per qualifiers: Must be a JSON value:\n *\n * - {@link rtvref.types.STRING string}, however __empty strings are permitted__,\n *   even if the qualifier is `REQUIRED`;\n * - {@link rtvref.types.BOOLEAN boolean};\n * - {@link rtvref.types.FINITE finite number};\n * - {@link rtvref.types.PLAIN_OBJECT plain object};\n * - {@link rtvref.types.ARRAY array};\n * - `null`\n *\n * Since this type checks for _any_ valid JSON value, empty string and `null`\n *  values are permitted, even when the typeset is qualified as `REQUIRED`.\n *  Therefore, the `REQUIRED` qualifier has the same effect as the `EXPECTED`\n *  qualifier.\n *\n * @name rtvref.types.JSON\n * @const {string}\n * @see {@link rtvref.qualifiers}\n */\nexport const JSON = 'json';\n\n/**\n * An ES6 map supports any object as its keys, unlike a\n *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n *  be described using a regular expression (if they are strings), and values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted\n *  by default.\n *\n * Map rules per qualifiers: Must be a `Map` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.MAP\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.WEAK_MAP}\n */\nexport const MAP = 'map';\n\n/**\n * An ES6 weak map supports any object as its keys, unlike a\n *  {@link rtvref.types.MAP_OBJECT MAP_OBJECT} that only supports strings. Keys can\n *  be described using a regular expression (if they are strings), and values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted\n *  by default.\n *\n * Weak map rules per qualifiers: Must be a `WeakMap` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.WEAK_MAP\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.MAP_OBJECT}\n * @see {@link rtvref.types.MAP}\n */\nexport const WEAK_MAP = 'weakMap';\n\n/**\n * An ES6 set is a collection of _unique_ values without associated keys. Values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted\n *  by default.\n *\n * Set rules per qualifiers: Must be a `Set` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.SET\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.WEAK_SET}\n */\nexport const SET = 'set';\n\n/**\n * An ES6 weak set is a collection of _unique_ values without associated keys. Values can\n *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted\n *  by default.\n *\n * Weak set rules per qualifiers: Must be a `WeakSet` instance.\n *\n * Arguments (optional): {@link rtvref.types.collection_descriptor}\n *\n * @name rtvref.types.WEAK_SET\n * @const {string}\n * @see {@link rtvref.qualifiers}\n * @see {@link rtvref.types.SET}\n */\nexport const WEAK_SET = 'weakSet';\n\n//\n// ^^^^^^^ INSERT NEW TYPES ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.types types}.\n * @name rtvref.types.types\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration({\n  ANY,\n  STRING,\n  BOOLEAN,\n  SYMBOL,\n  NUMBER,\n  FINITE,\n  INT,\n  FLOAT,\n  FUNCTION,\n  REGEXP,\n  DATE,\n  ERROR,\n  PROMISE,\n  ARRAY,\n  ANY_OBJECT,\n  OBJECT,\n  PLAIN_OBJECT,\n  CLASS_OBJECT,\n  MAP_OBJECT,\n  JSON,\n  MAP,\n  WEAK_MAP,\n  SET,\n  WEAK_SET\n});\n","//// Main Implementation Module \\\\\\\\\n\nimport {isString, isBoolean} from './validation';\nimport types from './types';\n\n/**\n * RTV Implementation Module\n * @private\n * @namespace rtv.impl\n */\n\n// TODO\n// const fullyQualify = function(typeset) {\n//   if (!isTypeset(typeset)) {\n//     throw new Error(`Invalid typeset=${typeset}`);\n//   }\n\n//   const fqts = [];\n\n//   if (isArray(typeset)) {\n//     if (!qualifiers.check(typeset[0])) {\n//       fqts.push(qualifiers.REQUIRED, ...typeset); // TODO this needs serious TLC...\n//     }\n//   } else {\n//     fqts.push(qualifiers.REQUIRED, typeset); // TODO this needs serious TLC...\n//   }\n\n//   return fqts;\n// };\n\n/**\n * Checks a value against a simple type.\n * @function rtv.impl.checkSimple\n * @param {*} value Value to check.\n * @param {string} typeset Simple typeset name, must be one of {@link rtvref.types.types}.\n * @returns {(boolean|rtvref.RtvError)}\n * @throws {Error} If `typeset` is not a valid type name.\n */\nconst checkSimple = function(value, typeset) {\n  types.verify(typeset);\n\n  if (typeset === types.STRING) {\n    return isString(value); // TODO return RtvError if fails\n  } else if (typeset === types.BOOLEAN) {\n    return isBoolean(value); // TODO return RtvError if fails\n  }\n\n  throw new Error(`Missing handler for '${typeset}' type`);\n};\n\n/**\n * Checks a value against a shape.\n * @function rtv.impl.check\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} typeset Expected shape/type of the value.\n * @returns {(boolean|rtvref.RtvError)} `true` if the `value` is compliant to the\n *  `typeset`; `RtvError` otherwise. An exception is __not__ thrown if the `value`\n *  is non-compliant.\n * @throws {Error} If `typeset` is not a valid typeset.\n * @see {@link rtv.impl.verify}\n */\nexport const check = function(value, typeset) {\n  // TODO: on check failure (with a valid typeset), return a special RtvError object that\n  //  contains extra properties to indicate what didn't match, what was expected,\n  //  the shape that was checked, the value that was checked, etc.\n  //  If check succeeds, return boolean `true`. rtv.check/verify can then test\n  //  for the return type since impl shouldn't be exposed externally anyway.\n  try {\n    if (isString(typeset)) {\n      return checkSimple(value, typeset);\n    }\n  } catch (checkErr) {\n    const err = new Error(\n        `Cannot check value: shape is not a valid typeset -- rootCause: ${checkErr.message}`);\n    err.rootCause = checkErr;\n    throw err;\n  }\n};\n"],"names":["global","Object","freeSelf","self","freeGlobal","Function","root","Symbol","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","toStringTag","undefined","value","isOwn","call","tag","unmasked","e","result","nullTag","undefinedTag","getRawTag","objectToString","type","asyncTag","funcTag","genTag","proxyTag","uid","isObject","baseGetTag","maskSrcKey","exec","coreJsData","keys","IE_PROTO","func","funcToString","reIsHostCtor","funcProto","reIsNative","RegExp","replace","isMasked","isFunction","test","toSource","object","key","getValue","baseIsNative","getNative","dataViewCtorString","DataView","mapCtorString","Map","promiseCtorString","Promise","setCtorString","Set","weakMapCtorString","WeakMap","getTag","ArrayBuffer","resolve","Ctor","constructor","ctorString","freeExports","exports","nodeType","freeModule","module","freeProcess","process","nodeUtil","binding","isMap","isSet","isRegExp","Enumeration","map","values","length","Error","forEach","indexOf","push","defineProperty","this","concat","$values","silent","check","join","k","_this2","p","isString","v","emptyOK","typeset","verify","types","STRING","BOOLEAN","checkSimple","checkErr","err","message","rootCause","rtv","qualifiers","shape","config","enabled","impl","defineProperties","newValue","t","context"],"mappings":"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"}