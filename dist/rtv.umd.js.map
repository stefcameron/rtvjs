{"version":3,"file":"rtv.umd.js","sources":["../node_modules/lodash/isArray.js","../src/lib/util.js","../src/lib/Enumeration.js","../src/lib/types.js","../src/lib/validation/isArray.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObject.js","../node_modules/lodash/isFunction.js","../node_modules/lodash/_coreJsData.js","../node_modules/lodash/_isMasked.js","../node_modules/lodash/_toSource.js","../node_modules/lodash/_baseIsNative.js","../node_modules/lodash/_getValue.js","../node_modules/lodash/_getNative.js","../node_modules/lodash/_DataView.js","../node_modules/lodash/_Map.js","../node_modules/lodash/_Promise.js","../node_modules/lodash/_Set.js","../node_modules/lodash/_WeakMap.js","../node_modules/lodash/_getTag.js","../node_modules/lodash/_baseIsMap.js","../node_modules/lodash/_baseUnary.js","../node_modules/lodash/_nodeUtil.js","../node_modules/lodash/isMap.js","../src/lib/validation/isMap.js","../node_modules/lodash/isWeakMap.js","../src/lib/validation/isWeakMap.js","../node_modules/lodash/_baseIsSet.js","../node_modules/lodash/isSet.js","../src/lib/validation/isSet.js","../node_modules/lodash/isWeakSet.js","../src/lib/validation/isWeakSet.js","../node_modules/lodash/_baseIsRegExp.js","../node_modules/lodash/isRegExp.js","../src/lib/validation/isRegExp.js","../node_modules/lodash/_baseIsDate.js","../node_modules/lodash/isDate.js","../src/lib/validation/isDate.js","../node_modules/lodash/_overArg.js","../node_modules/lodash/_getPrototype.js","../node_modules/lodash/isPlainObject.js","../node_modules/lodash/isError.js","../src/lib/validation/isError.js","../src/lib/validation/isPromise.js","../src/lib/validation/isObject.js","../src/lib/validation/isString.js","../src/lib/validation/isFunction.js","../src/lib/validation/isBoolean.js","../node_modules/lodash/_arrayEach.js","../node_modules/lodash/_createBaseFor.js","../node_modules/lodash/_baseFor.js","../node_modules/lodash/_baseTimes.js","../node_modules/lodash/_baseIsArguments.js","../node_modules/lodash/isArguments.js","../node_modules/lodash/stubFalse.js","../node_modules/lodash/isBuffer.js","../node_modules/lodash/_isIndex.js","../node_modules/lodash/isLength.js","../node_modules/lodash/_baseIsTypedArray.js","../node_modules/lodash/isTypedArray.js","../node_modules/lodash/_arrayLikeKeys.js","../node_modules/lodash/_isPrototype.js","../node_modules/lodash/_nativeKeys.js","../node_modules/lodash/_baseKeys.js","../node_modules/lodash/isArrayLike.js","../node_modules/lodash/keys.js","../node_modules/lodash/_baseForOwn.js","../node_modules/lodash/_createBaseEach.js","../node_modules/lodash/_baseEach.js","../node_modules/lodash/identity.js","../node_modules/lodash/_castFunction.js","../node_modules/lodash/forEach.js","../src/lib/validation/isShape.js","../src/lib/validation/isTypeArgs.js","../src/lib/validation/isValidator.js","../src/lib/qualifiers.js","../src/lib/validation/isTypeset.js","../src/lib/RtvSuccess.js","../src/lib/RtvError.js","../src/lib/impl.js","../src/lib/validation/isAny.js","../src/lib/validator/valAny.js","../src/lib/validation/isAnyObject.js","../src/lib/validator/valAnyObject.js","../node_modules/lodash/isFinite.js","../src/lib/validation/isFinite.js","../src/lib/validator/valArray.js","../src/lib/validator/valBoolean.js","../src/lib/validation/isPlainObject.js","../src/lib/validation/isClassObject.js","../src/lib/validator/valClassObject.js","../src/lib/validator/valDate.js","../src/lib/validator/valError.js","../src/lib/validator/valFinite.js","../src/lib/validator/valFunction.js","../src/lib/validation/isHashMap.js","../src/lib/validator/valHashMap.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/toFinite.js","../node_modules/lodash/toInteger.js","../node_modules/lodash/isInteger.js","../src/lib/validation/isInt.js","../src/lib/validator/valInt.js","../src/lib/validation/isNull.js","../src/lib/validation/isJson.js","../src/lib/validator/valJson.js","../src/lib/validator/valMap.js","../src/lib/validator/valNull.js","../node_modules/lodash/isNumber.js","../node_modules/lodash/isNaN.js","../src/lib/validation/isNumber.js","../src/lib/validator/valNumber.js","../src/lib/validator/valObject.js","../src/lib/validator/valPlainObject.js","../src/lib/validator/valPromise.js","../src/lib/validator/valRegExp.js","../node_modules/lodash/isSafeInteger.js","../src/lib/validation/isSafeInt.js","../src/lib/validator/valSafeInt.js","../src/lib/validator/valSet.js","../src/lib/validator/valString.js","../src/lib/validation/isSymbol.js","../src/lib/validator/valSymbol.js","../src/lib/validator/valWeakMap.js","../src/lib/validator/valWeakSet.js","../src/rtv.js"],"sourcesContent":["/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","////// Utilities\n\n// NOTE: Ideally, this module has no dependencies. If it must, they should be\n//  third-party/external dependencies to avoid circular dependencies within\n//  this library.\n\n/**\n * RTV Utilities Module\n * @private\n * @namespace rtv.util\n */\n\n/**\n * Pretty-print a value.\n * @function rtv.util.print\n * @param {*} printValue Value to print.\n * @returns {string} Pretty-printed value. It's not perfect and may not catch\n *  all types, but attempts to be good enough.\n */\nexport const print = function(printValue) {\n  // NOTE: key will be undefined when the replacer is called outside of the\n  //  JSON.stringify() call, as well as for the first stringify() call\n  const replacer = function(stringifying, key, value) {\n    if (value === undefined || value === null) {\n      return stringifying ? value : (value + '');\n    }\n\n    if (typeof value === 'string') {\n      return stringifying ? value : `\"${value}\"`;\n    }\n\n    if (typeof value === 'number') { // also catches NaN\n      return stringifying ? value : `${value}`;\n    }\n\n    if (typeof value === 'boolean') {\n      return stringifying ? value : `${value}`;\n    }\n\n    if (typeof value === 'function') {\n      return '<function>';\n    }\n\n    if (typeof value === 'symbol') {\n      return value.toString();\n    }\n\n    return value; // keep stringifying since we're returning an object\n  };\n\n  const result = replacer(false, undefined, printValue);\n\n  if (typeof result === 'string') {\n    return result;\n  }\n\n  return JSON.stringify(result, replacer.bind(null, true)); // recursive\n};\n","////// Enumeration\n\nimport {print} from './util';\n\n/**\n * Simple enumeration type. Own-properties on an instance are the keys in the\n *  specified `map`, with their associated values. Key names cannot start with\n *  \"$\".\n *\n * <pre><code>const state = new Enumeration({\n *   READY: 1,\n *   RUNNING: 2,\n *   STOPPED: 3,\n *   COMPLETE: 4\n * });\n *\n * state.RUNNING; // 2\n * state.verify(3); // 3 (returns the value since found in enumeration)\n * state.verify(5); // ERROR thrown\n * state.check(3); // 3 (same as verify(3) since found in enumeration)\n * state.check(5); // undefined (silent failure)\n * state.$values; // [1, 2, 3, 4] (special non-enumerable own-property)\n * </code></pre>\n *\n * @class rtvref.Enumeration\n * @param {Object.<String,*>} map Object mapping keys to values. Values cannot\n *  be `undefined`.\n * @param {string} [name] Friendly name used to identify this enumeration,\n *  especially in validation error messages.\n * @throws {Error} If `map` is falsy or empty.\n * @throws {Error} If `map` has a key that maps to `undefined`.\n * @throws {Error} If `map` contains a duplicate value.\n * @throws {Error} If `map` has a key that is a restricted property (starts with\n *  \"$\").\n */\nexport default class Enumeration {\n  // JSDoc is provided at the @class level\n  constructor(map, name) {\n    map = map || {};\n\n    const keys = Object.keys(map);\n    const values = [];\n\n    if (keys.length === 0) {\n      throw new Error('map must contain at least one key');\n    }\n\n    // shallow-clone each key in the map into this\n    keys.forEach((key) => {\n      if (key.indexOf('$') === 0) {\n        throw new Error(`map key \"${key}\" cannot start with \"$\"`);\n      }\n\n      if (map[key] === undefined) {\n        throw new Error(`map[${key}] cannot be undefined`);\n      }\n\n      const value = map[key];\n      if (values.indexOf(value) >= 0) {\n        throw new Error(`map[${key}] is a duplicate value: ${print(value)}`);\n      }\n\n      values.push(value);\n      this[key] = value;\n    });\n\n    /**\n     * Friendly name (not necessarily unique among all enumeration instances)\n     *  used to identify this enumeration, especially in validation error\n     *  messages. Empty string if not specified during construction.\n     * @readonly\n     * @name rtvref.Enumeration#$name\n     * @type {string}\n     */\n    Object.defineProperty(this, '$name', {\n      enumerable: false,\n      configurable: true,\n      value: name || ''\n    });\n\n    /**\n     * List of enumeration values. Values are _references_ to values in this\n     *  enumeration.\n     *\n     * Note that this own-property is non-enumerable on purpose. Enumerable\n     *  properties on this instance are the keys in this enumeration.\n     *\n     * @readonly\n     * @name rtvref.Enumeration#$values\n     * @type {Array.<String>}\n     */\n    Object.defineProperty(this, '$values', {\n      enumerable: false,\n      configurable: true,\n      get() {\n        return values.concat(); // shallow clone\n      }\n    });\n  }\n\n  /**\n   * Checks if a value is in this enumeration.\n   * @method rtvref.Enumeration#check\n   * @param {*} value Value to check. Cannot be undefined.\n   * @returns {(*|undefined)} The specified value if it is in this enumeration, or `undefined`\n   *  if not. An exception is __not__ thrown if the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#verify}\n   */\n  check(value) {\n    if (this.$values.indexOf(value) >= 0) {\n      return value;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Validates a value as being in this enumeration. Throws an exception if the value\n   *  is not in this enumeration, unless `silent` is true.\n   * @method rtvref.Enumeration#verify\n   * @param {*} value Value to check. Cannot be undefined.\n   * @param {boolean} [silent=false] If truthy, returns `undefined` instead of throwing\n   *  an exception if the specified value is not in this enumeration.\n   * @returns {*} The specified value if it is in this enumeration, or `undefined` if\n   *  `silent` is true and the value is not in this enumeration.\n   * @throws {Error} If not `silent` and the value is not in this enumeration.\n   * @see {@link rtvref.Enumeration#check}\n   */\n  verify(value, silent) {\n    const result = this.check(value);\n\n    if (result === undefined && !silent) {\n      throw new Error(`Invalid value for ${this.$name ? `${print(this.$name)} ` : ''}enumeration (${this.$values.map(print).join(', ')}): ${print(value)}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * A string representation of this Enumeration.\n   * @method rtvref.Enumeration#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    const pairs = Object.keys(this).map((k) => [k, this[k]]);\n    return `{rtvref.Enumeration $name=${print(this.$name)} pairs=[${pairs.map(print).join(', ')}]}`;\n  }\n}\n","////// Type Definitions\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Types</h2>\n * @namespace rtvref.types\n */\n\n/**\n * <h3>Primitives</h3>\n *\n * In RTV.js (as in {@link https://developer.mozilla.org/en-US/docs/Glossary/Primitive ECMAScript 2015}),\n *  a _primitive_ is considered one of the following types:\n *\n * - `undefined`\n * - `null`\n * - `string` (note that `new String('s')` does not produce a _primitive_, it\n *   produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `boolean` (note that `new Boolean(true)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `number` (note that `new Number(1)` does not produce a _primitive_,\n *   it produces an {@link rtvref.types.OBJECT object}, and __should be avoided__).\n * - `Symbol`\n *\n * @typedef {*} rtvref.types.primitives\n * @see {@link rtvref.validation.isPrimitive}\n */\n\n/**\n * <h3>Rules Per Qualifiers</h3>\n *\n * {@link rtvref.qualifiers Qualifiers} state basic rules. Unless otherwise stated,\n *  every type herein abides by those basic rules. Each type will also impose\n *  additional rules specific to the type of value it represents.\n *\n * For example, while the {@link rtvref.types.FINITE FINITE} type states that the\n *  value must not be `NaN`, `+Infinity`, nor `-Infinity`; it could be `null` if\n *  the qualifier used is `EXPECTED`; and it could be `undefined` if the qualifier\n *  used is `OPTIONAL`.\n *\n * @typedef {*} rtvref.types.rules\n */\n\n/**\n * <h3>Type Arguments</a></h3>\n *\n * Some types will accept, or may even expect, one or more arguments. Each type\n *  will specify whether it has arguments, and if they're optional or required.\n *  Arguments are specified as a single {@link rtvref.types.OBJECT object}\n *  immediately following a type in an __Array__ {@link rtvref.types.typeset typeset}\n *  (i.e. an Array must be used as the typeset in order to provide arguments for\n *  a type).\n *\n * An arguments object immediately follows its type in a typeset, such as\n *  `[PLAIN_OBJECT, {hello: STRING}]`. This would specify the value must be a\n *  {@link rtvref.types.PLAIN_OBJECT plain object} with a shape that includes a\n *  property named 'hello', that property being a\n *  {@link rtvref.qualifiers.REQUIRED required} {@link rtvref.types.STRING string}.\n *  Another example would be `[STRING, {min: 5}]`, which would require a string\n *  of at least 5 characters in length.\n *\n * Since {@link rtvref.qualifiers qualifiers} may affect how a value is validated\n *  against a type, {@link rtvref.types.rules qualifier rules} always take\n *  __precedence__ over any argument specified. For example, `[STRING, {min: 0}]`\n *  would fail to validate an empty string because the _implied_ qualifier\n *  is `REQUIRED`, and per {@link rtvref.types.STRING STRING} qualifier rules,\n *  required strings cannot be empty.\n *\n * @typedef {Object} rtvref.types.type_arguments\n * @see {@link rtvref.validation.isTypeArgs}\n */\n\n/**\n * <h3>Collection Arguments</h3>\n *\n * Describes the keys and values in a collection-based object, which is one of\n *  the following types:\n *\n * - {@link rtvref.types.HASH_MAP HASH_MAP} (NOTE: only __own-enumerable\n *   properties__ are considered part of this type of collection)\n * - {@link rtvref.types.MAP MAP}\n * - {@link rtvref.types.SET SET} (with some exceptions)\n *\n * For example, the following arguments both verify a collection of 3-letter\n *  string keys (upper- or lowercase) to finite numbers:\n *\n * - `{keyExp: '[a-z]{3}', keyFlagSpec: 'i', values: FINITE}`\n * - `{keyExp: '[a-zA-Z]{3}', values: FINITE}`\n *\n * Note that {@link rtvref.types.ARRAY ARRAY} is __not__ included in this list\n *  because the array type has special syntax for describing the type of its items.\n *  See {@link rtvref.types.ARRAY_args ARRAY_args} instead.\n *\n * The {@link rtvref.types.WEAK_MAP WEAK_MAP} and {@link rtvref.types.WEAK_SET WEAK_SET}\n *  types do not apply because, due to their nature, their elements cannot be\n *  iterated.\n *\n * @typedef {Object} rtvref.types.collection_args\n * @property {number} [length] The exact number of elements required in\n *  the collection. A negative value allows for any number of entries. Zero\n *  requires an empty collection. Ignored if not a\n *  {@link rtvref.types.FINITE FINITE} number.\n *\n *  Applies to: All collection types.\n *\n * @property {rtvref.types.typeset} [keys] A typeset describing each key\n *  in the collection.\n *\n *  If the type is {@link rtvref.types.HASH_MAP HASH_MAP}, this argument is ignored\n *   due to the nature of its JavaScript `Object`-based implementation which\n *   requires that all keys be non-empty {@link rtvref.types.STRING strings}.\n *\n *  Applies to: {@link rtvref.types.MAP MAP}.\n *\n * @property {string} [keyExp] A string-based regular expression describing the\n *  names of keys found in the collection. By default, there are no restrictions\n *  on key names. Ignored if the key type is not {@link rtvref.types.STRING STRING},\n *  as specified in `keys` (when `keys` is applicable to the collection type).\n *\n *  For example, to require numerical keys, the following expression could be\n *   used: `\"^\\\\d+$\"`.\n *\n *  Applies to: {@link rtvref.types.HASH_MAP HASH_MAP}, {@link rtvref.types.MAP MAP}.\n *\n * @property {string} [keyFlagSpec] A string specifying any flags to use with\n *  the regular expression specified in `keyExp`. Ignored if _falsy_ or if\n *  `keyExp` is not specified. See the\n *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp RegExp#flags}\n *  parameter for more information.\n *\n *  Applies to: {@link rtvref.types.HASH_MAP HASH_MAP}, {@link rtvref.types.MAP MAP}.\n *\n * @property {rtvref.types.typeset} [values] A typeset describing each value in\n *  the collection. If specified, all values must match this typeset (but the\n *  collection is not required to have any elements to be considered valid, unless\n *  `length` is specified). If not specified, no validation is performed on values.\n *\n *  For example, to require arrays of non-empty string values as values in the\n *   collection, the following typeset could be used: `[[types.STRING]]`.\n *\n *  Applies to: All collection types.\n *\n * @see {@link rtvref.types.HASH_MAP}\n * @see {@link rtvref.types.MAP}\n * @see {@link rtvref.types.SET}\n */\n\n/**\n * <h3>Typeset</h3>\n *\n * Describes the possible types for a given value. It can be any one of the following\n *  JavaScript types:\n *\n * - {@link rtvref.types.OBJECT Object}: For the root or a nested\n *   {@link rtvref.shape_descriptor shape descriptor} of _implied_\n *   {@link rtvref.types.OBJECT OBJECT} type (unless paired with a specific object type\n *   like {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, for example, when using the\n *   Array notation, e.g. `[PLAIN_OBJECT, {...}]`). If the object is empty (has no properties),\n *   nothing will be verified (anything will pass).\n * - {@link rtvref.types.STRING String}: For a single type, such as\n *   {@link rtvref.types.FINITE FINITE} for a finite number. Must be one of the types\n *   defined in {@link rtvref.types}.\n * - {@link rtvref.types.FUNCTION Function}: For a\n *   {@link rtvref.types.custom_validator custom validator} that will verify the value of the\n *   property using custom code. Since the Array form is not being used (only the validator is\n *   being provided), it's always invoked immediately. Since a type is not provided, the\n *   {@link rtvref.types.ANY ANY} type is implied.\n * - {@link rtvref.types.ARRAY Array}: For multiple type possibilities, optionally\n *   {@link rtvref.qualifiers qualified}, using a short-circuit __OR__ conjunction, which means\n *   the value of the property being described must match _at least one_ of the types listed, but\n *   not all. Matching is done in a short-circuit fashion, from the first to the last element in\n *   the typeset. If a simpler type is a more likely match, it's more performant to specify it\n *   first/earlier in the typeset to avoid a match attempt on a nested shape or Array.\n *   - Cannot be an empty Array.\n *   - A given type may not be included more than once in the typeset, but may appear\n *     again in a nested typeset (when a parent typeset describes an\n *     {@link rtfref.types.ARRAY Array} or type of {@link rtfref.types.OBJECT Object}).\n *   - An Array is necessary to {@link rtvref.qualifiers qualify} the typeset as not\n *     required (see _Typeset Qualifiers_ below).\n *   - An Array is necessary if a type needs or requires\n *     {@link rtvref.types.type_arguments arguments}.\n *   - If the __first__ (or second, if a {@link rtvref.types.qualifiers qualifier}\n *     is provided, and this, in a typeset that is _not_\n *     {@link rtvref.types.fully_qualified_typeset fully-qualified}), element is an `Object`,\n *     it's treated as a nested {@link rtvref.shape_descriptor shape descriptor}\n *     describing an object of the default {@link rtvref.types.OBJECT OBJECT} type.\n *     To include a shape descriptor at any other position within the array, it\n *     __must__ be preceded by a type, even if the default `OBJECT` type is being\n *     used (i.e. `OBJECT` must be specified as the type). For example, all\n *     these typesets are equivalent (and equivalent to just `{name: STRING}`\n *     as the typeset): `[{name: STRING}]`, `[REQUIRED, {name: STRING}]`, and\n *     `[REQUIRED, OBJECT, {name: STRING}]`, describing an object that has a name\n *     property which is a non-empty string. Changing it to `[STRING, {name: STRING}]`,\n *     however, does __not__ mean, \"a non-empty string, or an object with a name\n *     property which is a non-empty string\". In this case, `{name: STRING}` would\n *     be treated as {@link rtvref.types.STRING_args STRING arguments}, which is\n *     likely not the desired intent. The object would have to be preceded by an\n *     object type (e.g. {@link rtvref.types.OBJECT OBJECT},\n *     {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}, etc.) to have it interpreted\n *     as in the OR case.\n *   - If an element is an `Array` (any position), it's treated as a __nested list__\n *     with an implied {@link rtvref.types.ARRAY ARRAY} type, e.g.\n *     `[BOOLEAN, [STRING, FINITE]]` would describe a property that should be a boolean,\n *     or an array of non-empty strings or finite numbers. See the `ARRAY` type\n *     reference for more information on _shorthand_ and _full_ notations.\n *   - If an element is a `Function`, it must be the __last__ element in the Array\n *     and will be treated as a {@link rtvref.types.custom_validator custom validator}.\n *     Only one validator can be specified for a given typeset (additional validators\n *     may appear in nested typesets).\n *\n * <h4>Typeset Qualifiers</h4>\n *\n * All typesets use an _implied_ {@link rtvref.qualifiers.REQUIRED REQUIRED}\n *  qualifier unless otherwise specified. To qualify a typeset, a\n *  {@link rtvref.qualifiers qualifier} may be specified as the __first__ element\n *  in the `Array` form (if specified, it must be the first element). For example,\n *  `{note: [EXPECTED, STRING]}` would describe an object with a 'note' property\n *  that is an expected, but not required, string, which could therefore be either\n *  empty or even `null`. The `Array` form must be used in order to qualify a\n *  typeset as other than required, and the qualifier applies to all immediate\n *  types in the typeset (which means each nested typeset can have its own qualifier).\n *\n * <h4>Example: Object</h4>\n *\n * <pre><code>const contactShape = {\n *   name: rtv.t.STRING, // required, non-empty, string\n *   tags: [rtv.t.ARRAY, [rtv.t.STRING]], // required array of non-empty strings\n *   // tags: [[rtv.t.STRING]], // same as above, but using shortcut array format\n *   details: { // required nested object of type `OBJECT` (default)\n *     birthday: [rtv.q.EXPECTED, rtv.t.DATE] // Date (could be null)\n *   },\n *   notes: [rtv.q.OPTIONAL, rtv.t.STRING, function(value) { // optional string...\n *     return !value || value.length < 500; // ...less than 500 characters long, if specified\n *   }]\n * };\n *\n * const contact = {\n *   name: 'John Doe',\n *   tags: ['colleagues', 'sports'],\n *   details: {\n *     birthday: null // not specified\n *   }\n * };\n *\n * rtv.verify(contact, contactShape); // OK\n *\n * const walletShape = {\n *   contacts: [[contactShape]], // list of contacts using nested shape\n *   address: {\n *     street: rtv.t.STRING\n *     // ...\n *   },\n *   money: rtv.t.FINITE\n * };\n *\n * rtv.verify({\n *   contacts: [contact],\n *   address: {street: '123 Main St'},\n *   money: 100\n * }, walletShape); // OK\n * </code></pre>\n *\n * <h4>Example: String</h4>\n *\n * <pre><code>rtv.verify('foo', rtv.t.STRING); // OK\n * rtv.verify('foo', rtv.t.FINITE); // ERROR\n * </code></pre>\n *\n * <h4>Example: Array</h4>\n *\n * <pre><code>const typeset = [rtv.t.STRING, rtv.t.FINITE]; // non-empty string, or finite number\n * rtv.verify('foo', typeset); // OK\n * rtv.verify(1, typeset); // OK\n * </code></pre>\n *\n * <h4>Example: Function</h4>\n *\n * <pre><code>rtv.verify(123, (v) => v > 100); // OK\n * rtv.verify('123', [rtv.t.STRING, (v) => parseInt(v) > 100); // OK\n * </code></pre>\n *\n * <h4>Example: Alternate Qualifier</h4>\n *\n * <pre><code>const person = {\n *   name: rtv.t.STRING, // required, non-empty\n *   age: [rtv.q.OPTIONAL, rtv.t.FINITE, (v) => v >= 18] // 18 or older, if specified\n * };\n * rtv.verify({name: 'Bob'}, person); // OK\n * rtv.verify({name: ''}, person); // ERROR\n * rtv.verify({name: 'Steve', age: 17}, person); // ERROR\n * rtv.verify({name: 'Steve', age: null}, person); // OK\n * </code></pre>\n *\n * @typedef {(Object|string|Array|Function)} rtvref.types.typeset\n */\n\n/**\n * <h3>Fully-Qualified Typeset</h3>\n *\n * A {@link rtvref.types.typeset typeset} expressed without any shortcut notations\n *  or implied/default types to make it easier to parse, especially as the `match`\n *  parameter given to a {@link rtvref.types.custom_validator custom validator}.\n *  A fully-qualified typeset always uses the array notation, and has a single\n *  {@link rtvref.qualifiers qualifier} as its first element, followed by\n *  at least one type, and at most one validator.\n *\n * For example:\n *\n * - `STRING` -> `[REQUIRED, STRING]`\n * - `{note: STRING}` -> `[REQUIRED, OBJECT, {note: [REQUIRED, STRING]}]`\n * - `[[FINITE]]` -> `[REQUIRED, ARRAY, [REQUIRED, FINITE]]`\n * - `(v) => !!v` -> `[REQUIRED, ANY, (v) => !!v]`\n *\n * @typedef {Array} rtvref.types.fully_qualified_typeset\n */\n\n/**\n * <h3>Custom Validator</h3>\n *\n * A function used as a {@link rtvref.types.typeset typeset}, or as a subset to\n *  a typeset, to provide custom verification of the value being verified.\n *\n * A typeset may only have one validator, and the validator is _only called if\n *  the value being verified was verified by at least one type in the typeset_.\n *  The validator must be the __last__ element within the typeset (if the typeset\n *  is an array, and a validator is needed). The validator must also be\n *  specified _after_ the {@link rtvref.qualifiers qualifier} in a typeset Array.\n *\n * The validator is invoked immediately after the first type match, but _only if\n *  a type match is made_. If the typeset is not\n *  {@link rtvref.types.fully_qualified_typeset fully-qualified} and does not\n *  explicitly specify a type, the {@link rtvref.types.ANY ANY} type is implied,\n *  which will match _any_ value, which means the validator will always be called.\n *\n * There is one disadvantage to using a custom validator: It cannot be de/serialized\n *  via JSON, which means it cannot be transmitted or persisted. One option would be\n *  to customize the de/serialization to JSON by serializing the validator to a\n *  special object with properties that would inform the deserialization process\n *  on how to reconstruct the validator dynamically.\n *\n * @typedef {function} rtvref.types.custom_validator\n * @param {*} value The value being verified.\n * @param {Array} match A __first-level__,\n *  {@link rtvref.types.fully_qualified_typeset fully-qualified} typeset describing\n *  the type that matched. This means the first level of this subset of `typeset`\n *  (the 3rd parameter) is fully-qualified, but any nested\n *  {@link rtvref.shape_descriptor shape descriptors} or arrays will not be (they\n *  will remain references to the same shapes/arrays in `typeset`).\n *\n * For example, if the given typeset was `[PLAIN_OBJECT, {note: STRING}]`, this\n *  parameter would be a new typeset array `[REQUIRED, PLAIN_OBJECT, {note: STRING}]`,\n *  and the `typeset` parameter would be the original `[PLAIN_OBJECT, {note: STRING}]`.\n *\n * If the given typeset was `[STRING, FINITE]` and FINITE matched, this parameter\n *  would be `[REQUIRED, FINITE]` and the `typeset` parameter would be the\n *  original `[STRING, FINITE]`.\n *\n * @param {rtvref.types.typeset} typeset Reference to the typeset used for\n *  verification. Note that the typeset may contain nested typeset(s), and may\n *  be part of a larger parent typeset (though there would be no reference to\n *  the parent typeset, if any). This typeset is as it was specified in the\n *  parent shape, and therefore it may not be fully-qualified.\n * @returns {boolean} A _truthy_ value to verify, a _falsy_ value to reject.\n * @see {@link rtvref.validation.isValidator}\n */\n\n// Creates a definition object.\n// @param {string} value Type value. Must not be empty.\n// @param {boolean} [hasArgs=false] If the type takes arguments.\n// @param {boolean} [isObject=false] If the type is an object type, which means\n//  it describes a shape (either directly as its args object, e.g. PLAIN_OBJECT,\n//  or indirectly as a property inside it's args object, e.g. CLASS_OBJECT).\n// @returns {{value: boolean, hasArgs: boolean, isObject: boolean}} Type definition.\nconst def = function(value, hasArgs, isObject) {\n  return {\n    value,\n    hasArgs: !!hasArgs,\n    isObject: !!isObject\n  };\n};\n\n// map of type key (string) to type definition (see def() for shape)\nconst defs = {\n  /**\n   * The any type is special in that it allows _anything_, which includes `null`\n   *  and `undefined` values. Because of this, it's the most liberal in terms of\n   *  types as well as qualifiers. A more specific type should be used whenever\n   *  possible to ensure a higher degree of confidence in the value being validated.\n   *\n   * Any rules per qualifiers:\n   *\n   * - REQUIRED: Can be any value, including `null` and `undefined`.\n   * - EXPECTED: Same rules as REQUIRED.\n   * - OPTIONAL: Same rules as EXPECTED.\n   *\n   * Since this type removes the property's need for existence in the prototype\n   *  chain, it renders the verification moot (i.e. the property of this type might\n   *  as well not be included in a {@link rtvref.shape_descriptor shape descriptor}\n   *  unless a {@link rtvref.types.custom_validator custom validator} is being\n   *  used to do customized verification.\n   *\n   * @name rtvref.types.ANY\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  ANY: def('ANY'),\n\n  /**\n   * Null rules per qualifiers: must be the `null` {@link rtvref.types.primitives primitive}.\n   *\n   * Use this special type to explicitly test for a `null` value. For example,\n   *  a {@link rtvref.shape_descriptor shape}'s property may be required to be\n   *  `null` under certain circumstances.\n   *\n   * @name rtvref.types.NULL\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  NULL: def('NULL'),\n\n  // TODO[future]: Add 'exp: string' and 'expFlags: string' args (strings because\n  //  of JSON requirement...) for a regular expression test. Similar prop names\n  //  to collection_args.\n  /**\n   * <h3>String Arguments</h3>\n   * @typedef {Object} rtvref.types.STRING_args\n   * @property {string} [exact] An exact string to match. Can be an empty string.\n   *  Note, however, that the {@link rtvref.qualifiers qualifier} must not be\n   *  `REQUIRED` because that will disallow an empty string as the value being\n   *  checked (i.e. this argument will be ignored).\n   * @property {string} [partial] A partial value to match (must be somewhere\n   *  within the string). Ignored if empty string, or `exact` is specified. `min`\n   *  and `max` take __precedence__ over this argument (the length will be\n   *  validated first, then a partial match will be attempted).\n   * @property {number} [min] Minimum inclusive length. Defaults to 1 for a\n   *  `REQUIRED` string, and 0 for an `EXPECTED` or `OPTIONAL` string. Ignored if\n   *  `exact` is specified, or `min` is not a {@link rtvref.types.FINITE FINITE}\n   *  number >= 0.\n   * @property {number} [max] Maximum inclusive length. Negative means no maximum.\n   *  Ignored if `exact` is specified, `max` is not a\n   *  {@link rtvref.types.FINITE FINITE} number, or `max` is less than `min`.\n   * @see {@link rtvref.types.STRING}\n   */\n\n  /**\n   * String rules per qualifiers:\n   *\n   * - REQUIRED: Must be a non-empty string.\n   * - EXPECTED | OPTIONAL: May be an empty string.\n   *\n   * In all cases, the value must be a string {@link rtvref.types.primitives primitive}.\n   *  Note that `new String('hello') !== 'hello'` because the former is an _object_, not a string.\n   *\n   * Arguments (optional): {@link rtvref.types.STRING_args}\n   *\n   * @name rtvref.types.STRING\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  STRING: def('STRING', true),\n\n  /**\n   * Boolean rules per qualifiers: Must be a boolean {@link rtvref.types.primitives primitive}.\n   *  Note that `new Boolean(true) !== true` because the former is an _object_, not a boolean.\n   * @name rtvref.types.BOOLEAN\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  BOOLEAN: def('BOOLEAN'),\n\n  /**\n   * Symbol rules per qualifiers: Must be a symbol {@link rtvref.types.primitives primitive}.\n   * @name rtvref.types.SYMBOL\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  SYMBOL: def('SYMBOL'),\n\n  /**\n   * <h3>Numeric Value Arguments</h3>\n   *\n   * Applicable to all numeric types.\n   *\n   * @typedef {Object} rtvref.types.numeric_args\n   * @property {string} [exact] An exact number to match. Ignored if not\n   *  within normal range of the type (e.g. for `NUMBER`, could be `+Infinity`,\n   *  or even `NaN` if the qualifier is not `REQUIRED`; but these values would be\n   *  ignored by `FINITE` since they aren't part of the `FINITE` range).\n   * @property {number} [min] Minimum inclusive value. Ignored if `exact` is\n   *  specified, `min` is `NaN`, or `min` is not within normal range of the type.\n   * @property {number} [max] Maximum inclusive value. Ignored if `exact` is\n   *  specified, `max` is `NaN`, `max` is not within normal range of the type,\n   *  or `max` is less than `min`.\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.FLOAT}\n   * @see {@link rtvref.qualifiers}\n   */\n\n  /**\n   * Number rules per qualifiers:\n   *\n   * - REQUIRED: Cannot be `NaN`, but could be `+Infinity`, `-Infinity`.\n   * - EXPECTED | OPTIONAL: Could be `NaN`, `+Infinity`, `-Infinity`.\n   *\n   * In all cases, the value must be a number {@link rtvref.types.primitives primitive}.\n   *  Note that `new Number(1) !== 1` because the former is an _object_, not a number.\n   *\n   * An number is not guaranteed to be a\n   *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger safe integer}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.NUMBER\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.SAFE_INT}\n   * @see {@link rtvref.types.FLOAT}\n   */\n  NUMBER: def('NUMBER', true),\n\n  /**\n   * Finite rules per qualifiers: Cannot be `NaN`, `+Infinity`, `-Infinity`. The\n   *  value can be either an {@link rtvref.types.INT integer},\n   *  or a {@link rtvref.types.FLOAT floating point number}. It must also be a\n   *  number {@link rtvref.types.primitives primitive}.\n   *\n   * A finite number is not guaranteed to be a\n   *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger safe integer}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.FINITE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.SAFE_INT}\n   * @see {@link rtvref.types.FLOAT}\n   */\n  FINITE: def('FINITE', true),\n\n  /**\n   * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} number,\n   *  an integer, and a number {@link rtvref.types.primitives primitive}.\n   *\n   * An integer is not guaranteed to be a\n   *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger safe integer}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.INT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.SAFE_INT}\n   * @see {@link rtvref.types.FLOAT}\n   */\n  INT: def('INT', true),\n\n  /**\n   * Int rules per qualifiers: Must be a {@link rtvref.types.FINITE finite} number, a\n   *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger safe integer},\n   *  and a number {@link rtvref.types.primitives primitive}.\n   *\n   * An integer is safe if it's an IEEE-754 double precision number which isn't\n   *  the result of a rounded unsafe integer. For example, `2^53 - 1` is safe,\n   *  but `2^53` is not because `2^53 + 1` would be rounded to `2^53`.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.INT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.FLOAT}\n   */\n  SAFE_INT: def('SAFE_INT', true),\n\n  /**\n   * Float rules per qualifiers: Must be a {@link rtvref.types.FINITE finite}\n   *  floating point number, and a number {@link rtvref.types.primitives primitive}.\n   *\n   * Arguments (optional): {@link rtvref.types.numeric_args}\n   *\n   * @name rtvref.types.FLOAT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.NUMBER}\n   * @see {@link rtvref.types.FINITE}\n   * @see {@link rtvref.types.INT}\n   * @see {@link rtvref.types.SAFE_INT}\n   */\n  FLOAT: def('FLOAT', true),\n\n  /**\n   * Function rules per qualifiers: Must be a `function`.\n   * @name rtvref.types.FUNCTION\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  FUNCTION: def('FUNCTION'),\n\n  /**\n   * RegExp rules per qualifiers: Must be a `RegExp` instance.\n   * @name rtvref.types.REGEXP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n   */\n  REGEXP: def('REGEXP'),\n\n  // TODO[future] Consider DATE args for ranges, date values to be ISO8601 UTC strings so they are\n  //  easily serializable.\n  /**\n   * Date rules per qualifiers: Must be a `Date` instance.\n   * @name rtvref.types.DATE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n   */\n  DATE: def('DATE'),\n\n  /**\n   * Error rules per qualifiers: Must be an `Error` instance, which includes `TypeError`,\n   *  `RangeError`, `ReferenceError`, etc.\n   * @name rtvref.types.ERROR\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n   */\n  ERROR: def('ERROR'),\n\n  /**\n   * Promise rules per qualifiers: Must be a `Promise` instance.\n   * @name rtvref.types.PROMISE\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n   */\n  PROMISE: def('PROMISE'),\n\n  // TODO[future]: Short-hand 'exact' with `[ARRAY, 2, [STRING]]` or `[2, [STRING]]` syntax?\n  /**\n   * <h3>Array Arguments</h3>\n   * @typedef {Object} rtvref.types.ARRAY_args\n   * @property {rtvref.types.typeset} [typeset] The typeset which every value in\n   *  the array must match. Defaults to {@link rtvref.types.ANY} which means any\n   *  value will match.\n   * @property {number} [length] Exact length. Ignored if not a\n   *  {@link rtvref.types.FINITE FINITE} number >= 0.\n   * @property {number} [min] Minimum inclusive length. Ignored if `exact` is\n   *  specified, or `min` is not a {@link rtvref.types.FINITE FINITE} number >= 0.\n   * @property {number} [max] Maximum inclusive length. Negative means no maximum.\n   *  Ignored if `exact` is specified, `max` is not a\n   *  {@link rtvref.types.FINITE FINITE} number, or `max` is less than `min`.\n   * @see {@link rtvref.types.ARRAY}\n   */\n\n  /**\n   * Array rules per qualifiers: Must be an `Array`. Empty arrays are permitted,\n   *  unless arguments prevent them.\n   *\n   * Arguments (optional): {@link rtvref.types.ARRAY_args},\n   *  {@link rtvref.types.typeset Array typeset}. Note that the `ARRAY` type must\n   *  be specified when using arguments (i.e. the shorthand notation cannot\n   *  be used).\n   *\n   * When describing arrays, either _shorthand_ or _full_ notation may be used.\n   *  In the shorthand notation, the `ARRAY` type isn't necessary, but it's only\n   *  possible to specify the Array typeset to use to validate each array element,\n   *  and {@link rtvref.types.ARRAY_args arguments} can't be specified. In the\n   *  {@link rtvref.types.fully_qualified_typeset fully-qualified} notation, the\n   *  `ARRAY` type is required, but the Array typeset must be moved into the\n   *  `typeset` argument (along with any other argument necessary).\n   *\n   * __NOTE__: It's important to realize that arrays (as in the JavaScript Array\n   *  type) are essentially nested {@link rtvref.types.typeset Array typesets}.\n   *  They represent a set of types that will be used to validate each element\n   *  of an array using a short-circuit OR conjunction, looking for the first type that matches.\n   *\n   * <h4>Example: Simple array</h4>\n   *\n   * The `value` property must be an array (possibly empty) of any type of value.\n   *\n   * <pre><code>{\n   *   value: [ARRAY]\n   * }\n   * </code></pre>\n   *\n   * __NOTE__: Since arrays are, in reality, nested\n   *  {@link rtvref.types.typeset Array typesets}, and since an empty array is\n   *  an invalid Array typeset, it's not possible to use the shorthand notation\n   *  to indicate what could be the equivalent: `[[]]`. The inner Array typeset\n   *  would be deemed _invalid_.\n   *\n   * <h4>Example: Shorthand notation</h4>\n   *\n   * The `value` property must be an array (possibly empty) of finite numbers of\n   *  any value.\n   *\n   * <pre><code>{\n   *   value: [[FINITE]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Shorthand, mixed types</h4>\n   *\n   * The `value` property must be either a boolean; or an array (possibly empty) of\n   *  finite numbers of any value, or non-empty strings, or a mix of both.\n   *\n   * <pre><code>{\n   *   value: [BOOLEAN, [FINITE, STRING]]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Fully-qualified notation, no typeset</h4>\n   *\n   * The `value` property must be a non-empty array of any type of value.\n   *\n   * <pre><code>{\n   *   value: [REQUIRED, ARRAY, {min: 1}]\n   * }\n   * </code></pre>\n   *\n   * <h4>Example: Fully-qualified notation</h4>\n   *\n   * The `value` property must be an array (possibly empty) of finite numbers of\n   *  any value (nested typeset is not fully-qualified).\n   *\n   * <pre><code>{\n   *   value: [REQUIRED, ARRAY, {typeset: [FINITE]}]\n   * }\n   *\n   * <h4>Example: Fully-qualified, mixed types</h4>\n   *\n   * The `value` property must be either a boolean; or an array (possibly empty) of\n   *  finite numbers of any value, or non-empty strings, or a mix of both\n   *  (nested typeset is not fully-qualified).\n   *\n   * <pre><code>{\n   *   value: [REQUIRED, BOOLEAN, ARRAY, {typeset: [FINITE, STRING]}]\n   * }\n   * </code></pre>\n   *\n   * @name rtvref.types.ARRAY\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  ARRAY: def('ARRAY', true),\n\n  /**\n   * An _any_ object is anything that is __not__ a {@link rtvref.types primitive}, which\n   *  means it includes the `Array` type, as well as functions and arguments, and\n   *  other JavaScript _object_ types. To test for an array, use the\n   *  {@link rtvref.types.ARRAY ARRAY} type. To test for a function, use the\n   *  {@link rtvref.types.FUNCTION FUNCTION} type.\n   *\n   * The following values __are considered__ any objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new (function() {}) | new (class {})` (class instance) (also see\n   *   {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT})\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new Date()` (also see {@link rtvref.types.DATE DATE})\n   * - `new Error()` (also see {@link rtvref.types.ERROR ERROR})\n   * - `new Promise()` (also see {@link rtvref.types.PROMISE PROMISE})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   *\n   * {@link rtvref.types.primitives Primitive} values __are not__ considered any objects,\n   *  especially when the qualifier is {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n   *  Note that `typeof null === 'object'` in JavaScript; the `ANY_OBJECT` type\n   *  allows testing for this undesirable fact.\n   *\n   * Any object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.ANY_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   */\n  ANY_OBJECT: def('ANY_OBJECT', true, true),\n\n  /**\n   * An object is one that extends from `JavaScript.Object` (i.e. an _instance_\n   *  of _something_ that extends from Object) and is not a\n   *  {@link rtvref.types.FUNCTION function}, {@link rtvref.types.ARRAY array},\n   *  {@link rtvref.types.REGEXP regular expression}, {@link rtvref.types.DATE DATE},\n   *  function arguments object,\n   *  {@link rtvref.types.MAP map}, {@link rtvref.types.WEAK_MAP weak map},\n   *  {@link rtvref.types.SET set}, {@link rtvref.types.WEAK_SET weak set}, nor a\n   *  {@link rtvref.types primitive}.\n   *\n   * This is the __default__ (imputed) type for\n   *  {@link rtvref.shape_descriptor shape descriptors}, which means the object itself\n   *  (the value being tested), prior to being checked against its shape, will be\n   *  tested according to this type.\n   *\n   * The following values are considered objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new (function() {}) | new (class {})` (class instance) (also see\n   *   {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT})\n   *\n   * The following values __are not__ considered objects:\n   *\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new Date()` (also see {@link rtvref.types.DATE DATE})\n   * - `new Error()` (also see {@link rtvref.types.ERROR ERROR})\n   * - `new Promise()` (also see {@link rtvref.types.PROMISE PROMISE})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   */\n  OBJECT: def('OBJECT', true, true),\n\n  /**\n   * A _plain_ object is one that is created directly from the `Object` constructor,\n   *  whether using `new Object()` or the literal `{}`.\n   *\n   * The following values are considered plain objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   *\n   * The following values __are not__ considered plain objects:\n   *\n   * - `new (function() {}) | new (class {})` (class instance) (also see\n   *   {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT})\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new Date()` (also see {@link rtvref.types.DATE DATE})\n   * - `new Error()` (also see {@link rtvref.types.ERROR ERROR})\n   * - `new Promise()` (also see {@link rtvref.types.PROMISE PROMISE})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Plain object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.shape_descriptor}\n   *\n   * @name rtvref.types.PLAIN_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   */\n  PLAIN_OBJECT: def('PLAIN_OBJECT', true, true),\n\n  /**\n   * {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} arguments.\n   * @typedef {Object} rtvref.types.CLASS_OBJECT_args\n   * @property {function} [ctr] A reference to a constructor function. If specified,\n   *  the class object (instance) must have this class function in its inheritance\n   *  chain such that `<class_object> instanceof ctr === true`. Note that this\n   *  property is not serializable to JSON. Ignored if not a\n   *  {@link rtvref.types.FUNCTION function}.\n   * @property {rtvref.shape_descriptor} [shape] A description of the class object's\n   *  shape. Ignored if not a valid shape descriptor.\n   */\n\n  /**\n   * A _class_ object is one that is created by invoking the `new` operator on a\n   *  function (other than a primitive type function), generating a new object,\n   *  commonly referred to as a _class instance_. This object's prototype\n   *  (`__proto__`) is a reference to that function's `prototype` and has a\n   *  `constructor` property that is `===` to the function.\n   *\n   * The following values are considered class objects:\n   *\n   * - `new (function() {}) | new (class {})` (tip: use the `ctr`\n   *   {@link rtvref.types.CLASS_OBJECT_args argument} to test for a specific class)\n   *\n   * The following values __are not__ considered class objects:\n   *\n   * - `{}`\n   * - `new Object()`\n   * - `new String('')`\n   * - `new Boolean(true)`\n   * - `new Number(1)`\n   * - `[]` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `new Array()` (also see {@link rtvref.types.ARRAY ARRAY})\n   * - `/re/` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new RegExp('re')` (also see {@link rtvref.types.REGEXP REGEXP})\n   * - `new Date()` (also see {@link rtvref.types.DATE DATE})\n   * - `new Error()` (also see {@link rtvref.types.ERROR ERROR})\n   * - `new Promise()` (also see {@link rtvref.types.PROMISE PROMISE})\n   * - `function(){}` (also see {@link rtvref.types.FUNCTION FUNCTION})\n   * - `arguments` (function arguments)\n   * - `new Map()` (also see {@link rtvref.types.MAP MAP})\n   * - `new WeakMap()` (also see {@link rtvref.types.WEAK_MAP WEAK_MAP})\n   * - `new Set()` (also see {@link rtvref.types.SET SET})\n   * - `new WeakSet()` (also see {@link rtvref.types.WEAK_SET WEAK_SET})\n   * - all {@link rtvref.types.primitives primitives}\n   *\n   * Class object rules per qualifiers:\n   *\n   * - REQUIRED: Per the lists above.\n   * - EXPECTED: `null` is allowed.\n   * - OPTIONAL: `undefined` is allowed.\n   *\n   * Arguments (optional): {@link rtvref.types.CLASS_OBJECT_args}\n   *\n   * @name rtvref.types.CLASS_OBJECT\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   */\n  CLASS_OBJECT: def('CLASS_OBJECT', true, true),\n\n  /**\n   * A simple {@link rtvref.types.OBJECT OBJECT} that is treated as a hash map\n   *  with an expected set of keys (forcibly strings due to the nature of the\n   *  native JavaScript `Object` type) and values. Keys are __own-properties only__,\n   *  and can be described using a regular expression. Values can be described using a\n   *  {@link rtvref.types.typeset typeset}. Empty maps are permitted.\n   *\n   * Map object rules per qualifiers: Same as {@link rtvref.types.OBJECT OBJECT} rules.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_args}\n   *\n   * @name rtvref.types.HASH_MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.ANY_OBJECT}\n   * @see {@link rtvref.types.OBJECT}\n   * @see {@link rtvref.types.PLAIN_OBJECT}\n   * @see {@link rtvref.types.CLASS_OBJECT}\n   * @see {@link rtvref.types.MAP}\n   * @see {@link rtvref.types.WEAK_MAP}\n   */\n  HASH_MAP: def('MAP_OBJECT', true), // NOTE: NOT an object type (unrelated to shapes)\n\n  /**\n   * An ES6 map supports any value as its keys, unlike a\n   *  {@link rtvref.types.HASH_MAP HASH_MAP} that only supports strings. Keys can\n   *  be described using a regular expression (if they are strings), and values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty maps are permitted\n   *  by default.\n   *\n   * Map rules per qualifiers: Must be a `Map` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_args}\n   *\n   * @name rtvref.types.MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.HASH_MAP}\n   * @see {@link rtvref.types.WEAK_MAP}\n   */\n  MAP: def('MAP', true),\n\n  /**\n   * An ES6 weak map supports any _object_ as its keys, unlike a\n   *  {@link rtvref.types.HASH_MAP HASH_MAP} that only supports strings,\n   *  and a {@link rtvref.types.MAP MAP} that supports any type of value.\n   *\n   * Weak map rules per qualifiers: Must be a `WeakMap` instance.\n   *\n   * @name rtvref.types.WEAK_MAP\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.HASH_MAP}\n   * @see {@link rtvref.types.MAP}\n   */\n  WEAK_MAP: def('WEAK_MAP'), // not iterable, so does not accept any collection args\n\n  /**\n   * An ES6 set is a collection of _unique_ values without associated keys. Values can\n   *  be described using a {@link rtvref.types.typeset typeset}. Empty sets are permitted\n   *  by default.\n   *\n   * Set rules per qualifiers: Must be a `Set` instance.\n   *\n   * Arguments (optional): {@link rtvref.types.collection_args}\n   *\n   * @name rtvref.types.SET\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.WEAK_SET}\n   */\n  SET: def('SET', true),\n\n  /**\n   * An ES6 weak set is a collection of weakly held _unique_ _objects_ without\n   *  associated keys.\n   *\n   * Weak set rules per qualifiers: Must be a `WeakSet` instance.\n   *\n   * @name rtvref.types.WEAK_SET\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   * @see {@link rtvref.types.SET}\n   */\n  WEAK_SET: def('WEAK_SET'), // not iterable, so does not accept any collection args\n\n  /**\n   * JSON rules per qualifiers: Must be a JSON value:\n   *\n   * - {@link rtvref.types.NULL null}\n   * - {@link rtvref.types.STRING string}, however __empty strings are permitted__,\n   *   even if the qualifier is `REQUIRED`\n   * - {@link rtvref.types.BOOLEAN boolean}\n   * - {@link rtvref.types.FINITE finite number}\n   * - {@link rtvref.types.PLAIN_OBJECT plain object}\n   * - {@link rtvref.types.ARRAY array}\n   *\n   * Since this type checks for _any_ valid JSON value, empty string and `null`\n   *  values are permitted, even when the typeset is qualified as `REQUIRED`.\n   *  Therefore, the `REQUIRED` qualifier has the same effect as the `EXPECTED`\n   *  qualifier.\n   *\n   * @name rtvref.types.JSON\n   * @const {string}\n   * @see {@link rtvref.qualifiers}\n   */\n  JSON: def('JSON')\n};\n\n//\n// ^^^^^^^ INSERT NEW TYPES ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Default object type: {@link rtvref.types.OBJECT}\n * @const {string} rtvref.types.DEFAULT_OBJECT_TYPE\n */\nexport const DEFAULT_OBJECT_TYPE = defs.OBJECT.value;\n\n/**\n * Enumeration (`string -> string`) of __object__ {@link rtvref.types types}. These\n *  are all the types that describe values which are essentially maps of various\n *  keys to values.\n * @name rtvref.types.objTypes\n * @type {rtvref.Enumeration}\n */\nexport const objTypes = new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    if (defs[name].isObject) {\n      types[name] = defs[name].value;\n    }\n  });\n  return types;\n}(), 'objTypes');\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.types types} that accept\n *  arguments.\n * @name rtvref.types.argTypes\n * @type {rtvref.Enumeration}\n */\nexport const argTypes = new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    if (defs[name].hasArgs) {\n      types[name] = defs[name].value;\n    }\n  });\n  return types;\n}(), 'argTypes');\n\n/**\n * Enumeration (`string -> string`) of all {@link rtvref.types types}.\n * @name rtvref.types.types\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration(function() {\n  const types = {};\n  Object.keys(defs).forEach(function(name) {\n    types[name] = defs[name].value;\n  });\n  return types;\n}(), 'types');\n","////// isArray validation\n\nimport {default as _isArray} from 'lodash/isArray';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.ARRAY ARRAY}\n * @const {string} rtvref.validation.isArray.type\n */\nexport const type = types.ARRAY;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.ARRAY ARRAY} type.\n * @function rtvref.validation.isArray.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isArray(v) {\n  return _isArray(v);\n}\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","////// isMap validation\n\nimport {default as _isMap} from 'lodash/isMap';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.MAP MAP}\n * @const {string} rtvref.validation.isMap.type\n */\nexport const type = types.MAP;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.MAP MAP} type.\n * @function rtvref.validation.isMap.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isMap(v) {\n  return _isMap(v);\n}\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar weakMapTag = '[object WeakMap]';\n\n/**\n * Checks if `value` is classified as a `WeakMap` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n * @example\n *\n * _.isWeakMap(new WeakMap);\n * // => true\n *\n * _.isWeakMap(new Map);\n * // => false\n */\nfunction isWeakMap(value) {\n  return isObjectLike(value) && getTag(value) == weakMapTag;\n}\n\nmodule.exports = isWeakMap;\n","////// isWeakMap validation\n\nimport {default as _isWeakMap} from 'lodash/isWeakMap';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * @const {string} rtvref.validation.isWeakMap.type\n */\nexport const type = types.WEAK_MAP;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.WEAK_MAP WEAK_MAP} type.\n * @function rtvref.validation.isWeakMap.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isWeakMap(v) {\n  return _isWeakMap(v);\n}\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","////// isSet validation\n\nimport {default as _isSet} from 'lodash/isSet';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.SET SET}\n * @const {string} rtvref.validation.isSet.type\n */\nexport const type = types.SET;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.SET SET} type.\n * @function rtvref.validation.isSet.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isSet(v) {\n  return _isSet(v);\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar weakSetTag = '[object WeakSet]';\n\n/**\n * Checks if `value` is classified as a `WeakSet` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n * @example\n *\n * _.isWeakSet(new WeakSet);\n * // => true\n *\n * _.isWeakSet(new Set);\n * // => false\n */\nfunction isWeakSet(value) {\n  return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n}\n\nmodule.exports = isWeakSet;\n","////// isWeakSet validation\n\nimport {default as _isWeakSet} from 'lodash/isWeakSet';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.WEAK_SET WEAK_SET}\n * @const {string} rtvref.validation.isWeakSet.type\n */\nexport const type = types.WEAK_SET;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.WEAK_SET WEAK_SET} type.\n * @function rtvref.validation.isWeakSet.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isWeakSet(v) {\n  return _isWeakSet(v);\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n","var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n","////// isRegExp validation\n\nimport {default as _isRegExp} from 'lodash/isRegExp';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.REGEXP REGEXP}\n * @const {string} rtvref.validation.isRegExp.type\n */\nexport const type = types.REGEXP;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.REGEXP REGEXP} type.\n * @function rtvref.validation.isRegExp.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isRegExp(v) {\n  return _isRegExp(v);\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n","var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n","////// isDate validation\n\nimport {default as _isDate} from 'lodash/isDate';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.DATE DATE}\n * @const {string} rtvref.validation.isDate.type\n */\nexport const type = types.DATE;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.DATE DATE} type.\n * @function rtvref.validation.isDate.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isDate(v) {\n  return _isDate(v);\n}\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike'),\n    isPlainObject = require('./isPlainObject');\n\n/** `Object#toString` result references. */\nvar domExcTag = '[object DOMException]',\n    errorTag = '[object Error]';\n\n/**\n * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n * `SyntaxError`, `TypeError`, or `URIError` object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n * @example\n *\n * _.isError(new Error);\n * // => true\n *\n * _.isError(Error);\n * // => false\n */\nfunction isError(value) {\n  if (!isObjectLike(value)) {\n    return false;\n  }\n  var tag = baseGetTag(value);\n  return tag == errorTag || tag == domExcTag ||\n    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n}\n\nmodule.exports = isError;\n","////// isError validation\n\nimport {default as _isError} from 'lodash/isError';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.ERROR ERROR}\n * @const {string} rtvref.validation.isError.type\n */\nexport const type = types.ERROR;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.ERROR ERROR} type.\n * @function rtvref.validation.isError.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isError(v) {\n  return _isError(v);\n}\n","////// isPromise validation\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.PROMISE PROMISE}\n * @const {string} rtvref.validation.isPromise.type\n */\nexport const type = types.PROMISE;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.PROMISE PROMISE} type.\n * @function rtvref.validation.isPromise.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isPromise(v) {\n  return (v instanceof Promise);\n}\n","////// isObject validation\n\nimport {default as _isObjectLike} from 'lodash/isObjectLike';\n\nimport isArray from './isArray';\nimport isMap from './isMap';\nimport isWeakMap from './isWeakMap';\nimport isSet from './isSet';\nimport isWeakSet from './isWeakSet';\nimport isRegExp from './isRegExp';\nimport isDate from './isDate';\nimport isError from './isError';\nimport isPromise from './isPromise';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.OBJECT OBJECT}\n * @const {string} rtvref.validation.isObject.type\n */\nexport const type = types.OBJECT;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.OBJECT OBJECT} type.\n * @function rtvref.validation.isObject.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isObject(v) { // no qualifier rules, no args\n  return _isObjectLike(v) && // excludes primitives and functions\n      !(v instanceof String) && // excludes `new String('foo')`\n      !(v instanceof Number) && // excludes `new Number(1)`\n      !(v instanceof Boolean) && // excludes `new Boolean(true)`\n      !isArray(v) && // excludes arrays which are otherwise object-like (typeof [] === 'object')\n      !isMap(v) && !isWeakMap(v) &&\n      !isSet(v) && !isWeakSet(v) &&\n      !isRegExp(v) &&\n      !isDate(v) &&\n      !isError(v) &&\n      !isPromise(v);\n}\n","////// isString validation\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.STRING STRING}\n * @const {string} rtvref.validation.isString.type\n */\nexport const type = types.STRING;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.STRING STRING} type.\n *\n * Determines if a value is a string literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}), __including an empty string__.\n *  It does not validate `new String('value')`, which is an object that is a\n *  string.\n *\n * @function rtvref.validation.isString.default\n * @param {*} v Value to validate.\n * @param {Object} [options] Validation options.\n * @param {boolean} [options.allowEmpty=false] If truthy, empty strings are\n *  permitted.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isString(v, {allowEmpty = false} = {}) {\n  return (typeof v === 'string') && (v !== '' || allowEmpty);\n}\n","////// isFunction validation\n\nimport {default as _isFunction} from 'lodash/isFunction';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.FUNCTION FUNCTION}\n * @const {string} rtvref.validation.isFunction.type\n */\nexport const type = types.FUNCTION;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.FUNCTION FUNCTION} type.\n * @function rtvref.validation.isFunction.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isFunction(v) {\n  return _isFunction(v);\n}\n","////// isBoolean validation\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.BOOLEAN BOOLEAN}\n * @const {string} rtvref.validation.isBoolean.type\n */\nexport const type = types.BOOLEAN;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.BOOLEAN BOOLEAN} type.\n *\n * Determines if a value is a boolean literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Boolean(true)`, which is an object that is a boolean.\n *\n * @function rtvref.validation.isBoolean.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isBoolean(v) {\n  return (v === true || v === false);\n}\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","////// isShape validation module\n\nimport isObject from './isObject';\n\n/**\n * Type: `undefined`, {@link rtvref.shape_descriptor shape} pseudo-type.\n * @const {string} rtvref.validation.isShape.type\n */\nexport const type = undefined;\n\n/**\n * Determines if a value is a {@link rtvref.shape_descriptor shape}.\n * @function rtvref.validation.isShape.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport default function isShape(v) {\n  return isObject(v);\n}\n","////// isTypeArgs validation module\n\nimport isObject from './isObject';\n\n/**\n * Type: `undefined`, {@link rtvref.types.type_arguments type arguments} pseudo-type.\n * @const {string} rtvref.validation.isTypeArgs.type\n */\nexport const type = undefined;\n\n/**\n * Determines if a value is a {@link rtvref.types.type_arguments type arguments}\n *  object.\n * @function rtvref.validation.isTypeArgs.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport default function isTypeArgs(v) {\n  // NOTE: Since shapes are also type args, this check must always validate a\n  //  shape; and since at this time, OBJECT === shape === type args, we just\n  //  check for an OBJECT type\n  return isObject(v);\n}\n","////// isValidator validation module\n\nimport isFunction from './isFunction';\n\n/**\n * Type: `undefined`, {@link rtvref.types.custom_validator custom validator} pseudo-type.\n * @const {string} rtvref.validation.isValidator.type\n */\nexport const type = undefined;\n\n/**\n * Determines if a value is a {@link rtvref.types.custom_validator custom validator}.\n * @function rtvref.validation.isValidator.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if it is; `false` otherwise.\n */\nexport default function isValidator(v) {\n  // TODO[plugins]: should this module be renamed to isCustomValidator since it's\n  //  perhaps overloaded with 'validator' concept for plugins @see rtvref.validator?\n  return isFunction(v);\n}\n","////// Qualifier Definitions\n\nimport Enumeration from './Enumeration';\n\n/**\n * <h2>Qualifiers</h2>\n *\n * Qualifiers determine the degree at which a value must be of a given type.\n *\n * @namespace rtvref.qualifiers\n */\n\n/**\n * Required qualifier: The value __must__ be of the expected type. Depending on\n *  the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier does not\n *  allow the value to be `null` or `undefined`.\n *\n * Note the fact the value cannot be `undefined` implicitly requires a\n *  {@link rtvref.shape_descriptor shape}'s property to be defined _somewhere_\n *  its prototype chain (if it weren't, then its value would be `undefined`,\n *  violating the requirements). For example, the shape `{name: [EXPECTED, STRING]}`\n *  would require the `name` property to exist and not be `undefined`, but would\n *  allow it to be `null` or even an empty string.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.REQUIRED\n * @const {string}\n * @see {@link rtvref.types}\n * @see {@link rtvref.types.STRING}\n */\nconst REQUIRED = '!';\n\n/**\n * Expected qualifier: The value _should_ be of the expected type. Depending on\n *  the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier does _not_ allow\n *  the value to be `undefined`, but does _allow_ it to be `null`.\n *\n * Note the fact the value cannot be `undefined` implicitly requires a\n *  {@link rtvref.shape_descriptor shape}'s property to be defined _somewhere_\n *  its prototype chain (if it weren't, then its value would be `undefined`,\n *  violating the requirements). For example, the shape `{name: [EXPECTED, STRING]}`\n *  would require the `name` property to exist and not be `undefined`, but would\n *  allow it to be `null` or even an empty string.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.EXPECTED\n * @const {string}\n * @see {@link rtvref.types}\n * @see {@link rtvref.types.STRING}\n */\nconst EXPECTED = '+';\n\n/**\n * Optional qualifier: The value _may_ be of the expected type. Depending on\n *  the type, additional requirements may be enforced.\n *\n * Unless otherwise stated in type-specific rules, this qualifier _allows_ a\n *  the value to be `null` as well as `undefined`,\n *\n * Note the fact the value can be `undefined` implies it does _not_ require a\n *  {@link rtvref.shape_descriptor shape}'s property to be defined anywhere in\n *  its prototype chain.\n *\n * See specific type for additional rules.\n *\n * @name rtvref.qualifiers.OPTIONAL\n * @const {string}\n * @see {@link rtvref.types}\n */\nconst OPTIONAL = '?';\n\n//\n// ^^^^^^^ INSERT NEW QUALIFIERS ^^^^^^^ ABOVE THIS SECTION ^^^^^^^\n//\n\n/**\n * Default qualifier: {@link rtvref.qualifiers.REQUIRED}\n * @const {string} rtvref.qualifiers.DEFAULT_QUALIFIER\n */\nexport const DEFAULT_QUALIFIER = REQUIRED;\n\n/**\n * Convenience function to check if a nil value (either `undefined` or `null`)\n *  is permitted under basic qualifier rules:\n *\n * - REQUIRED: Cannot be `undefined` nor `null`.\n * - EXPECTED: Can be `null`.\n * - OPTIONAL: Can be either `undefined` or `null`.\n *\n * @function rtvref.qualifiers.checkBasicRules\n * @param {*} v Value to check.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {boolean} `true` if the value is _nil_ (either `null` or `undefined`)\n *  and the basic qualifier's rules allow it to be so; `false` otherwise.\n *\n *  For example, `nilPermitted(null, REQUIRED) === false` while\n *   `nilPermitted(null, EXPECTED) === true`. Also, `nilPermitted(1, *) === false`\n *   because the value `1` is not _nil_\n */\nexport const nilPermitted = function(v, q = REQUIRED) {\n  if (q === REQUIRED) {\n    return false;\n  }\n\n  if (q === EXPECTED) {\n    return (v === null);\n  }\n\n  return (v === undefined || v === null);\n};\n\n/**\n * Enumeration (`string -> string`) of {@link rtvref.qualifiers qualifiers}.\n * @name rtvref.qualifiers.qualifiers\n * @type {rtvref.Enumeration}\n */\nexport default new Enumeration({\n  REQUIRED,\n  EXPECTED,\n  OPTIONAL\n}, 'qualifiers');\n","////// isTypeset validation module\n\nimport {default as _forEach} from 'lodash/forEach';\n\nimport isArray from './isArray';\nimport isShape from './isShape';\nimport isTypeArgs from './isTypeArgs';\nimport isString from './isString';\nimport isValidator from './isValidator';\n\nimport {default as types, argTypes, objTypes, DEFAULT_OBJECT_TYPE} from '../types';\nimport qualifiers from '../qualifiers';\nimport {print} from '../util';\n\n// Deep-verify a shape.\n// @param {string} type The in-scope type (should be an object type from types.objTypes).\n// @param {Object} rule The rule from the typeset being evaluated. This should be the args\n//  for the `type`, which is either the shape itself, or an args object containing a\n//  property that provides the shape.\n// @param {Object} options The options object originally given to isTypeset().\n// @param {string} failurePrefix The prefix to use if a failure message is generated.\n// @param {number} [idx=-1] The position of `rule` within an Array typeset (if the\n//  shape is nested), or a negative value if the typeset is not an Array.\n// @returns {boolean} True if the shape is valid, false otherwise.\nconst deepVerifyShape = function(type, rule, options, failurePrefix, idx = -1) {\n  let valid = true;\n\n  // if it's a class object, the shape is an optional sub-property of the object;\n  //  if it's a map object, there is no shape (the args are rtvref.types.collection_args);\n  //  otherwise, the shape is the rule/object itself\n  let shape;\n\n  if (type === types.CLASS_OBJECT && rule.hasOwnProperty('shape')) {\n    // shape must be valid descriptor\n    valid = isShape(rule.shape);\n    if (valid) {\n      shape = rule.shape;\n    } else {\n      // NOTE: since the type is CLASS_OBJECT, `idx` _must_ be >= 0 because an\n      //  Array typeset is required to specify this object type along with a shape:\n      //  [CLASS_OBJECT, {shape: {...}}]\n      options.failure = `${failurePrefix}: Expecting a valid shape descriptor in \"shape\" property of args for type=${print(type)} at index=${idx}`;\n    }\n  } else {\n    valid = isShape(rule);\n    if (valid) {\n      shape = rule;\n    } else {\n      options.failure = `${failurePrefix}: Expecting a valid shape descriptor for type=${print(type)}${idx >= 0 ? ` at index=${idx}` : ''}`;\n    }\n  }\n\n  if (shape) { // undefined if not valid or not provided\n    // validate all of the shape's typesets (each own-prop should be a typeset)\n    _forEach(shape, function(ts, prop) {\n      const opts = Object.assign({}, options); // options.failure should not exist at this point\n      valid = isTypeset(ts, opts); // eslint-disable-line no-use-before-define\n      options.failure = opts.failure && `${failurePrefix} (${idx >= 0 ? `index=${idx}, ` : ''}prop=\"${prop}\"): ${opts.failure}`;\n      return valid; // break on first invalid\n    });\n  }\n\n  return valid;\n};\n\n// Deep-verify a nested Array typeset.\n// @param {rtvref.types.typeset} typeset The nested Array typeset to verify.\n// @param {Object} options The options object originally given to isTypeset().\n// @param {string} failurePrefix The prefix to use if a failure message is generated.\n// @param {number} [idx] The position of `typeset` within the parent Array typeset.\nconst deepVerifyArray = function(typeset, options, failurePrefix, idx) {\n  const opts = Object.assign({}, options); // options.failure should not exist at this point\n  const valid = isTypeset(typeset, opts); // eslint-disable-line no-use-before-define\n  options.failure = opts.failure && `${failurePrefix} (index=${idx}): ${opts.failure}`;\n  return valid;\n};\n\n/**\n * Type: `undefined`, {@link rtvref.types.typeset typeset} pseudo-type.\n * @const {string} rtvref.validation.isTypeset.type\n */\nexport const type = undefined;\n\n/**\n * Determines if a value is a typeset.\n * @function rtvref.validation.isTypeset.default\n * @param {*} v Value to validate.\n * @param {Object} [options] Validation options.\n * @param {boolean} [options.deep=false] If truthy, deeply-validates any nested\n *  typesets. Note that typesets in nested shapes are also deeply-validated.\n * @param {boolean} [options.fullyQualified=false] If truthy, the typeset must be\n *  fully-qualified.\n * @param {(string|undefined)} [options.failure] (Output property) If an options\n *  object is specified, this property will be added and set to a failure message\n *  IIF the validation fails.\n * @returns {boolean} `true` if it is; `false` otherwise.\n * @see {@link rtvref.types.typeset}\n */\nexport default function isTypeset(v, options = {deep: false, fullyQualified: false}) {\n  const deep = !!options.deep;\n  const fullyQualified = !!options.fullyQualified;\n\n  // FIRST: make sure it's an acceptable type for a typeset: shape, string\n  //  (just a plain type name), function (validator), or array (non-empty)\n  let valid = !!(v && (isShape(v) || (isString(v) && types.check(v)) || isValidator(v) ||\n      (isArray(v) && v.length > 0)));\n\n  if (!valid) {\n    options.failure = `Value v=${print(v)} is not a valid type for a typeset: Expecting object (shape), non-empty string (single type), function (custom validator), or array (typeset, non-empty)`;\n  }\n\n  // THEN: check if needs to be fully-qualified, and check deep within if requested\n  if (valid && fullyQualified) {\n    const failurePrefix = `Fully-qualified ${deep ? 'deep' : 'shallow'} typeset=${print(v)}`;\n\n    // must now be an array with at least 2 elements: [qualifier, type]\n    if (isArray(v) && v.length >= 2) {\n      const usedTypes = {}; // @type {Object.<string,boolean>} map of simple type to `true`\n      let curType; // @type {string} current in-scope type\n      let argType; // @type {(string|undefined)} current in-scope type IIF it accepts args\n\n      // Updates the current in-scope type (curType) and marks it as used in usedTypes.\n      //  If the type has already been used, it sets valid to false.\n      // @param {string} newType New in-scope type.\n      const updateCurType = function(newType) {\n        // set the rule as the current in-scope type\n        curType = newType;\n\n        if (usedTypes[curType]) {\n          // a type cannot appear more than once in a typeset (but nested is OK)\n          valid = false;\n          options.failure = `${failurePrefix}: Type \"${curType}\" may not be included more than once in the typeset (but may appear again in a nested typeset)`;\n        }\n\n        usedTypes[curType] = true;\n      };\n\n      // iterate through each element in the typeset array to make sure all required\n      //  rules/properties of a fully-qualified typeset are specified\n      _forEach(v, function(rule, idx) {\n        if (idx === 0) {\n          // first position must always be the qualifier\n          // more efficient to check for a string first than to always iterate\n          //  all qualifiers (or all types, below) when it isn't since we know\n          //  they're always strings\n          valid = isString(rule) && !!qualifiers.check(rule);\n          if (!valid) {\n            options.failure = `${failurePrefix}: Expected a qualifier at index=${idx}, found ${print(rule)}`;\n          }\n        } else if (isString(rule)) {\n          // additional qualifier, or simple type\n          if (qualifiers.check(rule)) {\n            // cannot have more than one qualifier and qualifier must be in first position\n            //  (and this is not the first position because that's handled specially, above)\n            valid = false;\n            options.failure = `${failurePrefix}: Cannot have more than one qualifier, and qualifier must be in first position, index=${idx}`;\n          } else if (!types.check(rule)) {\n            // if not a qualifier, it must be a valid type (since it's a string)\n            valid = false;\n            options.failure = `${failurePrefix}: Expected a valid type in ${types} at index=${idx}, found ${print(rule)}`;\n          } else {\n            // set the rule as the current in-scope type\n            updateCurType(rule);\n\n            // update the in-scope arg type: reset to undefined if it doesn't take\n            //  args; otherwise, update it (NOTE: currently, there are no types that\n            //  _require_ args, only ones that optionally have args, so we don't\n            //  have to ensure that args were given when we change the type)\n            argType = argTypes.check(rule);\n          }\n        } else if (isValidator(rule)) {\n          // must be a validator, but there can't be more than 1, it must be\n          //  in the last position (which enforces the 1 count), always after the\n          //  qualifier, and since the typeset must be FQ'd, we must have an\n          //  in-scope type\n          valid = !!(curType && (idx + 1 === v.length));\n          if (!valid) {\n            options.failure = `${failurePrefix}: Unexpected custom validator at index=${idx}: Must be in the last position, must not be more than 1 in the typeset, must be after the qualifier, and must be preceded by a type`;\n          }\n        } else if (isTypeArgs(rule)) {\n          // could be a shape, or type args (either way, it's a single object)\n          // since the typeset must be fully-qualified, argType must already be\n          //  a type that takes arguments, since arguments are always provided\n          //  via objects\n          // NOTE: for object types, the args are the shapes themselves, except\n          //  for CLASS_OBJECT where the shape is specified within the args;\n          //  still, there is always only ever at most one object per type that\n          //  accepts args, never more\n          // NOTE: for the ARRAY type, the typeset is specified within the args\n          if (argType) {\n            // consume the object as the in-scope arg type's arguments\n            argType = undefined;\n          } else {\n            // since the typeset must be fully-qualified and we don't already\n            //  have an in-scope arg type, the typeset is invalid\n            valid = false;\n            options.failure = `${failurePrefix}: Expecting a type that takes arguments at index=${idx - 1}`;\n          }\n\n          // only go deep if the rule is a shape (which means the current in-scope\n          //  type must be an object type) or ARRAY args with `typeset` specified\n          if (valid && deep && objTypes.check(curType)) {\n            valid = deepVerifyShape(curType, rule, options, failurePrefix, idx);\n          } else if (valid && deep && curType === types.ARRAY && rule.hasOwnProperty('typeset')) {\n            // ARRAY type with args.typeset specified, and we're deep-validating\n            valid = deepVerifyArray(rule.typeset, options, failurePrefix, idx);\n          }\n          // else, either not valid, not deep, or neither shape nor ARRAY args, so assume\n          //  the rule (object) needs no further validation\n        } else {\n          // any other type in a fully-qualified array typeset is not supported\n          // NOTE: the ARRAY shorthand notation is not supported in fully-qualified\n          //  typesets, therefore a rule whose JavaScript type is an Array is not valid\n          valid = false;\n          options.failure = `${failurePrefix}: Unexpected value at index=${idx}: Expecting object (shape), non-empty string (single type), or function (custom validator)`;\n        }\n\n        return valid; // break if no longer valid\n      });\n    } else {\n      // automatically invalid if not an array because a typeset must be in the\n      //  array form in order to be FQ'd\n      valid = false;\n      options.failure = `${failurePrefix}: Typeset cannot be fully-qualified unless it is an Array of minimum length=2`;\n    }\n\n  // NEXT: if it's an array, valid, and does not need to be FQ'd, check its\n  //  definition, and deep (if requested)\n  } else if (valid && !fullyQualified && isArray(v)) {\n    const failurePrefix = `Non-qualified ${deep ? 'deep' : 'shallow'} typeset=${print(v)}`;\n    const usedTypes = {}; // @type {Object.<string,boolean>} map of simple type to `true`\n    let curType; // @type {string} current in-scope type\n    let argType; // @type {(string|undefined)} current in-scope type IIF it accepts args\n    let hasQualifier = false; // true if a qualifier is specified (not implied)\n\n    // Updates the current in-scope type (curType) and marks it as used in usedTypes.\n    //  If the type has already been used, it sets valid to false.\n    // @param {string} newType New in-scope type.\n    const updateCurType = function(newType) {\n      // set the rule as the current in-scope type\n      curType = newType;\n\n      if (usedTypes[curType]) {\n        // a type cannot appear more than once in a typeset (but nested is OK)\n        valid = false;\n        options.failure = `${failurePrefix}: Type \"${curType}\" may not be included more than once in the typeset (but may appear again in a nested typeset)`;\n      }\n\n      usedTypes[curType] = true;\n    };\n\n    // iterate through each element in the typeset array to make sure all required\n    //  rules/properties of a typeset are specified\n    _forEach(v, function(rule, idx) {\n      if (isString(rule)) {\n        if (qualifiers.check(rule)) {\n          hasQualifier = true;\n          valid = (idx === 0); // must be in the first position\n          if (!valid) {\n            options.failure = `${failurePrefix}: Unexpected qualifier at index=${idx}: There must be at most one qualifier and it may only be in the first position`;\n          }\n        } else if (types.check(rule)) {\n          // set the rule as the current in-scope type\n          updateCurType(rule);\n          // update current in-scope arg type IIF it accepts args\n          // NOTE: currently, there are no types that _require_ args, only ones\n          //  that optionally have args, so we don't have to ensure that args\n          //  were given when we change the type\n          argType = argTypes.check(rule);\n        } else {\n          // some unknown/invalid qualifier or type\n          valid = false;\n          options.failure = `${failurePrefix}: Unknown/invalid qualifier/type=${print(rule)} at index=${idx}`;\n        }\n      } else if (isValidator(rule)) {\n        // must be a validator, but there can't be more than 1, and it must be\n        //  in the last position (which enforces the 1 count), and always after\n        //  the qualifier (if any)\n        valid = (idx + 1 === v.length);\n        if (valid && !curType) {\n          // if we have a validator but no in-scope type, ANY is implied\n          updateCurType(types.ANY);\n        } else if (!valid) {\n          options.failure = `${failurePrefix}: Unexpected custom validator at index=${idx}: Must be at the last position`;\n        }\n      } else if (isTypeArgs(rule)) {\n        // could be a shape, or type args (either way, it's just one object)\n        // NOTE: for object types, the args are the shapes themselves, except\n        //  for CLASS_OBJECT where the shape is specified within the args; still,\n        //  there is always only ever at most one object per type that accepts\n        //  args, never more\n        // NOTE: for the ARRAY type, the typeset is specified within the args\n        if (!argType) {\n          // since there's no in-scope arg type, the object must be a shape using\n          //  the default OBJECT type, but it must be in the first position (or\n          //  second if the first element was a qualifier)\n          // NOTE: we do not set argType (it remains undefined here) because the\n          //  rule is the type and args all in one, therefore we consume the\n          //  rule/object as the in-scope arg type's arguments\n          updateCurType(DEFAULT_OBJECT_TYPE);\n          if (valid) {\n            valid = (idx === 0 || (hasQualifier && idx === 1));\n            // NOTE: do not set argType because the shape is the default object type's\n            //  args, so they should be consumed by the in-scope arg type\n            if (!valid) {\n              options.failure = `${failurePrefix}: Shape at index=${idx} is missing an object type in ${objTypes}: Only in the first position (or second if a qualifier is specified) does a shape assume the default object type of \"${DEFAULT_OBJECT_TYPE}\"`;\n            }\n          }\n        } else {\n          // consume the object as the in-scope arg type's arguments\n          // NOTE: currently, there are no types that _require_ args, only ones\n          //  that optionally have args, so we don't have to ensure that args\n          //  were given when we change the type\n          argType = undefined;\n        }\n\n        // only go deep if the rule is a shape, which means the current in-scope\n        //  type must be an object type, or ARRAY args with `typeset` specified\n        if (valid && deep && objTypes.check(curType)) {\n          valid = deepVerifyShape(curType, rule, options, failurePrefix, idx);\n        } else if (valid && deep && curType === types.ARRAY && rule.hasOwnProperty('typeset')) {\n          // ARRAY type with args.typeset specified, and we're deep-validating\n          valid = deepVerifyArray(rule.typeset, options, failurePrefix, idx);\n        }\n        // else, either not valid, not deep, or neither shape nor ARRAY args, so assume\n        //  the rule (object) needs no further validation\n      } else if (isArray(rule)) {\n        // a nested array implies the ARRAY type in shorthand notation\n        updateCurType(types.ARRAY);\n\n        // in this case, the in-scope arg type should be updated to ARRAY since\n        //  arrays accept optional args, but since this rule is a short-hand ARRAY\n        //  notation, which means args cannot be specified, we update argType to\n        //  undefined to clear it from the previous type (if it was set) and clear\n        //  it from this type as well\n        argType = undefined;\n\n        if (valid && deep) {\n          const opts = {deep, fullyQualified};\n          valid = isTypeset(rule, opts); // recursive\n          options.failure = opts.failure && `${failurePrefix} (index=${idx}): ${opts.failure}`;\n        }\n      } else {\n        // any other type in a non-qualified array typeset is not supported\n        // NOTE: ARRAY shorthand notation is permitted in non-qualified typesets,\n        //  therefore a rule whose JavaScript type is an Array is valid\n        valid = false;\n        options.failure = `${failurePrefix}: Unexpected value at index=${idx}: Expecting object (shape), non-empty string (single type), function (custom validator), or array (typeset)`;\n      }\n\n      return valid; // break if no longer valid\n    });\n\n    // make sure at least one type was specified\n    if (valid) {\n      valid = !!curType;\n      if (!valid) {\n        options.failure = `${failurePrefix}: Failed to find a type in the typeset`;\n      }\n    }\n\n  // NEXT: if it's a shape descriptor, check if deep is requested as long as it's\n  //  valid and does not need to be FQ'd (otherwise, 'v' must be an array and\n  //  would be invalid as a FQ'd typeset)\n  } else if (valid && deep && !fullyQualified && isShape(v)) {\n    const failurePrefix = `Non-qualified deep shape=${print(v)}`;\n\n    // we need to deep-validate a shape descriptor, which means each one of its\n    //  own-properties must be a valid typeset\n    valid = deepVerifyShape(DEFAULT_OBJECT_TYPE, v, options, failurePrefix);\n  }\n\n  // ELSE: must be valid (but non-array/shape and doesn't need to be FQ'd), or invalid\n\n  return valid;\n}\n","////// RtvSuccess Class\n\n/**\n * Runtime Verification Success Indicator\n *\n * Describes a successful runtime verification of a value against a given\n *  {@link rtvref.shape_descriptor shape} or {@link rtvref.types.typeset typeset}\n *  (note that a shape is a type of typeset).\n *\n * @class rtvref.RtvSuccess\n */\nexport default class RtvSuccess {\n  // JSDoc is provided at the @class level\n  constructor() {\n    Object.defineProperties(this, {\n      /**\n       * Flag indicating the validation succeeded. Always `true`.\n       * @readonly\n       * @name rtvref.RtvSuccess#valid\n       * @type {boolean}\n       * @see {@link rtvref.RtvError#valid}\n       */\n      valid: {\n        enumerable: true,\n        configurable: true,\n        value: true\n      }\n    });\n  }\n\n  /**\n   * A string representation of this instance.\n   * @method rtvref.RtvSuccess#toString\n   * @returns {string} String representation.\n   */\n  toString() {\n    return '{rtvref.RtvSuccess}';\n  }\n}\n","////// RtvError Class\n\nimport isTypeset from './validation/isTypeset';\nimport isArray from './validation/isArray';\n\nimport {print} from './util';\n\n// @type {function} The super class.\nconst extendsFrom = Error;\n\n// Renders a path array as a string.\n// @param {Array.<string>} path\n// @returns {string}\nconst renderPath = function(path) {\n  // returns '/' if the path is empty\n  return path.reduce(function(strPath, elem) {\n    // cast `elem` to string rather than print() to avoid quotes (should be a\n    //  string anyway)\n    return `${strPath}${strPath === '/' ? '' : '/'}${elem + ''}`;\n  }, '/');\n};\n\n/**\n * @external JS_Error\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n */\n\n/**\n * Runtime Verification Error Indicator\n *\n * Describes a failed runtime verification of a value against a given\n *  {@link rtvref.shape_descriptor shape} or {@link rtvref.types.typeset typeset}\n *  (note that a shape is a type of typeset).\n *\n * @class rtvref.RtvError\n * @extends {external:JS_Error}\n * @param {*} value The value being verified.\n * @param {rtvref.types.typeset} typeset The typeset used for verification.\n * @param {Array.<string>} path The path deep into `value` where the failure occurred.\n *  An empty array signifies the _root_ (top-level) value that was checked.\n * @param {rtvref.types.fully_qualified_typeset} cause The fully qualified typeset\n *  that caused the failure. This is normally the fully-qualified version of `typeset`,\n *  but could be a sub-type if `typeset` is an Array typeset or a\n *  {@link rtvref.shape_descriptor shape descriptor}.\n * @throws {Error} If `typeset`, `path`, or `cause` is invalid.\n */\nconst RtvError = function(value, typeset, path, cause) {\n  // NOTE: We're using the old ES5 way of doing classical inheritance rather than\n  //  an ES6 'class' because extending from Error doesn't appear to work very well,\n  //  at least not with Babel 6.x. It seems OK in Node 9.x, however. Anyway,\n  //  declaring it as `class RtvError extends Error {...}` and then attempting to\n  //  override `toString()` does not work. Calls to this method, whether direct\n  //  or implicit, continue to call `Error.prototype.toString()`, as confirmed\n  //  by checking the prototype chain, which isn't properly constructed.\n\n  if (!isTypeset(typeset)) {\n    throw new Error(`Invalid typeset: ${print(typeset)}`);\n  }\n\n  if (!isArray(path)) {\n    throw new Error(`Invalid path: ${print(path)}`);\n  }\n\n  if (!isTypeset(cause, {fullyQualified: true})) {\n    throw new Error(`Invalid cause (expecting a fully-qualified typeset): ${print(cause)}`);\n  }\n\n  // NOTE: For some reason, calling `extendsFrom.call(this, message)` has\n  //  no effect on `this` whatsoever, perhaps because it's calling native code,\n  //  or there's something strange about the built-in Error type, so we just\n  //  call the super's constructor as a formality.\n  extendsFrom.call(this);\n  this.message = `Verification failed: value=${print(value)}, path=\"${renderPath(path)}\", cause=${print(cause)}`;\n  this.name = 'RtvError';\n\n  Object.defineProperties(this, {\n    /**\n     * Flag indicating the validation failed. Always `false`.\n     * @readonly\n     * @name rtvref.RtvError#valid\n     * @type {boolean}\n     * @see {@link rtvref.RtvSuccess#valid}\n     */\n    valid: {\n      enumerable: true,\n      configurable: true,\n      value: false\n    },\n\n    /**\n     * Value that failed verification.\n     * @readonly\n     * @name rtvref.RtvError#value\n     * @type {*}\n     */\n    value: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return value;\n      }\n    },\n\n    /**\n     * Reference to the typeset used for verification.\n     * @readonly\n     * @name rtvref.RtvError#typeset\n     * @type {rtvref.types.typeset}\n     */\n    typeset: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return typeset;\n      }\n    },\n\n    /**\n     * Path from `value` to the nested property that caused the failure. This\n     *  is a shallow clone of the original `path` specified.\n     * @readonly\n     * @name rtvref.RtvError#path\n     * @type {Array.<string>}\n     */\n    path: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return path.concat(); // shallow clone\n      }\n    },\n\n    /**\n     * Fully qualified typeset that caused the failure. This will be a subset\n     *  of `typeset`, and possibly of a nested typeset within `typeset`\n     *  expressing only the direct cause of the failure.\n     *\n     * If `typeset` is `[[rtv.t.STRING]]` (a required array of required strings),\n     *  and `value` is `['a', 2]`, this property would be `[rtv.q.REQUIRED, rtv.t.STRING]`\n     *  because the failure would ultimately have been caused by the nested `rtv.t.STRING`\n     *  typeset.\n     *\n     * @readonly\n     * @name rtvref.RtvError#cause\n     * @type {rtvref.types.fully_qualified_typeset}\n     */\n    cause: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return cause;\n      }\n    }\n  });\n};\n\nRtvError.prototype = Object.create(extendsFrom.prototype);\nRtvError.prototype.constructor = RtvError;\n\n/**\n * A string representation of this instance.\n * @method rtvref.RtvError#toString\n * @returns {string} String representation.\n */\nRtvError.prototype.toString = function() {\n  return `{rtvref.RtvError value=${print(this.value)}, path=\"${renderPath(this.path)}\", cause=${print(this.cause)}}`;\n};\n\nexport default RtvError;\n","////// Main Implementation Module\n\n// NOTE: These validators are used for internal purposes. Validation of actual\n//  VALUES being checked should always be done via the _validatorMap.\nimport isArray from './validation/isArray';\nimport isObject from './validation/isObject';\nimport isString from './validation/isString';\nimport isFunction from './validation/isFunction';\nimport isBoolean from './validation/isBoolean';\n\nimport isTypeset from './validation/isTypeset';\nimport isShape from './validation/isShape';\nimport isTypeArgs from './validation/isTypeArgs';\nimport isValidator from './validation/isValidator';\n\nimport {DEFAULT_OBJECT_TYPE, argTypes, default as types} from './types';\nimport {DEFAULT_QUALIFIER, default as qualifiers} from './qualifiers';\nimport {print} from './util';\nimport RtvSuccess from './RtvSuccess';\nimport RtvError from './RtvError';\n\n/**\n * <h2>RTV Implementation Module</h2>\n *\n * Provides the internal implementation for the externally-facing {@link rtv RTV}\n *  API, as well as utilities for {@link rtvref.validator type validators}.\n *\n * @namespace rtvref.impl\n */\n\n/**\n * [Internal] Map of validator type (string) to validator function.\n * @private\n * @name rtvref.impl._validatorMap\n * @type {Object.<string,rtvref.validator.type_validator>}\n */\nconst _validatorMap = {};\n\n/**\n * Get the qualifier given any kind of typeset.\n *\n * The typeset's validity is __not__ checked. The function attempts to get a\n *  qualifier, and defaults to the {@link qualifiers.DEFAULT_QUALIFIER default qualifier}\n *  if it cannot.\n *\n * @function rtvref.impl.getQualifier\n * @param {rtvref.types.typeset} typeset The typeset in question.\n * @returns {string} The applicable {@link rtvref.qualifiers qualifier} for the\n *  specified typeset, which is assumed to be valid.\n */\nconst getQualifier = function(typeset) {\n  let qualifier = DEFAULT_QUALIFIER;\n\n  if (isArray(typeset)) {\n    // if there's a qualifier, it must be the first element, and since it's a\n    //  valid typeset, it cannot be an empty array\n    if (isString(typeset[0]) && qualifiers.check(typeset[0])) {\n      qualifier = typeset[0];\n    }\n  }\n  // else, it's either an object, function, or string, which implies the default\n  //  qualifier\n\n  return qualifier;\n};\n\n/**\n * Convert a type, qualifier, and args into a typeset.\n *\n * While the `qualifier`, `args`, and `fullyQualified` parameters are all\n *  optional and may be omitted, their order must be maintained: If needed,\n *  the `qualifier` must always be before `args`, and `args` before\n *  `fullyQualified`. Parameters with `undefined` values will be ignored.\n *\n * @function rtvref.impl.toTypeset\n * @param {string} type A single type from {@link rtvref.types.types}.\n * @param {(string|Object|boolean)} [qualifier=rtvref.qualifiers.DEFAULT_QUALIFIER]\n *  Optional qualifier from {@link rtvref.qualifiers.qualifiers}. Can also be\n *  either the `args` parameter, or the `fullyQualified` parameter if the\n *  default qualifier is being used.\n * @param {(Object|boolean)} [args] Optional\n *  {@link rtvref.types.type_arguments type arguments}. If specified, this\n *  parameter must be an {@link rtvref.types.OBJECT object}, however the\n *  properties of the object are not validated against the specified `type`\n *  (i.e. they are not guaranteed to be valid for that type). Can also be\n *  the `fullyQualified` parameter if type arguments aren't applicable.\n * @param {boolean} [fullyQualified=false] If _truthy_, the generated typeset\n *  will always be {@link rtvref.types.fully_qualified_typeset fully-qualified}.\n *  Otherwise, it'll be the simplest typeset possible.\n * @returns {rtvref.types.typeset} The simplest typeset that represents the\n *  combination of the specified type, qualifier, and args, unless `fullyQualified`\n *  was set to `true`, in which case it'll always be an array typeset and\n *  fully-qualified.\n * @throws {Error} If `type`, `qualifier`, or `args` is invalid.\n */\nconst toTypeset = function(type, ...rest) {\n  const params = rest.filter((p) => p !== undefined);\n  let qualifier = DEFAULT_QUALIFIER;\n  let typeArgs;\n  let typeArgsGiven = false;\n  let fullyQualified = false;\n\n  if (params.length === 1) {\n    if (isString(params[0])) {\n      qualifier = params[0];\n    } else if (!isBoolean(params[0])) {\n      typeArgsGiven = true;\n      typeArgs = params[0];\n    } else {\n      fullyQualified = params[0]; // must be boolean\n    }\n  } else if (params.length === 2) {\n    if (isBoolean(params[0])) {\n      throw new Error('Expecting qualifier or args as the second parameter');\n    }\n\n    if (isString(params[0])) {\n      qualifier = params[0];\n    } else {\n      typeArgsGiven = true;\n      typeArgs = params[0]; // must be args\n    }\n\n    if (!isBoolean(params[1])) {\n      if (typeArgs) {\n        throw new Error('args parameter already specified');\n      }\n      typeArgsGiven = true;\n      typeArgs = params[1];\n    } else {\n      fullyQualified = params[1]; // must be boolean\n    }\n  } else if (params.length >= 3) {\n    qualifier = params[0];\n    typeArgsGiven = true;\n    typeArgs = params[1];\n    fullyQualified = !!params[2]; // cast to boolean\n  }\n\n  types.verify(type); // catches the falsy value case too\n  qualifiers.verify(qualifier); // catches the falsy value case too\n\n  if (typeArgsGiven) {\n    argTypes.verify(type);\n    if (!isTypeArgs(typeArgs)) {\n      throw new Error(`Invalid type args=${print(typeArgs)}`);\n    }\n  }\n\n  let typeset;\n\n  if (fullyQualified) {\n    typeset = [qualifier, type];\n    if (typeArgs) {\n      typeset.push(typeArgs);\n    }\n  } else {\n    if (qualifier === DEFAULT_QUALIFIER) {\n      if (!typeArgs) {\n        typeset = type;\n      } else {\n        typeset = [type, typeArgs];\n      }\n    } else {\n      typeset = [qualifier, type];\n      if (typeArgs) {\n        typeset.push(typeArgs);\n      }\n    }\n  }\n\n  return typeset;\n};\n\n/**\n * Fully-qualifies a typeset, shallow (i.e. the first level only; nested typesets\n *  are not fully-qualified).\n *\n * This function does not modify the input `typeset`.\n *\n * @function rtvref.impl.fullyQualify\n * @param {rtvref.types.typeset} typeset Typeset to fully-qualify.\n * @param {rtvref.qualifiers} [qualifier] Optional qualifier to be used.\n *\n *  If the typeset is a simple {@link rtvref.types type},\n *   a {@link rtvref.shape_descriptor shape}, or\n *   a {@link rtvref.types.custom_validator custom validator} that was\n *   cherry-picked out of a typeset whose qualifier should be used instead of\n *   the {@link rtvref.qualifiers.DEFAULT_QUALIFIER default} one.\n *\n *  If `typeset` is an Array typeset, specifying this parameter will __override__\n *   the typeset's qualifier (otherwise, its own qualifier will be used).\n *\n * @returns {rtvref.types.fully_qualified_typeset} A new, fully-qualified typeset\n *  representing the input `typeset`. Only the first/immediate level of the\n *  input typeset is fully-qualified. The new array returned contains references\n *  to elements within the input typeset.\n * @throws {Error} If `typeset` or `qualifier` is not a valid.\n */\nconst fullyQualify = function(typeset, qualifier) {\n  if (!isTypeset(typeset)) { // start by validating so we can be confident later\n    throw new Error(`Invalid typeset=${print(typeset)}`);\n  }\n\n  if (qualifier) {\n    qualifiers.verify(qualifier);\n  }\n\n  // NOTE: from this point on, we ASSUME that the typeset is valid, which lets\n  //  us make assumptions about what we find within it; without this knowledge,\n  //  the algorithm below would not work\n\n  if (!isArray(typeset)) {\n    qualifier = qualifier || DEFAULT_QUALIFIER;\n\n    // must be either a string, shape, or function with an implied qualifier\n    if (isShape(typeset)) {\n      // must be a nested shape descriptor with default object type\n      return [qualifier, DEFAULT_OBJECT_TYPE, typeset];\n    }\n\n    // if a validator, it has an implied type of ANY\n    if (isValidator(typeset)) {\n      return [qualifier, types.ANY, typeset];\n    }\n\n    // string (basic type)\n    return [qualifier, typeset];\n  }\n\n  const fqts = []; // ALWAYS a new array\n  let curType; // @type {(string|undefined)} current type in scope or undefined if none\n\n  // typeset is an array: iterate its elements and build fqts iteratively\n  typeset.forEach(function(rule, i) {\n    // qualifiers are non-empty strings and must appear in the first element, if specified\n    if (i === 0) {\n      if (isString(rule) && qualifiers.check(rule)) {\n        fqts.push(qualifier || rule); // qualifier overrides the one in the typeset\n        return; // next rule\n      }\n\n      // rule isn't a qualifier: use override or the default, and keep processing the rule\n      fqts.push(qualifier || DEFAULT_QUALIFIER);\n    }\n\n    if (isString(rule)) {\n      // must be a type\n      curType = rule;\n      fqts.push(curType);\n    } else if (i === 0 && isShape(rule)) {\n      // nested shape descriptor using default object type\n      curType = DEFAULT_OBJECT_TYPE;\n      fqts.push(curType, rule);\n    } else if (isTypeArgs(rule)) {\n      // args for curType since typeset is an array and object is not in first position\n      fqts.push(rule);\n    } else if (isValidator(rule)) {\n      // validator: ANY is implied type if none specified\n      if (!curType) {\n        curType = types.ANY;\n        fqts.push(curType);\n      }\n\n      fqts.push(rule);\n    } else {\n      // must be an array: add implied ARRAY type and move Array typeset into args\n      curType = types.ARRAY;\n      fqts.push(curType, {typeset: rule});\n    }\n  });\n\n  return fqts;\n};\n\n/**\n * Extracts (modifies) the next complete type from an Array typeset.\n *\n * For example, if the given `typeset` is `[EXPECTED, STRING, {string_args}, FINITE]`,\n *  the returned array would be `[EXPECTED, STRING, {atring_args}]` and `typeset`\n *  would then be `[FINITE]`.\n *\n * @function rtvref.impl.extractNextType\n * @param {(rtvref.types.typeset|Array)} typeset An Array typeset from which to\n *  extract the next complete type. __This Array will be modified.__ Can also\n *  be an empty array (which is not a valid typeset, but is tolerated; see the\n *  return value for more information).\n * @param {(rtvref.qualifiers|boolean)} [qualifier] Optional, and can either\n *  be a valid qualifier, `true`, or `false`.\n *\n *  <h4>Parameter is specified, and is a qualifier</h4>\n *\n *  If __a qualifier is not found in `typeset`__, this qualifier will be used to\n *  qualify the returned sub-type Array typeset. If a qualifier is found in `typeset`,\n *  this parameter is ignored. If a qualifier is __not__ found in `typeset` and\n *  this parameter is specified, then this qualifier will be used to qualify the\n *  returned sub-type Array typeset.\n *\n *  __Examples:__\n *  - `typeset = [EXPECTED, STRING, FINITE];`\n *  - `extractNextType(typeset, REQUIRED) === [EXPECTED, STRING]`, `typeset === [FINITE]`\n *  - `extractNextType(typeset) === [FINITE]`, `typeset === []`\n *  - `typeset = [FINITE];`\n *  - `extractNextType(typeset, EXPECTED) === [EXPECTED, FINITE]`\n *\n *  <h4>Parameter is specified, and is a boolean</h4>\n *\n *  If `true`, the qualifier, if any, will be included in the returned sub-type\n *  Array typeset.\n *\n *  If `false`, the qualifier, if any, will be ignored.\n *\n *  __Examples:__\n *  - `extractNextType([STRING], true) === [STRING]`\n *  - `extractNextType([REQUIRED, STRING], true) === [EXPECTED, STRING]`\n *  - `extractNextType([REQUIRED, STRING], false) === [STRING]`\n *\n * @returns {(rtvref.types.typeset|Array)} The extracted __Array typeset__ as a\n *  new Array, which is a sub-type of the given `typeset`. This sub-typeset is\n *  not necessarily fully-qualified. If `typeset` was an empty array, an empty\n *  array is returned (which is the only case where an invalid Array typeset\n *  is tolerated, so that this function is easy to use in loops, checking for\n *  the stopping condition where the returned sub-typeset is empty).\n * @throws {Error} If `typeset` is not empty and not a valid Array typeset.\n * @throws {Error} If `qualifier` is specified but not valid.\n */\nconst extractNextType = function(typeset, qualifier) {\n  if (qualifier && !isBoolean(qualifier)) {\n    qualifiers.verify(qualifier);\n  }\n\n  // check for an array first since that's much faster than isTypeset()\n  if (!isArray(typeset) || (typeset.length > 0 && !isTypeset(typeset))) {\n    throw new Error(`Invalid Array typeset=${print(typeset)}`);\n  }\n\n  if (typeset.length === 0) {\n    return [];\n  }\n\n  const subtype = []; // subset type of `typeset`\n  let type = typeset.shift(); // NOTE: [].shift() === undefined\n\n  // FIRST: check for the qualifier, which must be the first element, if specified\n  if (qualifiers.check(type)) {\n    if (qualifier !== false) {\n      subtype.push(type); // include, and ignore the specified qualifier\n    }\n\n    // next type: typeset cannot be empty because it's valid and since\n    //  there's a qualifier, there must be at least one type in it too\n    type = typeset.shift();\n  } else {\n    // must be a type or the validator, which we'll check for below\n    // use the specified qualifier, if any, and if allowed\n    if (qualifier && !isBoolean(qualifier)) {\n      subtype.push(qualifier);\n    }\n  }\n\n  if (isString(type)) {\n    // simple type\n    subtype.push(type);\n\n    // check for args if applicable to type (as of now, there are no types that\n    //  require args)\n    if (argTypes.check(type) && typeset.length > 0 && isTypeArgs(typeset[0])) {\n      subtype.push(typeset.shift());\n    }\n  } else {\n    // Must be either a shape, an array (nested typeset), or a validator:\n    // - Shape: if the given typeset was in its original form (nothing extracted from it)\n    //  then the first type could be a shape, in which case it has an implied type of\n    //  OBJECT and is itself the args for it\n    // - Array: a nested array is an Array typeset with an implied type of ARRAY and no args\n    // - Validator: a custom validator has an implied type of ANY and no args\n    subtype.push(type);\n  }\n\n  return subtype;\n};\n\n/**\n * [Internal] Common options for the various `check*()` functions.\n * @private\n * @typedef {Object} rtvref.impl._checkOptions\n * @property {Array.<string>} path The current path into the typeset. Initially\n *  empty to signify the root (top-level) value being checked.\n * @property {boolean} isTypeset `true` if the typeset specified in the public\n *  parameters has already been validated and is a valid __shallow__ typeset;\n *  `false` otherwise (which means the typeset should first be validated before\n *  being processed).\n * @property {(string|undefined)} qualifier The {@link rtvref.qualifiers qualifier}\n *  in context; `undefined` if none. This property should be used when calling\n *  a `check*()` function for a typeset subtype where the typeset's qualifier\n *  should be attributed to the subtype rather than the\n *  {@link rtvref.qualifiers.DEFAULT_QUALIFIER default qualifier}.\n * @see {@link rtvref.impl.check}\n * @see {@link rtvref.impl.checkShape}\n * @see {@link rtvref.impl.checkType}\n */\n\n/**\n * [Internal] Gets check options for any of the `check*()` functions.\n * @private\n * @function rtvref.impl._getCheckOptions\n * @param {Object} [current] Current options, used as a basis for new options.\n * @param {Object} [override] Override options, which will overwrite any `current`\n *  options.\n * @returns {rtvref.impl._checkOptions} A full, new options object, based on\n *  `given` options, if any. Invalid given options will be ignored. The object\n *  returned may contain references to objects in `given` depending on property\n *  types.\n * @see {@link rtvref.impl.check}\n * @see {@link rtvref.impl.checkShape}\n * @see {@link rtvref.impl.checkType}\n * @throws {Error} If `current.path` or `override.path` is specified and not an array.\n */\nconst _getCheckOptions = function(current = {}, override = {}) {\n  if (current.path && !isArray(current.path)) {\n    throw new Error(`current.path must be an Array when specified, current.path=${print(current.path)}`);\n  }\n\n  if (override.path && !isArray(override.path)) {\n    throw new Error(`override.path must be an Array when specified, override.path=${print(override.path)}`);\n  }\n\n  const options = {\n    path: override.path || current.path || [],\n    isTypeset: false,\n    qualifier: override.qualifier || current.qualifier || undefined\n  };\n\n  // careful with isTypeset since it's a boolean: check for property existence\n  //  so we don't misinterpret undefined as a falsy value we should use\n  if (override.hasOwnProperty('isTypeset')) {\n    options.isTypeset = !!override.isTypeset;\n  } else if (current.hasOwnProperty('isTypeset')) {\n    options.isTypeset = !!current.isTypeset;\n  }\n\n  return options;\n};\n\n/**\n * Checks a value using a single type.\n * @function rtvref.impl.checkType\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} singleType Either a simple type name (one of\n *  {@link rtvref.types.types}), a {@link rtvref.shape_descriptor shape descriptor},\n *  or an Array typeset which represents a single type.\n *  A {@link rtvref.types.custom_validator custom validator} is not considered\n *  a valid single type.\n *\n *  In the string/simple case, the\n *   {@link rtvref.qualifiers.DEFAULT_QUALIFIER default qualifier} is assumed.\n *\n *  In the shape descriptor case, the\n *   {@link rtvref.types.DEFAULT_OBJECT_TYPE default object type} is assumed.\n *\n *  In the Array case, the qualifier is optional, and a type, along with args,\n *   if any, is expected (e.g. `[type]`, `[qualifier, type]`, `[type, args]`, or\n *   `[qualifier, type, args]`). Note that the type may be implied the shorthand\n *   notation is being used for an ARRAY, or if the\n *   {@link rtvref.types.DEFAULT_OBJECT_TYPE default object type} is being implied.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} A success indicator if the\n *  `value` is compliant to the type; an error indicator if not.\n * @throws {Error} If `singleType` is not a valid simple type or single type.\n * @see {@link rtvref.types}\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst checkWithType = function(value, singleType /*, options*/) {\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  if (!options.isTypeset && !isTypeset(singleType)) {\n    throw new Error(`Invalid typeset in singleType=${print(singleType)}`);\n  }\n\n  options.isTypeset = true;\n\n  const qualifier = options.qualifier || getQualifier(singleType);\n\n  let type; // @type {string}\n  let args; // @type {Object}\n\n  if (isString(singleType)) {\n    type = singleType;\n    // simple type: no args\n  } else if (isShape(singleType)) {\n    type = DEFAULT_OBJECT_TYPE;\n    args = singleType;\n  } else if (isArray(singleType)) {\n    const singleTypeCopy = fullyQualify(singleType); // make any implied types concrete\n    const typeset = extractNextType(singleTypeCopy, false);\n\n    if (singleTypeCopy.length > 0) { // if singleType was just one type, copy should be empty now\n      throw new Error(`Specified singleType=${print(singleType)} typeset must represent a single type`);\n    }\n\n    type = typeset[0];\n    args = typeset.length > 1 ? typeset[1] : undefined;\n  } else {\n    throw new Error(`Specified singleType=${print(singleType)} must be a string, shape, or Array`);\n  }\n\n  if (_validatorMap[type]) {\n    // call the validator for the specified type\n    let result = _validatorMap[type](value, qualifier, args);\n\n    if (!result.valid) {\n      // create a new error from the original, but with the current path and the\n      //  original path combined\n      result = new RtvError(value, singleType, options.path.concat(result.path),\n          result.cause);\n    }\n\n    return result;\n  }\n\n  throw new Error(`Missing validator for type=${print(type)}`);\n};\n\n/**\n * Checks a value using a {@link rtvref.shape_descriptor shape descriptor} and\n *  ensure the value's type is the default object type.\n * @function rtvref.impl.checkShape\n * @param {Object} value Value to check. Must be of the\n *  {@link rtvref.types.DEFAULT_OBJECT_TYPE default} object type.\n * @param {Object} shape Expected shape of the `value`. Must be an\n *  {@link rtvref.types.OBJECT OBJECT}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} A success indicator if the\n *  `value` is compliant to the shape; an error indicator if not.\n * @throws {Error} If `shape` is not an {@link rtvref.types.OBJECT OBJECT}.\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst checkWithShape = function(value, shape /*, options*/) {\n  if (!isShape(shape)) {\n    throw new Error(`Invalid shape=${print(shape)}`);\n  }\n\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  // type validators are ultimately responsible for checking values against shapes\n  return checkWithType(value, shape, _getCheckOptions(options));\n};\n\n/**\n * Checks a value using an Array typeset.\n * @function rtvref.impl.checkTypeset\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} typeset The Array typeset to check against.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the `value`\n *  is compliant to the `typeset`; error indicator otherwise. An exception is\n *  __not__ thrown if the `value` is non-compliant.\n * @throws {Error} If `typeset` is not a valid Array typeset.\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst checkWithArray = function(value, typeset /*, options*/) {\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  // check for an array first since that's must faster than isTypeset()\n  if (!isArray(typeset) || !(options.isTypeset || isTypeset(typeset))) {\n    throw new Error(`Invalid Array typeset=${print(typeset)}`);\n  }\n\n  options.isTypeset = true;\n\n  let match; // @type {(rtvref.types.fully_qualified_typeset|undefined)}\n  const qualifier = options.qualifier || getQualifier(typeset);\n\n  // consider each type in the typeset until we find one that matches the value\n  // NOTE: an Array typeset represents multiple possibilities for a type match\n  //  using a short-circuit OR conjunction\n  // NOTE: due to the isTypeset check above, we can assume that each 'type' is\n  //  a SHALLOW-valid typeset (meaning, if it's an Array typeset, we cannot\n  //  assume that itself is valid because the isTypeset check was just shallow)\n  const typesetCopy = typeset.concat(); // shallow clone so we can modify the array locally\n  let subtype = extractNextType(typesetCopy, false); // exclude qualifier we already have\n  while (subtype.length > 0) {\n    // check for the validator, which will always come alone, and since the validator\n    //  must be at the end of an Array typeset, it also signals the end of all subtypes\n    if (subtype.length === 1 && isValidator(subtype[0])) {\n      // if we reach the validator (which must be the very last element) in this\n      //  loop, none of the types matched, unless the validator is the only\n      //  type in the typeset, at which point it gets an implied type of ANY,\n      //  which matches any value\n      // NOTE: we have to test the original typeset for the ANY condition\n      if (typeset.length === 1 || (typeset.length === 2 && qualifiers.check(typeset[0]))) {\n        match = fullyQualify(types.ANY, qualifier);\n      }\n\n      break; // break (since this must be the last element in typeset)\n    } else {\n      const result = checkWithType(value, subtype, _getCheckOptions(options, {\n        path: options.path,\n        qualifier,\n        isTypeset: true // subtype must be valid per extractNextType()\n      }));\n\n      if (result.valid) {\n        match = fullyQualify(subtype, qualifier);\n        break; // break on first match\n      }\n    }\n\n    // next subtype\n    subtype = extractNextType(typesetCopy);\n  }\n\n  let err; // @type {(RtvError|undefined)}\n\n  if (match) {\n    // check for a validator at the end of the Array typeset and invoke it\n    const lastType = typeset[typeset.length - 1];\n    if (isValidator(lastType)) {\n      if (!lastType(value, match, typeset)) {\n        // invalid in spite of the match since the validator said no\n        err = new RtvError(value, typeset, options.path, fullyQualify(typeset, qualifier));\n      }\n      // else, valid!\n    }\n    // else, valid, since we have a match\n  } else {\n    // no match\n    err = new RtvError(value, typeset, options.path, fullyQualify(typeset, qualifier));\n  }\n\n  return err || (new RtvSuccess());\n};\n\n/**\n * Checks a value against a typeset.\n * @function rtvref.impl.check\n * @param {*} value Value to check.\n * @param {rtvref.types.typeset} typeset Expected shape/type of the value.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the `value`\n *  is compliant to the `typeset`; error indicator otherwise. An exception is\n *  __not__ thrown if the `value` is non-compliant.\n * @throws {Error} If `typeset` is not a valid typeset.\n */\n// @param {rtvref.impl._checkOptions} [options] (internal parameter)\nconst check = function(value, typeset /*, options*/) {\n  const options = _getCheckOptions(arguments.length > 2 ? arguments[2] : undefined);\n\n  try {\n    if (options.isTypeset || isTypeset(typeset)) {\n      options.isTypeset = true;\n\n      if (isString(typeset)) {\n        // simple type: check value is of the type\n        return checkWithType(value, typeset, options);\n      }\n\n      if (isValidator(typeset)) {\n        // custom validator: bare function implies the ANY type\n        const match = types.ANY;\n        const fqMatch = fullyQualify(match, options.qualifier);\n\n        // value must be ANY type, and custom validator must return true\n        const result = checkWithType(value, match, options);\n        if (!result.valid) {\n          return result;\n        }\n\n        // call the custom validator\n        if (typeset(value, fqMatch, match)) {\n          return new RtvSuccess();\n        }\n\n        return new RtvError(value, match, options.path, fqMatch);\n      }\n\n      if (isShape(typeset)) {\n        // shape descriptor: check value against shape\n        return checkWithShape(value, typeset, options);\n      }\n\n      if (isArray(typeset)) {\n        // Array typeset: check value against all types in typeset\n        return checkWithArray(value, typeset, options);\n      }\n\n      throw new Error(`Invalid JavaScript type for typeset=${print(typeset)}`);\n    } else {\n      throw new Error(`Invalid typeset=${print(typeset)} specified`);\n    }\n  } catch (checkErr) {\n    const err = new Error(`Cannot check value: ${checkErr.message}`);\n    err.rootCause = checkErr;\n    throw err;\n  }\n};\n\n/**\n * [Internal] Registers a validator, adding a new type that can be\n *  {@link rtvref.impl.check checked}.\n *\n * If a validator has already been registered for a particular type, the previous\n *  validator is replaced by the newer one.\n *\n * @private\n * @function rtvref.impl._registerType\n * @param {rtvref.validator} validator The validator representing the type to be\n *  registered.\n * @throws {Error} if `validator` does not have the expected interface.\n */\nconst _registerType = function(validator) {\n  // NOTE: we can't dogfood and describe a shape to check() because the types\n  //  needed may not have been registered yet\n  if (!isObject(validator) || !types.check(validator.type) ||\n      !isFunction(validator.config) || !isFunction(validator.default)) {\n\n    throw new Error(`Cannot register an invalid validator for type=${print(validator && validator.type)}: missing at least one required property in [type, config, default]`);\n  }\n\n  _validatorMap[validator.type] = validator.default;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Define and export the module\n\n// define the module to be exported: properties/methods with an underscore prefix\n//  will be converted to non-enumerable properties/methods\nconst impl = {\n  // internal\n  _validatorMap, // exposed mainly to support unit testing\n  _registerType,\n  _getCheckOptions,\n  // public\n  getQualifier,\n  toTypeset,\n  fullyQualify,\n  extractNextType,\n  checkWithType,\n  checkWithShape,\n  checkWithArray,\n  check\n};\n\n// make properties/methods with underscore prefix internal by making them\n//  non-enumerable (but otherwise, a normal property)\nObject.keys(impl).forEach(function(prop) {\n  if (prop.indexOf('_') === 0) {\n    Object.defineProperty(impl, prop, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: impl[prop]\n    });\n  }\n});\n\nexport default impl;\n","////// isAny validation\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.ANY ANY}\n * @const {string} rtvref.validation.isAny.type\n */\nexport const type = types.ANY;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.ANY ANY} type.\n * @function rtvref.validation.isAny.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isAny(v) {\n  return true; // anything goes, even undefined and null\n}\n","////// valAny validator\n\nimport {type, default as isAny} from '../validation/isAny';\n\nimport qualifiers from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valAny._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.ANY ANY}\n * @const {string} rtvref.validator.valAny.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valAny.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ANY ANY} type.\n * @function rtvref.validator.valAny.default\n * @param {*} v Value to validate.\n  * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n* @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valAny(v, q = REQUIRED) {\n  // NOTE: no point checking basic qualifier rules since this type allows both\n  //  undefined and null regardless of the qualifier\n\n  if (isAny(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// isAnyObject validation\n\nimport {default as _isObject} from 'lodash/isObject';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.ANY_OBJECT ANY_OBJECT}\n * @const {string} rtvref.validation.isAnyObject.type\n */\nexport const type = types.ANY_OBJECT;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.ANY_OBJECT ANY_OBJECT} type.\n * @function rtvref.validation.isAnyObject.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isAnyObject(v) {\n  return _isObject(v);\n}\n","////// valAnyObject validator\n\nimport _forEach from 'lodash/forEach';\n\nimport {type, default as isAnyObject} from '../validation/isAnyObject';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport isShape from '../validation/isShape';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valAnyObject._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.ANY_OBJECT ANY_OBJECT}\n * @const {string} rtvref.validator.valAnyObject.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valAnyObject.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ANY_OBJECT ANY_OBJECT} type.\n * @function rtvref.validator.valAnyObject.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valAnyObject(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (!isAnyObject(v)) {\n    return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n  }\n\n  // args is the optional shape: ignore if it isn't a shape, like other validators\n  //  ignore invalid args properties\n  const shape = (args && isShape(args)) ? args : undefined;\n  let err; // @type {(RtvError|undefined)}\n\n  // only consider enumerable, own-properties of the shape\n  _forEach(shape, function(typeset, prop) {\n    const result = impl.check(v[prop], typeset); // check prop value against shape prop typeset\n\n    if (!result.valid) {\n      err = new RtvError(v, shape, [prop].concat(result.path), result.cause);\n    }\n\n    return !err; // break on first error\n  });\n\n  return err || (new RtvSuccess());\n}\n","var root = require('./_root');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsFinite = root.isFinite;\n\n/**\n * Checks if `value` is a finite primitive number.\n *\n * **Note:** This method is based on\n * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n * @example\n *\n * _.isFinite(3);\n * // => true\n *\n * _.isFinite(Number.MIN_VALUE);\n * // => true\n *\n * _.isFinite(Infinity);\n * // => false\n *\n * _.isFinite('3');\n * // => false\n */\nfunction isFinite(value) {\n  return typeof value == 'number' && nativeIsFinite(value);\n}\n\nmodule.exports = isFinite;\n","////// isFinite validation\n\nimport {default as _isFinite} from 'lodash/isFinite';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.FINITE FINITE}\n * @const {string} rtvref.validation.isFinite.type\n */\nexport const type = types.FINITE;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.FINITE FINITE} type.\n *\n * Determines if a value is a finite number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validation.isFinite.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isFinite(v) {\n  return _isFinite(v); // eliminates NaN, +/-Infinity\n}\n","////// valArray validator\n\nimport {default as _forEach} from 'lodash/forEach';\n\nimport {type, default as isArray} from '../validation/isArray';\n\nimport isFinite from '../validation/isFinite';\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valArray._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.ARRAY ARRAY}\n * @const {string} rtvref.validator.valArray.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valArray.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ARRAY ARRAY} type.\n * @function rtvref.validator.valArray.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.ARRAY_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valArray(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isArray(v);\n  let result; // @type {(rtvref.RtvSuccess|rtvref.RtvError)}\n\n  if (valid && args) { // then check args\n    if (isFinite(args.length) && args.length >= 0) {\n      valid = (v.length === args.length);\n    } else {\n      let min;\n      if (valid && isFinite(args.min) && args.min >= 0) {\n        min = args.min;\n        valid = (v.length >= min);\n      }\n\n      if (valid && isFinite(args.max) && args.max >= 0) {\n        if (min === undefined || args.max >= min) {\n          valid = (v.length <= args.max);\n        } // else, ignore\n      }\n    }\n\n    if (valid && args.typeset) {\n      // check each element in `value` against the typeset\n      _forEach(v, function(elem, idx) {\n        result = impl.check(elem, args.typeset);\n        valid = result.valid;\n\n        if (!result.valid) {\n          // create a new error from the original, but with the index prepended to the path\n          result = new RtvError(v, impl.toTypeset(type, q, args),\n              [idx].concat(result.path), result.cause);\n        }\n\n        return valid; // break on first invalid element\n      });\n    }\n  }\n\n  if (!result) {\n    if (valid) {\n      result = new RtvSuccess();\n    } else {\n      result = new RtvError(v, impl.toTypeset(type, q, args), [],\n          impl.toTypeset(type, q, args, true));\n    }\n  }\n\n  return result;\n}\n","////// valBoolean validator\n\nimport {type, default as isBoolean} from '../validation/isBoolean';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valBoolean._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.BOOLEAN BOOLEAN}\n * @const {string} rtvref.validator.valBoolean.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valBoolean.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.BOOLEAN BOOLEAN} type.\n *\n * Determines if a value is a boolean literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Boolean(true)`, which is an object that is a boolean.\n *\n * @function rtvref.validator.valBoolean.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valBoolean(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isBoolean(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// isPlainObject validation\n\nimport {default as _isPlainObject} from 'lodash/isPlainObject';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}\n * @const {string} rtvref.validation.isPlainObject.type\n */\nexport const type = types.PLAIN_OBJECT;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT} type.\n * @function rtvref.validation.isPlainObject.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isPlainObject(v) {\n  return _isPlainObject(v);\n}\n","////// isClassObject validation\n\nimport isObject from './isObject';\nimport isPlainObject from './isPlainObject';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT}\n * @const {string} rtvref.validation.isClassObject.type\n */\nexport const type = types.CLASS_OBJECT;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} type.\n * @function rtvref.validation.isClassObject.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isClassObject(v) {\n  return isObject(v) && !isPlainObject(v);\n}\n","////// valClassObject validator\n\nimport _forEach from 'lodash/forEach';\n\nimport {type, default as isClassObject} from '../validation/isClassObject';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport isShape from '../validation/isShape';\nimport isFunction from '../validation/isFunction';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valClassObject._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT}\n * @const {string} rtvref.validator.valClassObject.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valClassObject.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.CLASS_OBJECT CLASS_OBJECT} type.\n * @function rtvref.validator.valClassObject.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valClassObject(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isClassObject(v);\n  let result; // @type {(rtvref.RtvSuccess|rtvref.RtvError)}\n\n  if (valid && args) { // then check args\n    // check constructor first since it's more efficient than the shape\n    if (args.ctr && isFunction(args.ctr)) {\n      valid = (v instanceof args.ctr);\n    }\n\n    if (valid) {\n      // now validate the shape, if any\n      const shape = (args.shape && isShape(args.shape)) ? args.shape : undefined;\n      let err; // @type {(RtvError|undefined)}\n\n      // only consider enumerable, own-properties of the shape\n      _forEach(shape, function(typeset, prop) {\n        const propResult = impl.check(v[prop], typeset); // check prop value against shape prop typeset\n\n        if (!propResult.valid) {\n          err = new RtvError(v, impl.toTypeset(type, q, args),\n              [prop].concat(propResult.path), propResult.cause);\n        }\n\n        return !err; // break on first error\n      });\n\n      valid = !err;\n      result = err;\n    }\n  }\n\n  if (!result) {\n    if (valid) {\n      result = new RtvSuccess();\n    } else {\n      result = new RtvError(v, impl.toTypeset(type, q, args), [],\n          impl.toTypeset(type, q, args, true));\n    }\n  }\n\n  return result;\n}\n","////// valDate validator\n\nimport {type, default as isDate} from '../validation/isDate';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valDate._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.DATE DATE}\n * @const {string} rtvref.validator.valDate.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valDate.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.DATE DATE} type.\n * @function rtvref.validator.valDate.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valDate(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isDate(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// valError validator\n\nimport {type, default as isError} from '../validation/isError';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valError._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.ERROR ERROR}\n * @const {string} rtvref.validator.valError.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valError.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.ERROR ERROR} type.\n * @function rtvref.validator.valError.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valError(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isError(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// valFinite validator\n\nimport {type, default as isFinite} from '../validation/isFinite';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valFinite._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.FINITE FINITE}\n * @const {string} rtvref.validator.valFinite.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valFinite.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.FINITE FINITE} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validator.valFinite.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valFinite(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isFinite(v);\n\n  if (valid && args) { // then check args against normal type range\n    if (isFinite(args.exact)) {\n      valid = (v === args.exact);\n    } else {\n      let min;\n      if (valid && isFinite(args.min)) {\n        min = args.min;\n        valid = (v >= min);\n      }\n\n      if (valid && isFinite(args.max)) {\n        if (min === undefined || args.max >= min) {\n          valid = (v <= args.max);\n        } // else, ignore\n      }\n    }\n  }\n\n  if (valid) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q, args), [],\n      impl.toTypeset(type, q, args, true));\n}\n","////// valFunction validator\n\nimport {type, default as isFunction} from '../validation/isFunction';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * Type: {@link rtvref.types.FUNCTION FUNCTION}\n * @const {string} rtvref.validator.valFunction.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valFunction.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.FUNCTION FUNCTION} type.\n * @function rtvref.validator.valFunction.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valFunction(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isFunction(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// isHashMap validation\n\nimport isObject from './isObject';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.HASH_MAP HASH_MAP}\n * @const {string} rtvref.validation.isHashMap.type\n */\nexport const type = types.HASH_MAP;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.HASH_MAP HASH_MAP} type.\n * @function rtvref.validation.isHashMap.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isHashMap(v) {\n  return isObject(v); // same rules as OBJECT\n}\n","////// valHashMap validator\n\nimport _forEach from 'lodash/forEach';\n\nimport {type, default as isHashMap} from '../validation/isHashMap';\n\nimport isFinite from '../validation/isFinite';\nimport isString from '../validation/isString';\nimport isTypeset from '../validation/isTypeset';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport {print} from '../util';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valHashMap._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.HASH_MAP HASH_MAP}\n * @const {string} rtvref.validator.valHashMap.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valHashMap.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.HASH_MAP HASH_MAP} type.\n * @function rtvref.validator.valHashMap.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.collection_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valHashMap(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isHashMap(v);\n  let result; // @type {(rtvref.RtvSuccess|rtvref.RtvError)}\n\n  if (valid && args) { // then check args\n    const keys = Object.keys(v);\n\n    // start with the easiest/most efficient test: length\n    if (valid && isFinite(args.length) && args.length >= 0) {\n      valid = (keys.length === args.length);\n    }\n\n    // remaining args, if specified, require iterating potentially the entire map\n    if (valid) {\n      // get the key expression\n      const keyExp = (args.keyExp && isString(args.keyExp)) ? args.keyExp : undefined;\n      // get the key expression flags only if we have a key expression\n      const keyFlagSpec = (keyExp && args.keyFlagSpec && isString(args.keyFlagSpec)) ?\n        args.keyFlagSpec : undefined;\n      // get the typeset for values\n      const tsValues = isTypeset(args.values) ? args.values : undefined;\n\n      if (keyExp || tsValues) {\n        const reKeys = keyExp ? new RegExp(keyExp, keyFlagSpec) : undefined;\n\n        _forEach(keys, function(key) {\n          const value = v[key];\n\n          if (reKeys) {\n            valid = reKeys.test(key); // check key against regex since it's a string\n            if (!valid) {\n              result = new RtvError(v, impl.toTypeset(type, q, args),\n                  [`key=${print(key)}`], impl.toTypeset(type, q, args, true));\n            }\n          }\n\n          if (valid && tsValues) {\n            result = impl.check(value, tsValues); // check VALUE against typeset\n            valid = result.valid;\n\n            if (!result.valid) {\n              // create a new error from the original, but still with the KEY added to the path\n              result = new RtvError(v, impl.toTypeset(type, q, args),\n                  [`valueKey=${print(key)}`].concat(result.path), result.cause);\n            }\n          }\n\n          return valid; // break on first invalid key or value\n        });\n      }\n    }\n  }\n\n  if (!result) {\n    if (valid) {\n      result = new RtvSuccess();\n    } else {\n      result = new RtvError(v, impl.toTypeset(type, q, args), [],\n          impl.toTypeset(type, q, args, true));\n    }\n  }\n\n  return result;\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var toInteger = require('./toInteger');\n\n/**\n * Checks if `value` is an integer.\n *\n * **Note:** This method is based on\n * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n * @example\n *\n * _.isInteger(3);\n * // => true\n *\n * _.isInteger(Number.MIN_VALUE);\n * // => false\n *\n * _.isInteger(Infinity);\n * // => false\n *\n * _.isInteger('3');\n * // => false\n */\nfunction isInteger(value) {\n  return typeof value == 'number' && value == toInteger(value);\n}\n\nmodule.exports = isInteger;\n","////// isInt validation\n\nimport {default as _isInteger} from 'lodash/isInteger';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.INT INT}\n * @const {string} rtvref.validation.isInt.type\n */\nexport const type = types.INT;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.INT INT} type.\n *\n * Determines if a value is an integer literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validation.isInt.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isInt(v) {\n  return _isInteger(v); // eliminates NaN, +/-Infinity, floats\n}\n","////// valInt validator\n\nimport {type, default as isInt} from '../validation/isInt';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valInt._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.INT INT}\n * @const {string} rtvref.validator.valInt.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valInt.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.INT INT} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validator.valInt.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valInt(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isInt(v);\n\n  if (valid && args) { // then check args against normal type range\n    if (isInt(args.exact)) {\n      valid = (v === args.exact);\n    } else {\n      let min;\n      if (valid && isInt(args.min)) {\n        min = args.min;\n        valid = (v >= min);\n      }\n\n      if (valid && isInt(args.max)) {\n        if (min === undefined || args.max >= min) {\n          valid = (v <= args.max);\n        } // else, ignore\n      }\n    }\n  }\n\n  if (valid) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q, args), [],\n      impl.toTypeset(type, q, args, true));\n}\n","////// isNull validation\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.NULL NULL}\n * @const {string} rtvref.validation.isFunction.type\n */\nexport const type = types.NULL;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.NULL NULL} type.\n * @function rtvref.validation.isNull.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isNull(v) {\n  return v === null;\n}\n","////// isJson validation\n\nimport isNull from './isNull';\nimport isString from './isString';\nimport isBoolean from './isBoolean';\nimport isFinite from './isFinite';\nimport isPlainObject from './isPlainObject';\nimport isArray from './isArray';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.JSON JSON}\n * @const {string} rtvref.validation.isJson.type\n */\nexport const type = types.JSON;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.JSON JSON} type.\n * @function rtvref.validation.isJson.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isJson(v) {\n  return isNull(v) ||\n      isString(v, {allowEmpty: true}) ||\n      isBoolean(v) ||\n      isFinite(v) ||\n      isPlainObject(v) ||\n      isArray(v);\n}\n","////// valJson validator\n\nimport {type, default as isJson} from '../validation/isJson';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valJson._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.JSON JSON}\n * @const {string} rtvref.validator.valJson.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valJson.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.JSON JSON} type.\n * @function rtvref.validator.valJson.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valJson(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isJson(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// valMap validator\n\nimport {type, default as isMap} from '../validation/isMap';\n\nimport isFinite from '../validation/isFinite';\nimport isString from '../validation/isString';\nimport isTypeset from '../validation/isTypeset';\n\nimport types from '../types';\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport {print} from '../util';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valMap._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.MAP MAP}\n * @const {string} rtvref.validator.valMap.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valMap.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n//\n// Determines if a typeset represents a string, and only a string.\n// @param {rtvref.types.typeset} ts Typeset to check.\n// @return {boolean} `true` if so; `false` otherwise.\n//\nconst isStringTypeset = function(ts) {\n  const fqts = impl.fullyQualify(ts);\n\n  // must be `[qualifier, STRING]`, otherwise no\n  return (fqts.length === 2 && fqts[1] === types.STRING);\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.MAP MAP} type.\n * @function rtvref.validator.valMap.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.collection_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valMap(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isMap(v);\n  let result; // @type {(rtvref.RtvSuccess|rtvref.RtvError)}\n\n  if (valid && args) { // then check args\n    // start with the easiest/most efficient test: length\n    if (valid && isFinite(args.length) && args.length >= 0) {\n      valid = (v.size === args.length);\n    }\n\n    // remaining args, if specified, require iterating potentially the entire map\n    if (valid) {\n      // get the typeset for keys\n      const tsKeys = isTypeset(args.keys) ? args.keys : undefined;\n      // get the key expression only if the keys are expected to be strings\n      const tsKeysIsString = !!(tsKeys && isStringTypeset(tsKeys));\n      const keyExp = (tsKeysIsString && args.keyExp && isString(args.keyExp)) ?\n        args.keyExp : undefined;\n      // get the key expression flags only if we have a key expression\n      const keyFlagSpec = (keyExp && args.keyFlagSpec && isString(args.keyFlagSpec)) ?\n        args.keyFlagSpec : undefined;\n      // get the typeset for values\n      const tsValues = isTypeset(args.values) ? args.values : undefined;\n\n      if (tsKeys || tsValues) {\n        const reKeys = keyExp ? new RegExp(keyExp, keyFlagSpec) : undefined;\n        const it = v.entries(); // iterator\n\n        for (let elem of it) {\n          const [key, value] = elem;\n\n          if (tsKeys) {\n            result = impl.check(key, tsKeys); // check KEY against typeset\n            valid = result.valid;\n\n            if (!result.valid) {\n              // create a new error from the original, but with the KEY prepended to the path\n              result = new RtvError(v, impl.toTypeset(type, q, args),\n                  [`key=${print(key)}`].concat(result.path), result.cause);\n            }\n\n            if (valid && tsKeysIsString && reKeys) {\n              valid = reKeys.test(key); // check key against regex since it's a string\n              if (!valid) {\n                result = new RtvError(v, impl.toTypeset(type, q, args),\n                    [`key=${print(key)}`], impl.toTypeset(type, q, args, true));\n              }\n            }\n          }\n\n          if (valid && tsValues) {\n            result = impl.check(value, tsValues); // check VALUE against typeset\n            valid = result.valid;\n\n            if (!result.valid) {\n              // create a new error from the original, but still with the KEY added to the path\n              result = new RtvError(v, impl.toTypeset(type, q, args),\n                  [`valueKey=${print(key)}`].concat(result.path), result.cause);\n            }\n          }\n\n          if (!valid) { // break on first invalid key or value\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (!result) {\n    if (valid) {\n      result = new RtvSuccess();\n    } else {\n      result = new RtvError(v, impl.toTypeset(type, q, args), [],\n          impl.toTypeset(type, q, args, true));\n    }\n  }\n\n  return result;\n}\n","////// valNull validator\n\nimport {type, default as isNull} from '../validation/isNull';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valNull._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.NULL NULL}\n * @const {string} rtvref.validator.valNull.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valNull.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.NULL NULL} type.\n * @function rtvref.validator.valNull.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valNull(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isNull(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","var isNumber = require('./isNumber');\n\n/**\n * Checks if `value` is `NaN`.\n *\n * **Note:** This method is based on\n * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n * `undefined` and other non-number values.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n * @example\n *\n * _.isNaN(NaN);\n * // => true\n *\n * _.isNaN(new Number(NaN));\n * // => true\n *\n * isNaN(undefined);\n * // => true\n *\n * _.isNaN(undefined);\n * // => false\n */\nfunction isNaN(value) {\n  // An `NaN` primitive is the only value that is not equal to itself.\n  // Perform the `toStringTag` check first to avoid errors with some\n  // ActiveX objects in IE.\n  return isNumber(value) && value != +value;\n}\n\nmodule.exports = isNaN;\n","////// isNumber validation\n\nimport {default as _isNaN} from 'lodash/isNaN';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.NUMBER NUMBER}\n * @const {string} rtvref.validation.isNumber.type\n */\nexport const type = types.NUMBER;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.NUMBER NUMBER} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number, neither does it\n *  validate `NaN`.\n *\n * @function rtvref.validation.isNumber.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isNumber(v) {\n  return (typeof v === 'number' && !_isNaN(v)); // allows +/-Infinity\n}\n","////// valNumber validator\n\nimport {default as _isNaN} from 'lodash/isNaN';\n\nimport {type, default as isNumber} from '../validation/isNumber';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valNumber._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.NUMBER NUMBER}\n * @const {string} rtvref.validator.valNumber.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valNumber.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.NUMBER NUMBER} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validator.valNumber.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valNumber(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isNumber(v);\n\n  // all qualifiers other than REQUIRED allow NaN\n  if (q !== REQUIRED && _isNaN(v)) {\n    valid = true;\n  }\n\n  if (valid && args) { // then check args against normal type range\n    // NOTE: NaN is OK for the exact arg (careful: NaN !== NaN...)\n    if (isNumber(args.exact) || _isNaN(args.exact)) {\n      valid = (v === args.exact) || (_isNaN(v) && _isNaN(args.exact));\n    } else {\n      let min;\n      if (valid && isNumber(args.min)) {\n        min = args.min;\n        valid = (v >= min);\n      }\n\n      if (valid && isNumber(args.max)) {\n        if (min === undefined || args.max >= min) {\n          valid = (v <= args.max);\n        } // else, ignore\n      }\n    }\n  }\n\n  if (valid) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q, args), [],\n      impl.toTypeset(type, q, args, true));\n}\n","////// valObject validator\n\nimport _forEach from 'lodash/forEach';\n\nimport {type, default as isObject} from '../validation/isObject';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport isShape from '../validation/isShape';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valObject._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.OBJECT OBJECT}\n * @const {string} rtvref.validator.valObject.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valObject.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.OBJECT OBJECT} type.\n * @function rtvref.validator.valObject.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valObject(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (!isObject(v)) {\n    return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n  }\n\n  // args is the optional shape: ignore if it isn't a shape, like other validators\n  //  ignore invalid args properties\n  const shape = (args && isShape(args)) ? args : undefined;\n  let err; // @type {(RtvError|undefined)}\n\n  // only consider enumerable, own-properties of the shape\n  _forEach(shape, function(typeset, prop) {\n    const result = impl.check(v[prop], typeset); // check prop value against shape prop typeset\n\n    if (!result.valid) {\n      err = new RtvError(v, shape, [prop].concat(result.path), result.cause);\n    }\n\n    return !err; // break on first error\n  });\n\n  return err || (new RtvSuccess());\n}\n","////// valPlainObject validator\n\nimport _forEach from 'lodash/forEach';\n\nimport {type, default as isPlainObject} from '../validation/isPlainObject';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport isShape from '../validation/isShape';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valPlainObject._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT}\n * @const {string} rtvref.validator.valPlainObject.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valPlainObject.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.PLAIN_OBJECT PLAIN_OBJECT} type.\n * @function rtvref.validator.valPlainObject.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valPlainObject(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (!isPlainObject(v)) {\n    return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n  }\n\n  // args is the optional shape: ignore if it isn't a shape, like other validators\n  //  ignore invalid args properties\n  const shape = (args && isShape(args)) ? args : undefined;\n  let err; // @type {(RtvError|undefined)}\n\n  // only consider enumerable, own-properties of the shape\n  _forEach(shape, function(typeset, prop) {\n    const result = impl.check(v[prop], typeset); // check prop value against shape prop typeset\n\n    if (!result.valid) {\n      err = new RtvError(v, shape, [prop].concat(result.path), result.cause);\n    }\n\n    return !err; // break on first error\n  });\n\n  return err || (new RtvSuccess());\n}\n","////// valPromise validator\n\nimport {type, default as isPromise} from '../validation/isPromise';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valPromise._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.PROMISE PROMISE}\n * @const {string} rtvref.validator.valPromise.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valPromise.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.PROMISE PROMISE} type.\n * @function rtvref.validator.valPromise.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valPromise(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isPromise(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// valRegExp validator\n\nimport {type, default as isRegExp} from '../validation/isRegExp';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valRegExp._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.REGEXP REGEXP}\n * @const {string} rtvref.validator.valRegExp.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valRegExp.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.REGEXP REGEXP} type.\n * @function rtvref.validator.valRegExp.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valRegExp(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isRegExp(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","var isInteger = require('./isInteger');\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n * double precision number which isn't the result of a rounded unsafe integer.\n *\n * **Note:** This method is based on\n * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n * @example\n *\n * _.isSafeInteger(3);\n * // => true\n *\n * _.isSafeInteger(Number.MIN_VALUE);\n * // => false\n *\n * _.isSafeInteger(Infinity);\n * // => false\n *\n * _.isSafeInteger('3');\n * // => false\n */\nfunction isSafeInteger(value) {\n  return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isSafeInteger;\n","////// isSafeInt validation\n\nimport {default as _isSafeInteger} from 'lodash/isSafeInteger';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.SAFE_INT SAFE_INT}\n * @const {string} rtvref.validation.isSafeInt.type\n */\nexport const type = types.SAFE_INT;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.SAFE_INT SAFE_INT} type.\n *\n * Determines if a value is an integer literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validation.isSafeInt.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isSafeInt(v) {\n  return _isSafeInteger(v); // eliminates NaN, +/-Infinity, floats, unsafe ints\n}\n","////// valSafeInt validator\n\nimport {type, default as isSafeInt} from '../validation/isSafeInt';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valSafeInt._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.SAFE_INT SAFE_INT}\n * @const {string} rtvref.validator.valSafeInt.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valSafeInt.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.SAFE_INT SAFE_INT} type.\n *\n * Determines if a value is a number literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new Number(1)`, which is an object that is a number.\n *\n * @function rtvref.validator.valSafeInt.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.numeric_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valSafeInt(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isSafeInt(v);\n\n  if (valid && args) { // then check args against normal type range\n    if (isSafeInt(args.exact)) {\n      valid = (v === args.exact);\n    } else {\n      let min;\n      if (valid && isSafeInt(args.min)) {\n        min = args.min;\n        valid = (v >= min);\n      }\n\n      if (valid && isSafeInt(args.max)) {\n        if (min === undefined || args.max >= min) {\n          valid = (v <= args.max);\n        } // else, ignore\n      }\n    }\n  }\n\n  if (valid) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q, args), [],\n      impl.toTypeset(type, q, args, true));\n}\n","////// valSet validator\n\nimport {type, default as isSet} from '../validation/isSet';\n\nimport isFinite from '../validation/isFinite';\nimport isTypeset from '../validation/isTypeset';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\nimport {print} from '../util';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valSet._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.SET SET}\n * @const {string} rtvref.validator.valSet.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valSet.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.SET SET} type.\n * @function rtvref.validator.valSet.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.collection_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valSet(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isSet(v);\n  let result; // @type {(rtvref.RtvSuccess|rtvref.RtvError)}\n\n  if (valid && args) { // then check args\n    // start with the easiest/most efficient test: length\n    if (valid && isFinite(args.length) && args.length >= 0) {\n      valid = (v.size === args.length);\n    }\n\n    // remaining args, if specified, require iterating potentially the entire set\n    if (valid) {\n      // get the typeset for values\n      const tsValues = isTypeset(args.values) ? args.values : undefined;\n\n      if (tsValues) {\n        const it = v.values(); // iterator of straight values\n\n        for (let elem of it) {\n          result = impl.check(elem, tsValues); // check value against typeset\n          valid = result.valid;\n\n          if (!result.valid) {\n            // create a new error from the original, but with the value prepended to\n            //  the path (since sets don't have indexes; they just have unique values)\n            result = new RtvError(v, impl.toTypeset(type, q, args),\n                [print(elem)].concat(result.path), result.cause);\n          }\n\n          if (!valid) { // break on first invalid value\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (!result) {\n    if (valid) {\n      result = new RtvSuccess();\n    } else {\n      result = new RtvError(v, impl.toTypeset(type, q, args), [],\n          impl.toTypeset(type, q, args, true));\n    }\n  }\n\n  return result;\n}\n","////// valString validator\n\nimport {type, default as isString} from '../validation/isString';\n\nimport isFinite from '../validation/isFinite';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valString._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.STRING STRING}\n * @const {string} rtvref.validator.valString.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valString.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.STRING STRING} type.\n *\n * Determines if a value is a string literal __only__ (i.e. a\n *  {@link rtvref.types.primitives primitive}). It does not validate\n *  `new String('value')`, which is an object that is a string.\n *\n * @function rtvref.validator.valString.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @param {rtvref.types.STRING_args} [args] Type arguments.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valString(v, q = REQUIRED, args) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  let valid = isString(v) || (q !== REQUIRED && v === '');\n\n  if (valid && args) { // then check args\n    if (isString(args.exact)) { // empty string OK\n      valid = (v === args.exact);\n    } else {\n      let min;\n      if (valid && isFinite(args.min) && args.min >= 0) {\n        min = args.min;\n        valid = (v.length >= min);\n      }\n\n      if (valid && isFinite(args.max) && args.max >= 0) {\n        if (min === undefined || args.max >= min) {\n          valid = (v.length <= args.max);\n        } // else, ignore\n      }\n\n      if (valid && args.partial) {\n        valid = v.includes(args.partial);\n      }\n    }\n  }\n\n  if (valid) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q, args), [],\n      impl.toTypeset(type, q, args, true));\n}\n","////// isSymbol validation\n\nimport {default as _isSymbol} from 'lodash/isSymbol';\n\nimport types from '../types';\n\n/**\n * Type: {@link rtvref.types.SYMBOL SYMBOL}\n * @const {string} rtvref.validation.isSymbol.type\n */\nexport const type = types.SYMBOL;\n\n/**\n * {@link rtvref.validation.method Validation} for the\n *  {@link rtvref.types.SYMBOL SYMBOL} type.\n * @function rtvref.validation.isSymbol.default\n * @param {*} v Value to validate.\n * @returns {boolean} `true` if validated; `false` otherwise.\n */\nexport default function isSymbol(v) {\n  return _isSymbol(v);\n}\n","////// valSymbol validator\n\nimport {type, default as isSymbol} from '../validation/isSymbol';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valSymbol._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.SYMBOL SYMBOL}\n * @const {string} rtvref.validator.valSymbol.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valSymbol.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.SYMBOL SYMBOL} type.\n * @function rtvref.validator.valSymbol.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valSymbol(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isSymbol(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// valWeakMap validator\n\nimport {type, default as isWeakMap} from '../validation/isWeakMap';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valWeakMap._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.WEAK_MAP WEAK_MAP}\n * @const {string} rtvref.validator.valWeakMap.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valWeakMap.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.WEAK_MAP WEAK_MAP} type.\n * @function rtvref.validator.valWeakMap.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valWeakMap(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isWeakMap(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// valWeakSet validator\n\nimport {type, default as isWeakSet} from '../validation/isWeakSet';\n\nimport {default as qualifiers, nilPermitted} from '../qualifiers';\nimport RtvSuccess from '../RtvSuccess';\nimport RtvError from '../RtvError';\n\nconst {REQUIRED} = qualifiers;\nlet impl; // @type {rtvref.impl}\n\n/**\n * [Internal] __FOR UNIT TESTING ONLY:__ The {@link rtvref.impl} instance\n *  configured on this validator.\n * @private\n * @name rtvref.validator.valWeakSet._impl\n * @type {rtvref.impl}\n */\nexport {impl as _impl};\n\n/**\n * Type: {@link rtvref.types.WEAK_SET WEAK_SET}\n * @const {string} rtvref.validator.valWeakSet.type\n */\nexport {type};\n\n/**\n * {@link rtvref.validator.validator_config Configuration Function}\n  * @function rtvref.validator.valWeakSet.config\n * @param {rtvref.validator.validator_config_settings} settings Configuration settings.\n */\nexport const config = function(settings) {\n  impl = settings.impl;\n};\n\n/**\n * {@link rtvref.validator.type_validator Validator} for the\n *  {@link rtvref.types.WEAK_SET WEAK_SET} type.\n * @function rtvref.validator.valWeakSet.default\n * @param {*} v Value to validate.\n * @param {string} [q] Validation qualifier. Defaults to\n *  {@link rtvref.qualifiers.REQUIRED REQUIRED}.\n * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} An `RtvSuccess` if valid; `RtvError` if not.\n */\nexport default function valWeakSet(v, q = REQUIRED) {\n  if (nilPermitted(v, q)) {\n    return new RtvSuccess();\n  }\n\n  if (isWeakSet(v)) {\n    return new RtvSuccess();\n  }\n\n  return new RtvError(v, impl.toTypeset(type, q), [], impl.toTypeset(type, q, true));\n}\n","////// Main entry point\n\nimport {version as VERSION} from '../package.json';\nimport impl from './lib/impl';\nimport types from './lib/types';\nimport qualifiers from './lib/qualifiers';\nimport RtvSuccess from './lib/RtvSuccess';\nimport isTypeset from './lib/validation/isTypeset';\n\n// all known types\n// TODO[plugins]: In the future, with plugins, this should be dynamically-generated somehow.\nimport * as valAny from './lib/validator/valAny';\nimport * as valAnyObject from './lib/validator/valAnyObject';\nimport * as valArray from './lib/validator/valArray';\nimport * as valBoolean from './lib/validator/valBoolean';\nimport * as valClassObject from './lib/validator/valClassObject';\nimport * as valDate from './lib/validator/valDate';\nimport * as valError from './lib/validator/valError';\nimport * as valFinite from './lib/validator/valFinite';\nimport * as valFunction from './lib/validator/valFunction';\nimport * as valHashMap from './lib/validator/valHashMap';\nimport * as valInt from './lib/validator/valInt';\nimport * as valJson from './lib/validator/valJson';\nimport * as valMap from './lib/validator/valMap';\nimport * as valNull from './lib/validator/valNull';\nimport * as valNumber from './lib/validator/valNumber';\nimport * as valObject from './lib/validator/valObject';\nimport * as valPlainObject from './lib/validator/valPlainObject';\nimport * as valPromise from './lib/validator/valPromise';\nimport * as valRegExp from './lib/validator/valRegExp';\nimport * as valSafeInt from './lib/validator/valSafeInt';\nimport * as valSet from './lib/validator/valSet';\nimport * as valString from './lib/validator/valString';\nimport * as valSymbol from './lib/validator/valSymbol';\nimport * as valWeakMap from './lib/validator/valWeakMap';\nimport * as valWeakSet from './lib/validator/valWeakSet';\n\n/**\n * <h1>RTV.js Reference</h1>\n *\n * Members herein are _indirectly_ exposed through the {@link rtv} object.\n * @namespace rtvref\n */\n\n/**\n * <h2>Shape Descriptor</h2>\n *\n * Describes the shape (i.e. interface) of an object as a map of properties to\n *  {@link rtvref.types.typeset typesets}. Each typeset indicates whether the\n *  property is required, expected, or optional, using {@link rtvref.qualifiers qualifiers},\n *  along with possible types. Only enumerable, own-properties of the shape are\n *  considered part of the shape.\n *\n * When a value is {@link rtv.check checked} or {@link rtv.verify verified} against\n *  a given shape, _properties on the value that are not part of the shape are\n *  ignored_. If successfully checked/verified, the value is guaranteed to provide\n *  the properties described in the shape, and each property is guaranteed to be\n *  assigned to a value of at least one type described in each property's typeset.\n *\n * The shape descriptor itself must be an {@link rtvref.types.OBJECT OBJECT}.\n *\n * @typedef {Object} rtvref.shape_descriptor\n * @see {@link rtvref.validation.isShape}\n */\n\n/**\n * <h1>RTV.js</h1>\n *\n * Runtime Verification Library for browsers and Node.js.\n * @namespace rtv\n */\nconst rtv = {\n  /**\n   * Enumeration of {@link rtvref.types types}.\n   * @name rtv.t\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  t: types,\n\n  /**\n   * Enumeration of {@link rtvref.qualifiers qualifiers}.\n   * @name rtv.q\n   * @type {rtvref.Enumeration.<String,String>}\n   */\n  q: qualifiers,\n\n  /**\n   * Determines if a value is a typeset.\n   * @function rtv.isTypeset\n   * @see {@link rtvref.validation.isTypeset.default}\n   */\n  isTypeset,\n\n  /**\n   * Checks a value against a typeset for compliance.\n   * @function rtv.check\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the\n   *  `value` is compliant to the `shape`; `RtvError` if not. __Unlike\n   *  {@link rtv.verify verify()}, an exception is not thrown__ if the\n   *  `value` is non-compliant.\n   *\n   *  Since both {@link rtvref.RtvSuccess RtvSuccess}, returned when\n   *   the check succeeds, as well as {@link rtvref.RtvError RtvError}, returned\n   *   when the check fails, have a `valid: boolean` property in common, it's\n   *   easy to test for success/failure like this:\n   *   `if (rtv.check(2, rtv.t.FINITE).valid) {...}`.\n   *\n   *  __NOTE:__ This method always returns a success indicator if RTV.js is currently\n   *   {@link rtv.config.enabled disabled}.\n   *\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.verify}\n   * @see {@link rtv.config.enabled}\n   * @see {@link rtvref.types}\n   * @see {@link rtvref.shape_descriptor}\n   */\n  check(value, typeset) {\n    if (this.config.enabled) {\n      return impl.check(value, typeset);\n    }\n\n    return new RtvSuccess();\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.check}.\n   * @function rtv.c\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {(rtvref.RtvSuccess|rtvref.RtvError)} Success indicator if the\n   *  `value` is compliant to the `shape`; `RtvError` if not. __Unlike\n   *  {@link rtv.verify verify()}, an exception is not thrown__ if the\n   *  `value` is non-compliant.\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.check}\n   */\n  c(value, typeset) {\n    return this.check(value, typeset);\n  },\n\n  /**\n   * __Requires__ a value to be compliant to a shape.\n   *\n   * NOTE: This method does nothing if RTV.js is currently\n   *  {@link rtv.config.enabled disabled}.\n   *\n   * @function rtv.verify\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {rtvref.RtvSuccess} Success indicator IIF the `value` is compliant\n   *  to the `shape`. Otherwise, an {@link rtvref.RtvError RtvError} __is thrown__.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @throws {Error} If `typeset` is not a valid typeset.\n   * @see {@link rtv.check}\n   * @see {@link rtv.config.enabled}\n   * @see {@link rtvref.types}\n   * @see {@link rtvref.shape_descriptor}\n   */\n  verify(value, typeset) {\n    if (this.config.enabled) {\n      const result = this.check(value, typeset);\n      if (result instanceof RtvSuccess) {\n        return result;\n      }\n\n      throw result; // expected to be an RtvError\n    }\n\n    return new RtvSuccess();\n  },\n\n  /**\n   * Shortcut proxy to {@link rtv.verify}.\n   * @param {*} value Value to check.\n   * @param {rtvref.types.typeset} typeset Expected shape of (or typeset describing)\n   *  the `value`. A shape is a kind of typeset. Normally, this is a\n   *  {@link rtvref.shape_descriptor shape descriptor}.\n   * @returns {rtvref.RtvSuccess} Success indicator IIF the `value` is compliant\n   *  to the `shape`. Otherwise, an {@link rtvref.RtvError RtvError} __is thrown__.\n   * @throws {RtvError} If the `value` is not compliant to the `shape`.\n   * @see {@link rtv.verify}\n   */\n  v(value, typeset) {\n    return this.verify(value, typeset);\n  },\n\n  /**\n   * RTV Library Configuration\n   * @namespace rtv.config\n   */\n  config: Object.defineProperties({}, {\n    /**\n     * Globally enables or disables {@link rtv.verify} and {@link rtv.check}.\n     *\n     * Use this, or the shortcut {@link rtv.e}, to enable code optimization\n     *  when building source with a bundler that supports _tree shaking_ like\n     *  {@link https://rollupjs.org/ Rollup} or {@link https://webpack.js.org/ Webpack}.\n     *\n     * <h4>Example</h4>\n     *\n     * By conditionally calling {@link rtv.verify} based on the state of\n     *  {@link rtv.config.enabled}, a bundler can be configured to completely\n     *  remove the code from a production build.\n     *\n     * // TODO: Add Rollup and Webpack examples.\n     *\n     * <pre><code>if (rtv.config.enabled) {\n     *  rtv.verify(jsonResult, expectedShape);\n     * }\n     *\n     * rtv.e && rtv.v(jsonResult, expectedShape); // even shorter\n     * </code></pre>\n     *\n     * @name rtv.config.enabled\n     * @type {boolean}\n     * @see {@link rtv.enabled}\n     */\n    enabled: (function() {\n      let value = true;\n      return {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return value;\n        },\n        set(newValue) {\n          rtv.verify(newValue, rtv.t.BOOLEAN);\n          value = newValue;\n        }\n      };\n    })()\n  }),\n\n  /**\n   * Shortcut proxy for reading {@link rtv.config.enabled}.\n   * @readonly\n   * @name rtv.e\n   * @type {boolean}\n   */\n  get e() {\n    return this.config.enabled;\n  }\n};\n\n/**\n * [Internal] Library version.\n * @private\n * @name rtv._version\n * @type {string}\n */\nObject.defineProperty(rtv, '_version', {\n  enumerable: false, // internal\n  configurable: true,\n  writable: true,\n  value: VERSION\n});\n\nexport default rtv;\n\n////////////////////////////////////////////////////////////////////////////////\n// Register all known types with impl\n\n(function() { // put in an IIFE so there's nothing unnecessarily retained in any closures\n  // TODO[plugins]: In the future, with plugins, this should be dynamically-generated somehow.\n  const validators = [\n    valAny,\n    valAnyObject,\n    valArray,\n    valBoolean,\n    valClassObject,\n    valDate,\n    valError,\n    valFinite,\n    valFunction,\n    valHashMap,\n    valInt,\n    valJson,\n    valNull,\n    valMap,\n    valNumber,\n    valObject,\n    valPlainObject,\n    valPromise,\n    valRegExp,\n    valSafeInt,\n    valSet,\n    valString,\n    valSymbol,\n    valWeakMap,\n    valWeakSet\n  ];\n\n  const publicImpl = {}; // impl for validators, excluding any internal parts\n\n  Object.keys(impl).forEach(function(k) { // only enumerable methods/properties\n    publicImpl[k] = impl[k];\n  });\n\n  validators.forEach(function(val) {\n    val.config({impl: publicImpl});\n    impl._registerType(val);\n  });\n})();\n"],"names":["print","printValue","replacer","stringifying","key","value","undefined","toString","result","JSON","stringify","bind","Enumeration","map","name","keys","Object","values","length","Error","forEach","indexOf","push","defineProperty","enumerable","configurable","get","concat","$values","silent","check","$name","join","pairs","k","def","hasArgs","isObject","defs","ANY","NULL","STRING","BOOLEAN","SYMBOL","NUMBER","FINITE","INT","SAFE_INT","FLOAT","FUNCTION","REGEXP","DATE","ERROR","PROMISE","ARRAY","ANY_OBJECT","OBJECT","PLAIN_OBJECT","CLASS_OBJECT","HASH_MAP","MAP","WEAK_MAP","SET","WEAK_SET","DEFAULT_OBJECT_TYPE","objTypes","types","argTypes","type","isArray","v","_isArray","global","freeGlobal","Symbol","root","objectProto","nativeObjectToString","symToStringTag","getRawTag","objectToString","baseGetTag","coreJsData","funcProto","funcToString","hasOwnProperty","isMasked","isFunction","toSource","getValue","baseIsNative","getNative","Map","Promise","DataView","Set","WeakMap","mapTag","isObjectLike","getTag","nodeUtil","baseUnary","baseIsMap","isMap","_isMap","weakMapTag","isWeakMap","_isWeakMap","setTag","baseIsSet","isSet","_isSet","isWeakSet","_isWeakSet","baseIsRegExp","isRegExp","_isRegExp","baseIsDate","isDate","_isDate","overArg","objectTag","getPrototype","isPlainObject","isError","_isError","isPromise","_isObjectLike","String","Number","Boolean","isString","allowEmpty","_isFunction","isBoolean","createBaseFor","baseIsArguments","stubFalse","MAX_SAFE_INTEGER","argsTag","dateTag","errorTag","funcTag","regexpTag","dataViewTag","isLength","baseIsTypedArray","isArguments","isBuffer","isTypedArray","baseTimes","isIndex","isPrototype","nativeKeys","isArrayLike","arrayLikeKeys","baseKeys","baseFor","createBaseEach","baseForOwn","identity","arrayEach","baseEach","castFunction","isShape","isTypeArgs","isValidator","REQUIRED","EXPECTED","OPTIONAL","DEFAULT_QUALIFIER","nilPermitted","q","deepVerifyShape","rule","options","failurePrefix","idx","valid","shape","failure","_forEach","ts","prop","opts","assign","isTypeset","deepVerifyArray","typeset","deep","fullyQualified","usedTypes","curType","argType","updateCurType","newType","qualifiers","hasQualifier","RtvSuccess","defineProperties","extendsFrom","renderPath","path","reduce","strPath","elem","RtvError","cause","call","message","prototype","create","constructor","_validatorMap","getQualifier","qualifier","toTypeset","rest","params","filter","p","typeArgs","typeArgsGiven","verify","fullyQualify","fqts","i","extractNextType","subtype","shift","_getCheckOptions","current","override","checkWithType","singleType","arguments","args","singleTypeCopy","checkWithShape","checkWithArray","match","typesetCopy","err","lastType","fqMatch","checkErr","rootCause","_registerType","validator","config","default","impl","writable","settings","valAny","isAnyObject","_isObject","valAnyObject","isFinite","_isFinite","valArray","min","max","valBoolean","_isPlainObject","isClassObject","valClassObject","ctr","propResult","valDate","valError","valFinite","exact","valFunction","isHashMap","valHashMap","keyExp","keyFlagSpec","tsValues","reKeys","RegExp","test","isSymbol","toNumber","toFinite","toInteger","isInt","_isInteger","valInt","isNull","isJson","valJson","isStringTypeset","valMap","size","tsKeys","tsKeysIsString","it","entries","valNull","numberTag","isNumber","_isNaN","valNumber","valObject","valPlainObject","valPromise","valRegExp","isInteger","isSafeInt","_isSafeInteger","valSafeInt","valSet","valString","partial","includes","_isSymbol","valSymbol","valWeakMap","valWeakSet","rtv","t","enabled","c","set","newValue","e","VERSION","validators","publicImpl","val"],"mappings":"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"}